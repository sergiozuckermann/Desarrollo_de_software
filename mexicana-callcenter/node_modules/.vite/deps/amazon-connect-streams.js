import {
  __publicField,
  __require
} from "./chunk-WGAPYIUP.js";

// node_modules/amazon-connect-streams/release/connect-streams.js
(() => {
  var __webpack_modules__ = {
    /***/
    821: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          connect2.agentApp = {};
          var APP = {
            CCP: "ccp",
            GUIDES: "customviews"
          };
          connect2.agentApp.initCCP = connect2.core.initCCP;
          connect2.agentApp.isInitialized = function(instanceAlias) {
          };
          connect2.agentApp.initAppCommunication = function(iframeId, endpoint) {
            var iframe = document.getElementById(iframeId);
            var iframeConduit = new connect2.IFrameConduit(endpoint, window, iframe);
            var BROADCAST_TYPE = [
              connect2.AgentEvents.UPDATE,
              connect2.ContactEvents.VIEW,
              connect2.EventType.ACKNOWLEDGE,
              connect2.EventType.TERMINATED,
              connect2.TaskEvents.CREATED
            ];
            iframe.addEventListener("load", function(e) {
              BROADCAST_TYPE.forEach(function(type) {
                connect2.core.getUpstream().onUpstream(type, function(data) {
                  iframeConduit.sendUpstream(type, data);
                });
              });
            });
          };
          var getConnectUrl = function(ccpUrl) {
            var pos = ccpUrl.indexOf("ccp-v2");
            return ccpUrl.slice(0, pos - 1);
          };
          var signOutThroughCCP = function(ccpUrl) {
            var logoutUrl = getConnectUrl(ccpUrl) + "/logout";
            return connect2.fetch(logoutUrl, {
              credentials: "include"
            }).then(function() {
              var eventBus = connect2.core.getEventBus();
              eventBus.trigger(connect2.EventType.TERMINATE);
              return true;
            }).catch(function(e) {
              connect2.getLog().error("An error occured on logout." + e).withException(e);
              window.location.href = logoutUrl;
              return false;
            });
          };
          var removeAppData = function(appName) {
            connect2.agentApp.AppRegistry.delete(appName);
          };
          var initCustomViewsApp = function(connectUrl, containerDOM, config) {
            const { contact, disableAutoDestroy, iframeSuffix, terminateCustomViewOptions = {} } = config.customViewsParams;
            let { contactFlowId } = config.customViewsParams;
            let contactId, appName;
            if (contact !== void 0) {
              contactId = extractContactId(contact);
              if (contactId && disableAutoDestroy !== true && typeof contact !== "string") {
                contact.onDestroy((contact2) => {
                  connect2.core.terminateCustomView(
                    connectUrl,
                    iframeSuffix,
                    {
                      timeout: terminateCustomViewOptions.timeout || 5e3,
                      hideIframe: terminateCustomViewOptions.hideIframe !== void 0 ? terminateCustomViewOptions.hideIframe : true,
                      resolveIframe: terminateCustomViewOptions.resolveIframe !== void 0 ? terminateCustomViewOptions.resolveIframe : true
                    }
                  );
                });
              }
              if (!contactFlowId) {
                console.warn("[CustomViews]: Need to provide a contactFlowId when defining contact parameter for initalizing customviews application");
              }
            }
            if (iframeSuffix) {
              appName = `${APP.GUIDES}${iframeSuffix}`;
            } else {
              appName = `${APP.GUIDES}`;
            }
            const iframeIdSelector = `iframe[id='${appName}']`;
            const iframe = (containerDOM == null ? void 0 : containerDOM.querySelector(iframeIdSelector)) || document.getElementById(appName) || window.top.document.getElementById(appName);
            if (iframe) {
              const tabId = AWS.util.uuid.v4();
              if (contactId) {
                iframe.src = `${connectUrl}?contactFlowId=${contactFlowId}&currentContactId=${contactId}&agentAppTabId=${tabId}-tab`;
              } else if (contactFlowId) {
                iframe.src = `${connectUrl}?contactFlowId=${contactFlowId}&agentAppTabId=${tabId}-tab`;
              }
            } else {
              throw new Error("[CustomViews]: No iframe found for the app: ", appName);
            }
          };
          var extractContactId = function(contact) {
            if (typeof contact === "string") {
              return contact;
            }
            try {
              return contact.getContactId();
            } catch {
              console.error("[CustomViews]: Invalid Contact Provided: ", contact);
              return void 0;
            }
          };
          var signInThroughinitCCP = function(ccpUrl, container, config) {
            var defaultParams = {
              ccpUrl,
              ccpLoadTimeout: 1e4,
              loginPopup: true,
              loginUrl: getConnectUrl(ccpUrl) + "/login",
              softphone: {
                allowFramedSoftphone: true,
                disableRingtone: false,
                allowFramedVideoCall: true
              }
            };
            var ccpParams = connect2.merge(defaultParams, config.ccpParams);
            connect2.core.initCCP(container, ccpParams);
          };
          connect2.agentApp.initApp = function(name, containerId, appUrl, config) {
            config = config ? config : {};
            var endpoint = appUrl.endsWith("/") ? appUrl : appUrl + "/";
            var onLoad = config.onLoad ? config.onLoad : null;
            var registerConfig = { endpoint, style: config.style, onLoad };
            var filteredName;
            if (name === APP.CCP_DR) {
              filteredName = APP.CCP;
            } else if (name === APP.GUIDES && config.customViewsParams) {
              const { iframeSuffix } = config.customViewsParams;
              if (iframeSuffix) {
                filteredName = `${APP.GUIDES}${iframeSuffix}`;
              } else {
                filteredName = `${APP.GUIDES}`;
              }
              if (connect2.agentApp.AppRegistry.get(filteredName) !== void 0) {
                throw new Error("[CustomViews]: Custom views application with the same name already exists. Please provide a different iframeSuffix for the custom views application.");
              }
            } else {
              filteredName = name;
            }
            var containerElement = typeof containerId === "string" ? document.getElementById(containerId) : containerId;
            connect2.agentApp.AppRegistry.register(filteredName, registerConfig, containerElement);
            connect2.agentApp.AppRegistry.start(filteredName, function(moduleData) {
              var endpoint2 = moduleData.endpoint;
              var containerDOM = moduleData.containerDOM;
              return {
                init: function() {
                  switch (name) {
                    case APP.CCP:
                      config.ccpParams = config.ccpParams ? config.ccpParams : {};
                      if (config.style)
                        config.ccpParams.style = config.style;
                      return signInThroughinitCCP(endpoint2, containerDOM, config);
                    case APP.GUIDES:
                      if (config.customViewsParams !== void 0) {
                        connect2.agentApp.initAppCommunication(filteredName, endpoint2, containerDOM);
                        return initCustomViewsApp(endpoint2, containerDOM, config);
                      } else {
                        return connect2.agentApp.initAppCommunication(filteredName, endpoint2, containerDOM);
                      }
                    default:
                      return connect2.agentApp.initAppCommunication(filteredName, endpoint2, containerDOM);
                  }
                },
                destroy: function() {
                  switch (name) {
                    case APP.CCP:
                      return signOutThroughCCP(endpoint2);
                    case APP.GUIDES:
                      if (config.customViewsParams !== void 0) {
                        return removeAppData(filteredName);
                      } else {
                        return null;
                      }
                    default:
                      return null;
                  }
                }
              };
            });
          };
          connect2.agentApp.stopApp = function(name) {
            return connect2.agentApp.AppRegistry.stop(name);
          };
        })();
      }
    ),
    /***/
    500: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          var APP = {
            CCP: "ccp"
          };
          function AppRegistry() {
            var moduleData = {};
            var makeAppIframe = function(appName, endpoint, style, onLoad) {
              var iframe = document.createElement("iframe");
              iframe.src = endpoint;
              iframe.style = style || "width: 100%; height:100%;";
              iframe.id = appName;
              iframe["aria-label"] = appName;
              iframe.onload = onLoad;
              iframe.allow = "clipboard-read; clipboard-write";
              iframe.setAttribute(
                "sandbox",
                "allow-forms allow-popups allow-popups-to-escape-sandbox allow-same-origin allow-scripts"
              );
              return iframe;
            };
            return {
              register: function(appName, config, containerDOM) {
                moduleData[appName] = {
                  containerDOM,
                  endpoint: config.endpoint,
                  style: config.style,
                  instance: void 0,
                  onLoad: config.onLoad
                };
              },
              start: function(appName, creator) {
                if (!moduleData[appName])
                  return;
                var containerDOM = moduleData[appName].containerDOM;
                var endpoint = moduleData[appName].endpoint;
                var style = moduleData[appName].style;
                var onLoad = moduleData[appName].onLoad;
                if (appName !== APP.CCP) {
                  var app = makeAppIframe(appName, endpoint, style, onLoad);
                  containerDOM.appendChild(app);
                }
                moduleData[appName].instance = creator(moduleData[appName]);
                return moduleData[appName].instance.init();
              },
              get: function(appName) {
                return moduleData[appName];
              },
              delete: function(appName) {
                delete moduleData[appName];
              },
              stop: function(appName) {
                if (!moduleData[appName])
                  return;
                var data = moduleData[appName];
                var app = data.containerDOM.querySelector("iframe");
                if (appName.includes("customviews")) {
                  const iframeIdSelector = `iframe[id='${appName}']`;
                  app = data.containerDOM.querySelector(iframeIdSelector);
                }
                data.containerDOM.removeChild(app);
                var result;
                if (data.instance) {
                  result = data.instance.destroy();
                  delete data.instance;
                }
                return result;
              }
            };
          }
          global.connect.agentApp.AppRegistry = AppRegistry();
        })();
      }
    ),
    /***/
    965: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          connect2.AgentStateType = connect2.makeEnum([
            "init",
            "routable",
            "not_routable",
            "offline"
          ]);
          connect2.AgentStatusType = connect2.AgentStateType;
          connect2.AgentAvailStates = connect2.makeEnum([
            "Init",
            "Busy",
            "AfterCallWork",
            "CallingCustomer",
            "Dialing",
            "Joining",
            "PendingAvailable",
            "PendingBusy"
          ]);
          connect2.AgentErrorStates = connect2.makeEnum([
            "Error",
            "AgentHungUp",
            "BadAddressAgent",
            "BadAddressCustomer",
            "Default",
            "FailedConnectAgent",
            "FailedConnectCustomer",
            "InvalidLocale",
            "LineEngagedAgent",
            "LineEngagedCustomer",
            "MissedCallAgent",
            "MissedCallCustomer",
            "MultipleCcpWindows",
            "RealtimeCommunicationError"
          ]);
          connect2.EndpointType = connect2.makeEnum([
            "phone_number",
            "agent",
            "queue"
          ]);
          connect2.AddressType = connect2.EndpointType;
          connect2.ConnectionType = connect2.makeEnum([
            "agent",
            "inbound",
            "outbound",
            "monitoring"
          ]);
          connect2.ConnectionStateType = connect2.makeEnum([
            "init",
            "connecting",
            "connected",
            "hold",
            "disconnected",
            "silent_monitor",
            "barge"
          ]);
          connect2.ConnectionStatusType = connect2.ConnectionStateType;
          connect2.CONNECTION_ACTIVE_STATES = connect2.set([
            connect2.ConnectionStateType.CONNECTING,
            connect2.ConnectionStateType.CONNECTED,
            connect2.ConnectionStateType.HOLD,
            connect2.ConnectionStateType.SILENT_MONITOR,
            connect2.ConnectionStateType.BARGE
          ]);
          connect2.CONNECTION_CONNECTED_STATES = connect2.set([
            connect2.ConnectionStateType.CONNECTED,
            connect2.ConnectionStateType.SILENT_MONITOR,
            connect2.ConnectionStateType.BARGE
          ]);
          connect2.ContactStateType = connect2.makeEnum([
            "init",
            "incoming",
            "pending",
            "connecting",
            "connected",
            "missed",
            "error",
            "ended",
            "rejected",
            "paused"
          ]);
          connect2.ContactStatusType = connect2.ContactStateType;
          connect2.CONTACT_ACTIVE_STATES = connect2.makeEnum([
            "paused",
            "incoming",
            "pending",
            "connecting",
            "connected"
          ]);
          connect2.ContactType = connect2.makeEnum([
            "voice",
            "queue_callback",
            "chat",
            "task"
          ]);
          connect2.ContactInitiationMethod = connect2.makeEnum([
            "inbound",
            "outbound",
            "transfer",
            "queue_transfer",
            "callback",
            "api",
            "disconnect",
            "webrtc_api"
          ]);
          connect2.MonitoringMode = connect2.makeEnum([
            "SILENT_MONITOR",
            "BARGE"
          ]);
          connect2.MonitoringErrorTypes = connect2.makeEnum([
            "invalid_target_state"
          ]);
          connect2.ChannelType = connect2.makeEnum([
            "VOICE",
            "CHAT",
            "TASK"
          ]);
          connect2.MediaType = connect2.makeEnum([
            "softphone",
            "chat",
            "task"
          ]);
          connect2.SoftphoneCallType = connect2.makeEnum([
            "audio_video",
            "video_only",
            "audio_only",
            "none"
          ]);
          connect2.SoftphoneErrorTypes = connect2.makeEnum([
            "unsupported_browser",
            "microphone_not_shared",
            "signalling_handshake_failure",
            "signalling_connection_failure",
            "ice_collection_timeout",
            "user_busy_error",
            "webrtc_error",
            "realtime_communication_error",
            "vdi_strategy_not_supported",
            "vdi_redir_not_supported",
            "other"
          ]);
          connect2.ClickType = connect2.makeEnum([
            "Accept",
            "Reject",
            "Hangup"
          ]);
          connect2.VoiceIdErrorTypes = connect2.makeEnum([
            "no_speaker_id_found",
            "speaker_id_not_enrolled",
            "get_speaker_id_failed",
            "get_speaker_status_failed",
            "opt_out_speaker_failed",
            "opt_out_speaker_in_lcms_failed",
            "delete_speaker_failed",
            "start_session_failed",
            "evaluate_speaker_failed",
            "session_not_exists",
            "describe_session_failed",
            "enroll_speaker_failed",
            "update_speaker_id_failed",
            "update_speaker_id_in_lcms_failed",
            "not_supported_on_conference_calls",
            "enroll_speaker_timeout",
            "evaluate_speaker_timeout",
            "get_domain_id_failed",
            "no_domain_id_found"
          ]);
          connect2.CTIExceptions = connect2.makeEnum([
            "AccessDeniedException",
            "InvalidStateException",
            "BadEndpointException",
            "InvalidAgentARNException",
            "InvalidConfigurationException",
            "InvalidContactTypeException",
            "PaginationException",
            "RefreshTokenExpiredException",
            "SendDataFailedException",
            "UnauthorizedException",
            "QuotaExceededException"
          ]);
          connect2.VoiceIdStreamingStatus = connect2.makeEnum([
            "ONGOING",
            "ENDED",
            "PENDING_CONFIGURATION"
          ]);
          connect2.VoiceIdAuthenticationDecision = connect2.makeEnum([
            "ACCEPT",
            "REJECT",
            "NOT_ENOUGH_SPEECH",
            "SPEAKER_NOT_ENROLLED",
            "SPEAKER_OPTED_OUT",
            "SPEAKER_ID_NOT_PROVIDED",
            "SPEAKER_EXPIRED"
          ]);
          connect2.VoiceIdFraudDetectionDecision = connect2.makeEnum([
            "NOT_ENOUGH_SPEECH",
            "HIGH_RISK",
            "LOW_RISK"
          ]);
          connect2.ContactFlowAuthenticationDecision = connect2.makeEnum([
            "Authenticated",
            "NotAuthenticated",
            "Inconclusive",
            "NotEnrolled",
            "OptedOut",
            "NotEnabled",
            "Error"
          ]);
          connect2.ContactFlowFraudDetectionDecision = connect2.makeEnum([
            "HighRisk",
            "LowRisk",
            "Inconclusive",
            "NotEnabled",
            "Error"
          ]);
          connect2.VideoCapability = connect2.makeEnum([
            "SEND"
          ]);
          connect2.VoiceIdEnrollmentRequestStatus = connect2.makeEnum([
            "NOT_ENOUGH_SPEECH",
            "IN_PROGRESS",
            "COMPLETED",
            "FAILED"
          ]);
          connect2.VoiceIdSpeakerStatus = connect2.makeEnum([
            "OPTED_OUT",
            "ENROLLED",
            "PENDING"
          ]);
          connect2.VoiceIdConstants = {
            EVALUATE_SESSION_DELAY: 1e4,
            EVALUATION_MAX_POLL_TIMES: 24,
            // EvaluateSpeaker is Polling for maximum 2 mins.
            EVALUATION_POLLING_INTERVAL: 5e3,
            ENROLLMENT_MAX_POLL_TIMES: 120,
            // EnrollmentSpeaker is Polling for maximum 10 mins.
            ENROLLMENT_POLLING_INTERVAL: 5e3,
            START_SESSION_DELAY: 8e3
          };
          connect2.AgentPermissions = {
            OUTBOUND_CALL: "outboundCall",
            VOICE_ID: "voiceId"
          };
          class QuickResponses {
          }
          __publicField(QuickResponses, "isEnabled", function() {
            const client = connect2.isCRM() ? connect2.core.getClient() : connect2.core.getApiProxyClient();
            return new Promise(function(resolve, reject) {
              client.call(connect2.ApiProxyClientMethods.QR_INTEGRATION_EXISTS, null, {
                success: function(data) {
                  connect2.getLog().info("Quick Responses isEnabled succeeded").withObject(data).sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err) {
                  connect2.getLog().error("Quick Responses isEnabled failed").withException(err).sendInternalLogToServer();
                  reject(err);
                }
              });
            });
          });
          __publicField(QuickResponses, "searchQuickResponses", function(params) {
            const client = connect2.isCRM() ? connect2.core.getClient() : connect2.core.getApiProxyClient();
            const attributes = (params == null ? void 0 : params.contactId) ? new Contact(params.contactId).getAttributes() : void 0;
            return new Promise(function(resolve, reject) {
              client.call(connect2.ApiProxyClientMethods.QR_SEARCH_QUICK_RESPONSES, {
                ...params,
                attributes
              }, {
                success: function(data) {
                  connect2.getLog().info("searchQuickResponses succeeded").withObject(data).sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err) {
                  connect2.getLog().error("searchQuickResponses failed").withException(err).sendInternalLogToServer();
                  reject(err);
                }
              });
            });
          });
          ;
          var Agent = function() {
            if (!connect2.agent.initialized) {
              throw new connect2.StateError("The agent is not yet initialized!");
            }
          };
          Agent.prototype._getData = function() {
            return connect2.core.getAgentDataProvider().getAgentData();
          };
          Agent.prototype._createContactAPI = function(contactData) {
            return new connect2.Contact(contactData.contactId);
          };
          Agent.prototype.onRefresh = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.REFRESH, f);
          };
          Agent.prototype.onRoutable = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.ROUTABLE, f);
          };
          Agent.prototype.onNotRoutable = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.NOT_ROUTABLE, f);
          };
          Agent.prototype.onOffline = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.OFFLINE, f);
          };
          Agent.prototype.onError = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.ERROR, f);
          };
          Agent.prototype.onSoftphoneError = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.SOFTPHONE_ERROR, f);
          };
          Agent.prototype.onWebSocketConnectionLost = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.WEBSOCKET_CONNECTION_LOST, f);
          };
          Agent.prototype.onWebSocketConnectionGained = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.WEBSOCKET_CONNECTION_GAINED, f);
          };
          Agent.prototype.onAfterCallWork = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.ACW, f);
          };
          Agent.prototype.onStateChange = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.STATE_CHANGE, f);
          };
          Agent.prototype.onMuteToggle = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.AgentEvents.MUTE_TOGGLE, f);
          };
          Agent.prototype.onLocalMediaStreamCreated = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.AgentEvents.LOCAL_MEDIA_STREAM_CREATED, f);
          };
          Agent.prototype.onSpeakerDeviceChanged = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.SPEAKER_DEVICE_CHANGED, f);
          };
          Agent.prototype.onMicrophoneDeviceChanged = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.MICROPHONE_DEVICE_CHANGED, f);
          };
          Agent.prototype.onRingerDeviceChanged = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.RINGER_DEVICE_CHANGED, f);
          };
          Agent.prototype.onCameraDeviceChanged = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.CAMERA_DEVICE_CHANGED, f);
          };
          Agent.prototype.onBackgroundBlurChanged = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.BACKGROUND_BLUR_CHANGED, f);
          };
          Agent.prototype.mute = function() {
            connect2.core.getUpstream().sendUpstream(
              connect2.EventType.BROADCAST,
              {
                event: connect2.EventType.MUTE,
                data: { mute: true }
              }
            );
          };
          Agent.prototype.unmute = function() {
            connect2.core.getUpstream().sendUpstream(
              connect2.EventType.BROADCAST,
              {
                event: connect2.EventType.MUTE,
                data: { mute: false }
              }
            );
          };
          Agent.prototype.setSpeakerDevice = function(deviceId) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.SET_SPEAKER_DEVICE,
              data: { deviceId }
            });
          };
          Agent.prototype.setMicrophoneDevice = function(deviceId) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.SET_MICROPHONE_DEVICE,
              data: { deviceId }
            });
          };
          Agent.prototype.setRingerDevice = function(deviceId) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.SET_RINGER_DEVICE,
              data: { deviceId }
            });
          };
          Agent.prototype.setCameraDevice = function(deviceId) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.CAMERA_DEVICE_CHANGED,
              data: { deviceId }
            });
          };
          Agent.prototype.setBackgroundBlur = function(isBackgroundBlurEnabled) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.BACKGROUND_BLUR_CHANGED,
              data: { isBackgroundBlurEnabled }
            });
          };
          Agent.prototype.getState = function() {
            return this._getData().snapshot.state;
          };
          Agent.prototype.getNextState = function() {
            return this._getData().snapshot.nextState;
          };
          Agent.prototype.getAvailabilityState = function() {
            return this._getData().snapshot.agentAvailabilityState;
          };
          Agent.prototype.getStatus = Agent.prototype.getState;
          Agent.prototype.getStateDuration = function() {
            return connect2.now() - this._getData().snapshot.state.startTimestamp.getTime() + connect2.core.getSkew();
          };
          Agent.prototype.getStatusDuration = Agent.prototype.getStateDuration;
          Agent.prototype.getPermissions = function() {
            return this.getConfiguration().permissions;
          };
          Agent.prototype.getContacts = function(contactTypeFilter) {
            var self2 = this;
            return this._getData().snapshot.contacts.map(function(contactData) {
              return self2._createContactAPI(contactData);
            }).filter(function(contact) {
              return !contactTypeFilter || contact.getType() === contactTypeFilter;
            });
          };
          Agent.prototype.getConfiguration = function() {
            return this._getData().configuration;
          };
          Agent.prototype.getAgentStates = function() {
            return this.getConfiguration().agentStates;
          };
          Agent.prototype.getRoutingProfile = function() {
            return this.getConfiguration().routingProfile;
          };
          Agent.prototype.getChannelConcurrency = function(channel) {
            var channelConcurrencyMap = this.getRoutingProfile().channelConcurrencyMap;
            if (!channelConcurrencyMap) {
              channelConcurrencyMap = Object.keys(connect2.ChannelType).reduce(function(acc, key) {
                if (key !== "TASK") {
                  acc[connect2.ChannelType[key]] = 1;
                }
                return acc;
              }, {});
            }
            return channel ? channelConcurrencyMap[channel] || 0 : channelConcurrencyMap;
          };
          Agent.prototype.getName = function() {
            return this.getConfiguration().name;
          };
          Agent.prototype.getAgentARN = function() {
            return this.getConfiguration().agentARN;
          };
          Agent.prototype.getExtension = function() {
            return this.getConfiguration().extension;
          };
          Agent.prototype.getDialableCountries = function() {
            return this.getConfiguration().dialableCountries;
          };
          Agent.prototype.isSoftphoneEnabled = function() {
            return this.getConfiguration().softphoneEnabled;
          };
          Agent.prototype.setConfiguration = function(configuration, callbacks) {
            var client = connect2.core.getClient();
            if (configuration && configuration.agentPreferences && configuration.agentPreferences.LANGUAGE && !configuration.agentPreferences.locale) {
              configuration.agentPreferences.locale = configuration.agentPreferences.LANGUAGE;
            }
            if (configuration && configuration.agentPreferences && !connect2.isValidLocale(configuration.agentPreferences.locale)) {
              if (callbacks && callbacks.failure) {
                callbacks.failure(connect2.AgentErrorStates.INVALID_LOCALE);
              }
            } else {
              client.call(connect2.ClientMethods.UPDATE_AGENT_CONFIGURATION, {
                configuration: connect2.assertNotNull(configuration, "configuration")
              }, {
                success: function(data) {
                  var conduit = connect2.core.getUpstream();
                  conduit.sendUpstream(connect2.EventType.RELOAD_AGENT_CONFIGURATION);
                  if (callbacks.success) {
                    callbacks.success(data);
                  }
                },
                failure: callbacks && callbacks.failure
              });
            }
          };
          Agent.prototype.setState = function(state, callbacks, options) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.PUT_AGENT_STATE, {
              state: connect2.assertNotNull(state, "state"),
              enqueueNextState: options && !!options.enqueueNextState
            }, callbacks);
          };
          Agent.prototype.onEnqueuedNextState = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.AgentEvents.ENQUEUED_NEXT_STATE, f);
          };
          Agent.prototype.setStatus = Agent.prototype.setState;
          Agent.prototype.connect = function(endpointIn, params) {
            var client = connect2.core.getClient();
            var endpoint = new connect2.Endpoint(endpointIn);
            delete endpoint.endpointId;
            var callParams = {
              endpoint: connect2.assertNotNull(endpoint, "endpoint"),
              queueARN: params && (params.queueARN || params.queueId) || this.getRoutingProfile().defaultOutboundQueue.queueARN
            };
            if (params && params.relatedContactId && params.relatedContactId !== null) {
              callParams.relatedContactId = params.relatedContactId;
              if (params.previousContactId) {
                delete callParams.previousContactId;
              }
            }
            client.call(connect2.ClientMethods.CREATE_OUTBOUND_CONTACT, callParams, params && {
              success: params.success,
              failure: params.failure
            });
          };
          Agent.prototype.getAllQueueARNs = function() {
            return this.getConfiguration().routingProfile.queues.map(function(queue) {
              return queue.queueARN;
            });
          };
          Agent.prototype.getEndpoints = function(queueARNs, callbacks, pageInfoIn) {
            var self2 = this;
            var client = connect2.core.getClient();
            connect2.assertNotNull(callbacks, "callbacks");
            connect2.assertNotNull(callbacks.success, "callbacks.success");
            var pageInfo = pageInfoIn || {};
            pageInfo.endpoints = pageInfo.endpoints || [];
            pageInfo.maxResults = pageInfo.maxResults || connect2.DEFAULT_BATCH_SIZE;
            if (!connect2.isArray(queueARNs)) {
              queueARNs = [queueARNs];
            }
            client.call(connect2.ClientMethods.GET_ENDPOINTS, {
              queueARNs,
              nextToken: pageInfo.nextToken || null,
              maxResults: pageInfo.maxResults
            }, {
              success: function(data) {
                if (data.nextToken) {
                  self2.getEndpoints(queueARNs, callbacks, {
                    nextToken: data.nextToken,
                    maxResults: pageInfo.maxResults,
                    endpoints: pageInfo.endpoints.concat(data.endpoints)
                  });
                } else {
                  pageInfo.endpoints = pageInfo.endpoints.concat(data.endpoints);
                  var endpoints = pageInfo.endpoints.map(function(endpoint) {
                    return new connect2.Endpoint(endpoint);
                  });
                  callbacks.success({
                    endpoints,
                    addresses: endpoints
                  });
                }
              },
              failure: callbacks.failure
            });
          };
          Agent.prototype.getAddresses = Agent.prototype.getEndpoints;
          Agent.prototype._getResourceId = function() {
            var queueArns = this.getAllQueueARNs();
            for (let queueArn of queueArns) {
              const agentIdMatch = queueArn.match(/\/agent\/([^/]+)/);
              if (agentIdMatch) {
                return agentIdMatch[1];
              }
            }
            return new Error("Agent.prototype._getResourceId: queueArns did not contain agentResourceId: ", queueArns);
          };
          Agent.prototype.toSnapshot = function() {
            return new connect2.AgentSnapshot(this._getData());
          };
          var AgentSnapshot = function(agentData) {
            connect2.Agent.call(this);
            this.agentData = agentData;
          };
          AgentSnapshot.prototype = Object.create(Agent.prototype);
          AgentSnapshot.prototype.constructor = AgentSnapshot;
          AgentSnapshot.prototype._getData = function() {
            return this.agentData;
          };
          AgentSnapshot.prototype._createContactAPI = function(contactData) {
            return new connect2.ContactSnapshot(contactData);
          };
          var Contact = function(contactId) {
            this.contactId = contactId;
          };
          Contact.prototype._getData = function() {
            return connect2.core.getAgentDataProvider().getContactData(this.getContactId());
          };
          Contact.prototype._createConnectionAPI = function(connectionData) {
            if (this.getType() === connect2.ContactType.CHAT) {
              return new connect2.ChatConnection(this.contactId, connectionData.connectionId);
            } else if (this.getType() === connect2.ContactType.TASK) {
              return new connect2.TaskConnection(this.contactId, connectionData.connectionId);
            } else {
              return new connect2.VoiceConnection(this.contactId, connectionData.connectionId);
            }
          };
          Contact.prototype.getEventName = function(eventName) {
            return connect2.core.getContactEventName(eventName, this.getContactId());
          };
          Contact.prototype.onRefresh = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.REFRESH), f);
          };
          Contact.prototype.onIncoming = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.INCOMING), f);
          };
          Contact.prototype.onConnecting = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.CONNECTING), f);
          };
          Contact.prototype.onPending = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.PENDING), f);
          };
          Contact.prototype.onAccepted = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.ACCEPTED), f);
          };
          Contact.prototype.onMissed = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.MISSED), f);
          };
          Contact.prototype.onEnded = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.ENDED), f);
          };
          Contact.prototype.onDestroy = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.DESTROYED), f);
          };
          Contact.prototype.onACW = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.ACW), f);
          };
          Contact.prototype.onConnected = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.CONNECTED), f);
          };
          Contact.prototype.onError = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(this.getEventName(connect2.ContactEvents.ERROR), f);
          };
          Contact.prototype.getContactId = function() {
            return this.contactId;
          };
          Contact.prototype.getOriginalContactId = function() {
            return this._getData().initialContactId;
          };
          Contact.prototype.getInitialContactId = Contact.prototype.getOriginalContactId;
          Contact.prototype.getType = function() {
            return this._getData().type;
          };
          Contact.prototype.getContactDuration = function() {
            return this._getData().contactDuration;
          };
          Contact.prototype.getState = function() {
            return this._getData().state;
          };
          Contact.prototype.getStatus = Contact.prototype.getState;
          Contact.prototype.getStateDuration = function() {
            return connect2.now() - this._getData().state.timestamp.getTime() + connect2.core.getSkew();
          };
          Contact.prototype.getStatusDuration = Contact.prototype.getStateDuration;
          Contact.prototype.getQueue = function() {
            return this._getData().queue;
          };
          Contact.prototype.getQueueTimestamp = function() {
            return this._getData().queueTimestamp;
          };
          Contact.prototype.getConnections = function() {
            var self2 = this;
            return this._getData().connections.map(function(connData) {
              if (self2.getType() === connect2.ContactType.CHAT) {
                return new connect2.ChatConnection(self2.contactId, connData.connectionId);
              } else if (self2.getType() === connect2.ContactType.TASK) {
                return new connect2.TaskConnection(self2.contactId, connData.connectionId);
              } else {
                return new connect2.VoiceConnection(self2.contactId, connData.connectionId);
              }
            });
          };
          Contact.prototype.getInitialConnection = function() {
            return connect2.find(this.getConnections(), function(conn) {
              return conn.isInitialConnection();
            }) || null;
          };
          Contact.prototype.getActiveInitialConnection = function() {
            var initialConn = this.getInitialConnection();
            if (initialConn != null && initialConn.isActive()) {
              return initialConn;
            } else {
              return null;
            }
          };
          Contact.prototype.getThirdPartyConnections = function() {
            return this.getConnections().filter(function(conn) {
              return !conn.isInitialConnection() && conn.getType() !== connect2.ConnectionType.AGENT;
            });
          };
          Contact.prototype.getSingleActiveThirdPartyConnection = function() {
            return this.getThirdPartyConnections().filter(function(conn) {
              return conn.isActive();
            })[0] || null;
          };
          Contact.prototype.getAgentConnection = function() {
            return connect2.find(this.getConnections(), function(conn) {
              var connType = conn.getType();
              return connType === connect2.ConnectionType.AGENT || connType === connect2.ConnectionType.MONITORING;
            });
          };
          Contact.prototype.getActiveConnections = function() {
            return this.getConnections().filter((conn) => conn.isActive());
          };
          Contact.prototype.hasTwoActiveParticipants = function() {
            return this.getActiveConnections().length === 2;
          };
          Contact.prototype.getName = function() {
            return this._getData().name;
          };
          Contact.prototype.getContactMetadata = function() {
            return this._getData().contactMetadata;
          };
          Contact.prototype.getDescription = function() {
            return this._getData().description;
          };
          Contact.prototype.getReferences = function() {
            return this._getData().references;
          };
          Contact.prototype.getAttributes = function() {
            return this._getData().attributes;
          };
          Contact.prototype.getContactFeatures = function() {
            return this._getData().contactFeatures;
          };
          Contact.prototype.getChannelContext = function() {
            return this._getData().channelContext;
          };
          Contact.prototype.getSegmentAttributes = function() {
            return this._getData().segmentAttributes;
          };
          Contact.prototype.getContactSubtype = function() {
            const segmentAttributes = this.getSegmentAttributes();
            return segmentAttributes && segmentAttributes["connect:Subtype"] ? segmentAttributes["connect:Subtype"].ValueString : null;
          };
          Contact.prototype.isSoftphoneCall = function() {
            return connect2.find(this.getConnections(), function(conn) {
              return conn.getSoftphoneMediaInfo() != null;
            }) != null;
          };
          Contact.prototype.hasVideoRTCCapabilities = function() {
            return connect2.find(this.getConnections(), function(conn) {
              return conn.canSendVideo && conn.canSendVideo();
            }) != null;
          };
          Contact.prototype.canAgentSendVideo = function() {
            const agentConnection = this.getAgentConnection();
            return agentConnection.canSendVideo && agentConnection.canSendVideo();
          };
          Contact.prototype.canAgentReceiveVideo = function() {
            const initialConn = this.getInitialConnection();
            if (initialConn.canSendVideo && initialConn.canSendVideo()) {
              return true;
            }
            const thirdPartyConns = this.getThirdPartyConnections();
            return thirdPartyConns && thirdPartyConns.length > 0 && this.canAgentSendVideo();
          };
          Contact.prototype._isInbound = function() {
            var initiationMethod = this._getData().initiationMethod;
            return initiationMethod === connect2.ContactInitiationMethod.OUTBOUND ? false : true;
          };
          Contact.prototype.isInbound = function() {
            var conn = this.getInitialConnection();
            if (conn.getMediaType() === connect2.MediaType.TASK) {
              return this._isInbound();
            }
            return conn ? conn.getType() === connect2.ConnectionType.INBOUND : false;
          };
          Contact.prototype.isConnected = function() {
            return this.getStatus().type === connect2.ContactStateType.CONNECTED;
          };
          Contact.prototype.accept = function(callbacks) {
            var client = connect2.core.getClient();
            var self2 = this;
            var contactId = this.getContactId();
            connect2.publishClickStreamData({
              contactId: this.getContactId(),
              clickType: connect2.ClickType.ACCEPT,
              clickTime: (/* @__PURE__ */ new Date()).toISOString()
            });
            client.call(connect2.ClientMethods.ACCEPT_CONTACT, {
              contactId
            }, {
              success: function(data) {
                var conduit = connect2.core.getUpstream();
                conduit.sendUpstream(connect2.EventType.BROADCAST, {
                  event: connect2.ContactEvents.ACCEPTED,
                  data: new connect2.Contact(contactId)
                });
                conduit.sendUpstream(connect2.EventType.BROADCAST, {
                  event: connect2.core.getContactEventName(connect2.ContactEvents.ACCEPTED, self2.getContactId()),
                  data: new connect2.Contact(contactId)
                });
                var contact = new connect2.Contact(contactId);
                if (connect2.isFirefoxBrowser() && contact.isSoftphoneCall()) {
                  connect2.core.triggerReadyToStartSessionEvent();
                }
                if (callbacks && callbacks.success) {
                  callbacks.success(data);
                }
              },
              failure: function(err, data) {
                connect2.getLog().error("Accept Contact failed").sendInternalLogToServer().withException(err).withObject({
                  data
                });
                connect2.publishMetric({
                  name: "ContactAcceptFailure",
                  data: { count: 1 }
                });
                if (callbacks && callbacks.failure) {
                  callbacks.failure(connect2.ContactStateType.ERROR);
                }
              }
            });
          };
          Contact.prototype.destroy = function() {
            connect2.getLog().warn("contact.destroy() has been deprecated.");
          };
          Contact.prototype.reject = function(callbacks) {
            var client = connect2.core.getClient();
            connect2.publishClickStreamData({
              contactId: this.getContactId(),
              clickType: connect2.ClickType.REJECT,
              clickTime: (/* @__PURE__ */ new Date()).toISOString()
            });
            client.call(connect2.ClientMethods.REJECT_CONTACT, {
              contactId: this.getContactId()
            }, callbacks);
          };
          Contact.prototype.complete = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.COMPLETE_CONTACT, {
              contactId: this.getContactId()
            }, callbacks);
          };
          Contact.prototype.clear = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.CLEAR_CONTACT, {
              contactId: this.getContactId()
            }, callbacks);
          };
          Contact.prototype.notifyIssue = function(issueCode, description, callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.NOTIFY_CONTACT_ISSUE, {
              contactId: this.getContactId(),
              issueCode,
              description
            }, callbacks);
          };
          Contact.prototype.addConnection = function(endpointIn, callbacks) {
            var client = connect2.core.getClient();
            var endpoint = new connect2.Endpoint(endpointIn);
            delete endpoint.endpointId;
            client.call(connect2.ClientMethods.CREATE_ADDITIONAL_CONNECTION, {
              contactId: this.getContactId(),
              endpoint
            }, callbacks);
          };
          Contact.prototype.toggleActiveConnections = function(callbacks) {
            var client = connect2.core.getClient();
            var connectionId = null;
            var holdingConn = connect2.find(this.getConnections(), function(conn) {
              return conn.getStatus().type === connect2.ConnectionStateType.HOLD;
            });
            if (holdingConn != null) {
              connectionId = holdingConn.getConnectionId();
            } else {
              var activeConns = this.getConnections().filter(function(conn) {
                return conn.isActive();
              });
              if (activeConns.length > 0) {
                connectionId = activeConns[0].getConnectionId();
              }
            }
            client.call(connect2.ClientMethods.TOGGLE_ACTIVE_CONNECTIONS, {
              contactId: this.getContactId(),
              connectionId
            }, callbacks);
          };
          Contact.prototype.sendSoftphoneMetrics = function(softphoneStreamStatistics, callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.SEND_SOFTPHONE_CALL_METRICS, {
              contactId: this.getContactId(),
              ccpVersion: global.ccpVersion,
              softphoneStreamStatistics
            }, callbacks);
            connect2.publishSoftphoneStats({
              contactId: this.getContactId(),
              ccpVersion: global.ccpVersion,
              stats: softphoneStreamStatistics
            });
          };
          Contact.prototype.sendSoftphoneReport = function(report, callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.SEND_SOFTPHONE_CALL_REPORT, {
              contactId: this.getContactId(),
              ccpVersion: global.ccpVersion,
              report
            }, callbacks);
          };
          Contact.prototype.conferenceConnections = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.CONFERENCE_CONNECTIONS, {
              contactId: this.getContactId()
            }, callbacks);
          };
          Contact.prototype.toSnapshot = function() {
            return new connect2.ContactSnapshot(this._getData());
          };
          Contact.prototype.isMultiPartyConferenceEnabled = function() {
            var contactFeatures = this.getContactFeatures();
            return !!(contactFeatures && contactFeatures.multiPartyConferenceEnabled);
          };
          Contact.prototype.updateMonitorParticipantState = function(targetState, callbacks) {
            if (!targetState || !Object.values(connect2.MonitoringMode).includes(targetState.toUpperCase())) {
              connect2.getLog().error(`Invalid target state was provided: ${targetState}`).sendInternalLogToServer();
              if (callbacks && callbacks.failure) {
                callbacks.failure(connect2.MonitoringErrorTypes.INVALID_TARGET_STATE);
              }
            } else {
              var client = connect2.core.getClient();
              client.call(connect2.ClientMethods.UPDATE_MONITOR_PARTICIPANT_STATE, {
                contactId: this.getContactId(),
                targetMonitorMode: targetState.toUpperCase()
              }, callbacks);
            }
          };
          Contact.prototype.isUnderSupervision = function() {
            var nonAgentConnections = this.getConnections().filter((conn) => conn.getType() !== connect2.ConnectionType.AGENT);
            var supervisorConnection = nonAgentConnections && nonAgentConnections.find((conn) => conn.isBarge() && conn.isActive());
            return supervisorConnection !== void 0;
          };
          Contact.prototype.silentMonitor = function(callbacks) {
            return this.updateMonitorParticipantState(connect2.MonitoringMode.SILENT_MONITOR, callbacks);
          };
          Contact.prototype.bargeIn = function(callbacks) {
            return this.updateMonitorParticipantState(connect2.MonitoringMode.BARGE, callbacks);
          };
          Contact.prototype.pause = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.PAUSE_CONTACT, {
              contactId: this.getContactId()
            }, callbacks);
          };
          Contact.prototype.resume = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.RESUME_CONTACT, {
              contactId: this.getContactId()
            }, callbacks);
          };
          var ContactSnapshot = function(contactData) {
            connect2.Contact.call(this, contactData.contactId);
            this.contactData = contactData;
          };
          ContactSnapshot.prototype = Object.create(Contact.prototype);
          ContactSnapshot.prototype.constructor = ContactSnapshot;
          ContactSnapshot.prototype._getData = function() {
            return this.contactData;
          };
          ContactSnapshot.prototype._createConnectionAPI = function(connectionData) {
            return new connect2.ConnectionSnapshot(connectionData);
          };
          var Connection = function(contactId, connectionId) {
            this.contactId = contactId;
            this.connectionId = connectionId;
            this._initMediaController();
          };
          Connection.prototype._getData = function() {
            return connect2.core.getAgentDataProvider().getConnectionData(
              this.getContactId(),
              this.getConnectionId()
            );
          };
          Connection.prototype.getContactId = function() {
            return this.contactId;
          };
          Connection.prototype.getConnectionId = function() {
            return this.connectionId;
          };
          Connection.prototype.getEndpoint = function() {
            return new connect2.Endpoint(this._getData().endpoint);
          };
          Connection.prototype.getAddress = Connection.prototype.getEndpoint;
          Connection.prototype.getState = function() {
            return this._getData().state;
          };
          Connection.prototype.getStatus = Connection.prototype.getState;
          Connection.prototype.getStateDuration = function() {
            return connect2.now() - this._getData().state.timestamp.getTime() + connect2.core.getSkew();
          };
          Connection.prototype.getStatusDuration = Connection.prototype.getStateDuration;
          Connection.prototype.getType = function() {
            return this._getData().type;
          };
          Connection.prototype.isInitialConnection = function() {
            return this._getData().initial;
          };
          Connection.prototype.isActive = function() {
            return connect2.contains(connect2.CONNECTION_ACTIVE_STATES, this.getStatus().type);
          };
          Connection.prototype.isConnected = function() {
            return connect2.contains(connect2.CONNECTION_CONNECTED_STATES, this.getStatus().type);
          };
          Connection.prototype.isConnecting = function() {
            return this.getStatus().type === connect2.ConnectionStateType.CONNECTING;
          };
          Connection.prototype.isOnHold = function() {
            return this.getStatus().type === connect2.ConnectionStateType.HOLD;
          };
          Connection.prototype.getSoftphoneMediaInfo = function() {
            return this._getData().softphoneMediaInfo;
          };
          Connection.prototype.getMonitorInfo = function() {
            return this._getData().monitoringInfo;
          };
          Connection.prototype.destroy = function(callbacks) {
            connect2.publishClickStreamData({
              contactId: this.getContactId(),
              clickType: connect2.ClickType.HANGUP,
              clickTime: (/* @__PURE__ */ new Date()).toISOString()
            });
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.DESTROY_CONNECTION, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId()
            }, callbacks);
          };
          Connection.prototype.sendDigits = function(digits, callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.SEND_DIGITS, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId(),
              digits
            }, callbacks);
          };
          Connection.prototype.hold = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.HOLD_CONNECTION, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId()
            }, callbacks);
          };
          Connection.prototype.resume = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.RESUME_CONNECTION, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId()
            }, callbacks);
          };
          Connection.prototype.toSnapshot = function() {
            return new connect2.ConnectionSnapshot(this._getData());
          };
          Connection.prototype._initMediaController = function() {
            if (this.getMediaInfo()) {
              connect2.core.mediaFactory.get(this).catch(function() {
              });
            }
          };
          Connection.prototype._isAgentConnectionType = function() {
            var connectionType = this.getType();
            return connectionType === connect2.ConnectionType.AGENT || connectionType === connect2.ConnectionType.MONITORING;
          };
          Connection.prototype._isAgentConnectionType = function() {
            var connectionType = this.getType();
            return connectionType === connect2.ConnectionType.AGENT || connectionType === connect2.ConnectionType.MONITORING;
          };
          var VoiceId = function(contactId) {
            this.contactId = contactId;
          };
          VoiceId.prototype.getSpeakerId = function() {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              const params = {
                "contactId": self2.contactId,
                "instanceId": connect2.core.getAgentDataProvider().getInstanceId(),
                "awsAccountId": connect2.core.getAgentDataProvider().getAWSAccountId()
              };
              connect2.getLog().info("getSpeakerId called").withObject(params).sendInternalLogToServer();
              client.call(connect2.AgentAppClientMethods.GET_CONTACT, params, {
                success: function(data) {
                  if (data.contactData.customerId) {
                    var obj = {
                      speakerId: data.contactData.customerId
                    };
                    connect2.getLog().info("getSpeakerId succeeded").withObject(data).sendInternalLogToServer();
                    resolve(obj);
                  } else {
                    var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.NO_SPEAKER_ID_FOUND, "No speakerId assotiated with this call");
                    reject(error);
                  }
                },
                failure: function(err) {
                  connect2.getLog().error("Get SpeakerId failed").withObject({
                    err
                  }).sendInternalLogToServer();
                  var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.GET_SPEAKER_ID_FAILED, "Get SpeakerId failed", err);
                  reject(error);
                }
              });
            });
          };
          VoiceId.prototype.getSpeakerStatus = function() {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              self2.getSpeakerId().then(function(data) {
                self2.getDomainId().then(function(domainId) {
                  const params = {
                    "SpeakerId": connect2.assertNotNull(data.speakerId, "speakerId"),
                    "DomainId": domainId
                  };
                  connect2.getLog().info("getSpeakerStatus called").withObject(params).sendInternalLogToServer();
                  client.call(connect2.AgentAppClientMethods.DESCRIBE_SPEAKER, params, {
                    success: function(data2) {
                      connect2.getLog().info("getSpeakerStatus succeeded").withObject(data2).sendInternalLogToServer();
                      resolve(data2);
                    },
                    failure: function(err) {
                      var error;
                      var parsedErr = JSON.parse(err);
                      switch (parsedErr.status) {
                        case 400:
                        case 404:
                          var data2 = parsedErr;
                          data2.type = data2.type ? data2.type : connect2.VoiceIdErrorTypes.SPEAKER_ID_NOT_ENROLLED;
                          connect2.getLog().info("Speaker is not enrolled.").sendInternalLogToServer();
                          resolve(data2);
                          break;
                        default:
                          connect2.getLog().error("getSpeakerStatus failed").withObject({
                            err
                          }).sendInternalLogToServer();
                          var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.GET_SPEAKER_STATUS_FAILED, "Get SpeakerStatus failed", err);
                          reject(error);
                      }
                    }
                  });
                }).catch(function(err) {
                  reject(err);
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype._optOutSpeakerInLcms = function(speakerId, generatedSpeakerId) {
            var self2 = this;
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              const params = {
                "ContactId": self2.contactId,
                "InstanceId": connect2.core.getAgentDataProvider().getInstanceId(),
                "AWSAccountId": connect2.core.getAgentDataProvider().getAWSAccountId(),
                "CustomerId": connect2.assertNotNull(speakerId, "speakerId"),
                "VoiceIdResult": {
                  "SpeakerOptedOut": true,
                  "generatedSpeakerId": generatedSpeakerId
                }
              };
              connect2.getLog().info("_optOutSpeakerInLcms called").withObject(params).sendInternalLogToServer();
              client.call(connect2.AgentAppClientMethods.UPDATE_VOICE_ID_DATA, params, {
                success: function(data) {
                  connect2.getLog().info("optOutSpeakerInLcms succeeded").withObject(data).sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err) {
                  connect2.getLog().error("optOutSpeakerInLcms failed").withObject({
                    err
                  }).sendInternalLogToServer();
                  var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.OPT_OUT_SPEAKER_IN_LCMS_FAILED, "optOutSpeakerInLcms failed", err);
                  reject(error);
                }
              });
            });
          };
          VoiceId.prototype.optOutSpeaker = function() {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              self2.getSpeakerId().then(function(data) {
                self2.getDomainId().then(function(domainId) {
                  var speakerId = data.speakerId;
                  const params = {
                    "SpeakerId": connect2.assertNotNull(speakerId, "speakerId"),
                    "DomainId": domainId
                  };
                  connect2.getLog().info("optOutSpeaker called").withObject(params).sendInternalLogToServer();
                  client.call(connect2.AgentAppClientMethods.OPT_OUT_SPEAKER, params, {
                    success: function(data2) {
                      self2._optOutSpeakerInLcms(speakerId, data2.generatedSpeakerId).catch(function() {
                      });
                      connect2.getLog().info("optOutSpeaker succeeded").withObject(data2).sendInternalLogToServer();
                      resolve(data2);
                    },
                    failure: function(err) {
                      connect2.getLog().error("optOutSpeaker failed").withObject({
                        err
                      }).sendInternalLogToServer();
                      var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.OPT_OUT_SPEAKER_FAILED, "optOutSpeaker failed.", err);
                      reject(error);
                    }
                  });
                }).catch(function(err) {
                  reject(err);
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.deleteSpeaker = function() {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              self2.getSpeakerId().then(function(data) {
                self2.getDomainId().then(function(domainId) {
                  const params = {
                    "SpeakerId": connect2.assertNotNull(data.speakerId, "speakerId"),
                    "DomainId": domainId
                  };
                  connect2.getLog().info("deleteSpeaker called").withObject(params).sendInternalLogToServer();
                  client.call(connect2.AgentAppClientMethods.DELETE_SPEAKER, params, {
                    success: function(data2) {
                      connect2.getLog().info("deleteSpeaker succeeded").withObject(data2).sendInternalLogToServer();
                      resolve(data2);
                    },
                    failure: function(err) {
                      connect2.getLog().error("deleteSpeaker failed").withObject({
                        err
                      }).sendInternalLogToServer();
                      var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.DELETE_SPEAKER_FAILED, "deleteSpeaker failed.", err);
                      reject(error);
                    }
                  });
                }).catch(function(err) {
                  reject(err);
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.startSession = function() {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              self2.getDomainId().then(function(domainId) {
                const params = {
                  "contactId": self2.contactId,
                  "instanceId": connect2.core.getAgentDataProvider().getInstanceId(),
                  "customerAccountId": connect2.core.getAgentDataProvider().getAWSAccountId(),
                  "clientToken": AWS.util.uuid.v4(),
                  "domainId": domainId
                };
                connect2.getLog().info("startSession called").withObject(params).sendInternalLogToServer();
                client.call(connect2.AgentAppClientMethods.START_VOICE_ID_SESSION, params, {
                  success: function(data) {
                    if (data.sessionId) {
                      resolve(data);
                    } else {
                      connect2.getLog().error("startVoiceIdSession failed, no session id returned").withObject({
                        data
                      }).sendInternalLogToServer();
                      var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.START_SESSION_FAILED, "No session id returned from start session api");
                      reject(error);
                    }
                  },
                  failure: function(err) {
                    connect2.getLog().error("startVoiceIdSession failed").withObject({
                      err
                    }).sendInternalLogToServer();
                    var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.START_SESSION_FAILED, "startVoiceIdSession failed", err);
                    reject(error);
                  }
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.evaluateSpeaker = function(startNew) {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            var pollTimes = 0;
            return new Promise(function(resolve, reject) {
              function evaluate() {
                self2.getDomainId().then(function(domainId) {
                  const params = {
                    "SessionNameOrId": contactData.initialContactId || this.contactId,
                    "DomainId": domainId
                  };
                  connect2.getLog().info("evaluateSpeaker called").withObject(params).sendInternalLogToServer();
                  client.call(connect2.AgentAppClientMethods.EVALUATE_SESSION, params, {
                    success: function(data) {
                      if (++pollTimes < connect2.VoiceIdConstants.EVALUATION_MAX_POLL_TIMES) {
                        if (data.StreamingStatus === connect2.VoiceIdStreamingStatus.PENDING_CONFIGURATION) {
                          setTimeout(evaluate, connect2.VoiceIdConstants.EVALUATION_POLLING_INTERVAL);
                        } else {
                          if (!data.AuthenticationResult) {
                            data.AuthenticationResult = {};
                            data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.NOT_ENABLED;
                          }
                          if (!data.FraudDetectionResult) {
                            data.FraudDetectionResult = {};
                            data.FraudDetectionResult.Decision = connect2.ContactFlowFraudDetectionDecision.NOT_ENABLED;
                          }
                          if (!self2.isAuthEnabled(data.AuthenticationResult.Decision) && !self2.isFraudEnabled(data.FraudDetectionResult.Decision)) {
                            connect2.getLog().info("evaluateSpeaker succeeded").withObject(data).sendInternalLogToServer();
                            resolve(data);
                            return;
                          }
                          if (data.StreamingStatus === connect2.VoiceIdStreamingStatus.ENDED) {
                            if (self2.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision)) {
                              data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.INCONCLUSIVE;
                            }
                            if (self2.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision)) {
                              data.FraudDetectionResult.Decision = connect2.ContactFlowFraudDetectionDecision.INCONCLUSIVE;
                            }
                          }
                          if (self2.isAuthResultInconclusive(data.AuthenticationResult.Decision) && self2.isFraudResultInconclusive(data.FraudDetectionResult.Decision)) {
                            connect2.getLog().info("evaluateSpeaker succeeded").withObject(data).sendInternalLogToServer();
                            resolve(data);
                            return;
                          }
                          if (!self2.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision) && self2.isAuthEnabled(data.AuthenticationResult.Decision)) {
                            switch (data.AuthenticationResult.Decision) {
                              case connect2.VoiceIdAuthenticationDecision.ACCEPT:
                                data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.AUTHENTICATED;
                                break;
                              case connect2.VoiceIdAuthenticationDecision.REJECT:
                                data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.NOT_AUTHENTICATED;
                                break;
                              case connect2.VoiceIdAuthenticationDecision.SPEAKER_OPTED_OUT:
                                data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.OPTED_OUT;
                                break;
                              case connect2.VoiceIdAuthenticationDecision.SPEAKER_NOT_ENROLLED:
                                data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.NOT_ENROLLED;
                                break;
                              default:
                                data.AuthenticationResult.Decision = connect2.ContactFlowAuthenticationDecision.ERROR;
                            }
                          }
                          if (!self2.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision) && self2.isFraudEnabled(data.FraudDetectionResult.Decision)) {
                            switch (data.FraudDetectionResult.Decision) {
                              case connect2.VoiceIdFraudDetectionDecision.HIGH_RISK:
                                data.FraudDetectionResult.Decision = connect2.ContactFlowFraudDetectionDecision.HIGH_RISK;
                                break;
                              case connect2.VoiceIdFraudDetectionDecision.LOW_RISK:
                                data.FraudDetectionResult.Decision = connect2.ContactFlowFraudDetectionDecision.LOW_RISK;
                                break;
                              default:
                                data.FraudDetectionResult.Decision = connect2.ContactFlowFraudDetectionDecision.ERROR;
                            }
                          }
                          if (!self2.isAuthResultNotEnoughSpeech(data.AuthenticationResult.Decision) && !self2.isFraudResultNotEnoughSpeech(data.FraudDetectionResult.Decision)) {
                            connect2.getLog().info("evaluateSpeaker succeeded").withObject(data).sendInternalLogToServer();
                            resolve(data);
                            return;
                          } else {
                            setTimeout(evaluate, connect2.VoiceIdConstants.EVALUATION_POLLING_INTERVAL);
                          }
                        }
                      } else {
                        connect2.getLog().error("evaluateSpeaker timeout").sendInternalLogToServer();
                        var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.EVALUATE_SPEAKER_TIMEOUT, "evaluateSpeaker timeout");
                        reject(error);
                      }
                    },
                    failure: function(err) {
                      var error;
                      var parsedErr = JSON.parse(err);
                      switch (parsedErr.status) {
                        case 400:
                        case 404:
                          error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.SESSION_NOT_EXISTS, "evaluateSpeaker failed, session not exists", err);
                          connect2.getLog().error("evaluateSpeaker failed, session not exists").withObject({ err }).sendInternalLogToServer();
                          break;
                        default:
                          error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.EVALUATE_SPEAKER_FAILED, "evaluateSpeaker failed", err);
                          connect2.getLog().error("evaluateSpeaker failed").withObject({ err }).sendInternalLogToServer();
                      }
                      reject(error);
                    }
                  });
                }).catch(function(err) {
                  reject(err);
                });
              }
              if (!startNew) {
                self2.syncSpeakerId().then(function() {
                  evaluate();
                }).catch(function(err) {
                  connect2.getLog().error("syncSpeakerId failed when session startNew=false").withObject({ err }).sendInternalLogToServer();
                  reject(err);
                });
              } else {
                self2.startSession().then(function(data) {
                  self2.syncSpeakerId().then(function(data2) {
                    setTimeout(evaluate, connect2.VoiceIdConstants.EVALUATE_SESSION_DELAY);
                  }).catch(function(err) {
                    connect2.getLog().error("syncSpeakerId failed when session startNew=true").withObject({ err }).sendInternalLogToServer();
                    reject(err);
                  });
                }).catch(function(err) {
                  connect2.getLog().error("startSession failed when session startNew=true").withObject({ err }).sendInternalLogToServer();
                  reject(err);
                });
              }
            });
          };
          VoiceId.prototype.describeSession = function() {
            var self2 = this;
            var client = connect2.core.getClient();
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            return new Promise(function(resolve, reject) {
              self2.getDomainId().then(function(domainId) {
                const params = {
                  "SessionNameOrId": contactData.initialContactId || this.contactId,
                  "DomainId": domainId
                };
                connect2.getLog().info("describeSession called").withObject(params).sendInternalLogToServer();
                client.call(connect2.AgentAppClientMethods.DESCRIBE_SESSION, params, {
                  success: function(data) {
                    resolve(data);
                  },
                  failure: function(err) {
                    connect2.getLog().error("describeSession failed").withObject({
                      err
                    }).sendInternalLogToServer();
                    var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.DESCRIBE_SESSION_FAILED, "describeSession failed", err);
                    reject(error);
                  }
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.checkEnrollmentStatus = function(callbackOnAudioCollectionComplete) {
            connect2.getLog().info("checkEnrollmentStatus called").sendInternalLogToServer();
            var self2 = this;
            var pollingTimes = 0;
            var callbackOnAudioCollectionCompleteHasBeenInvoked = false;
            return new Promise(function(resolve, reject) {
              function describe() {
                if (++pollingTimes < connect2.VoiceIdConstants.ENROLLMENT_MAX_POLL_TIMES) {
                  self2.describeSession().then(function(data) {
                    switch (data.Session.EnrollmentRequestDetails.Status) {
                      case connect2.VoiceIdEnrollmentRequestStatus.COMPLETED:
                        resolve(data);
                        break;
                      case connect2.VoiceIdEnrollmentRequestStatus.IN_PROGRESS:
                        if (!callbackOnAudioCollectionCompleteHasBeenInvoked && typeof callbackOnAudioCollectionComplete === "function") {
                          callbackOnAudioCollectionComplete(data);
                          callbackOnAudioCollectionCompleteHasBeenInvoked = true;
                        }
                        setTimeout(describe, connect2.VoiceIdConstants.ENROLLMENT_POLLING_INTERVAL);
                        break;
                      case connect2.VoiceIdEnrollmentRequestStatus.NOT_ENOUGH_SPEECH:
                        if (data.Session.StreamingStatus !== connect2.VoiceIdStreamingStatus.ENDED) {
                          setTimeout(describe, connect2.VoiceIdConstants.ENROLLMENT_POLLING_INTERVAL);
                        } else {
                          setTimeout(function() {
                            self2.startSession().then(function(data2) {
                              describe();
                            }).catch(function(err, data2) {
                              reject(err);
                            });
                          }, connect2.VoiceIdConstants.START_SESSION_DELAY);
                        }
                        break;
                      default:
                        var message = data.Session.EnrollmentRequestDetails.Message ? data.Session.EnrollmentRequestDetails.Message : "enrollSpeaker failed. Unknown enrollment status has been received";
                        connect2.getLog().error(message).sendInternalLogToServer();
                        var error2 = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.ENROLL_SPEAKER_FAILED, message, data.Session.EnrollmentRequestDetails.Status);
                        reject(error2);
                    }
                  });
                } else {
                  connect2.getLog().error("enrollSpeaker timeout").sendInternalLogToServer();
                  var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.ENROLL_SPEAKER_TIMEOUT, "enrollSpeaker timeout");
                  reject(error);
                }
              }
              describe();
            });
          };
          VoiceId.prototype.enrollSpeaker = function(callbackOnAudioCollectionComplete) {
            connect2.getLog().info("enrollSpeaker called").sendInternalLogToServer();
            var self2 = this;
            self2.checkConferenceCall();
            return new Promise(function(resolve, reject) {
              self2.syncSpeakerId().then(function() {
                self2.getSpeakerStatus().then(function(data) {
                  if (data.Speaker && data.Speaker.Status == connect2.VoiceIdSpeakerStatus.OPTED_OUT) {
                    self2.deleteSpeaker().then(function() {
                      self2.enrollSpeakerHelper(resolve, reject, callbackOnAudioCollectionComplete);
                    }).catch(function(err) {
                      reject(err);
                    });
                  } else {
                    self2.enrollSpeakerHelper(resolve, reject, callbackOnAudioCollectionComplete);
                  }
                }).catch(function(err) {
                  reject(err);
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.enrollSpeakerHelper = function(resolve, reject, callbackOnAudioCollectionComplete) {
            var self2 = this;
            var client = connect2.core.getClient();
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            self2.getDomainId().then(function(domainId) {
              const params = {
                "SessionNameOrId": contactData.initialContactId || this.contactId,
                "DomainId": domainId
              };
              connect2.getLog().info("enrollSpeakerHelper called").withObject(params).sendInternalLogToServer();
              client.call(connect2.AgentAppClientMethods.ENROLL_BY_SESSION, params, {
                success: function(data) {
                  if (data.Status === connect2.VoiceIdEnrollmentRequestStatus.COMPLETED) {
                    connect2.getLog().info("enrollSpeaker succeeded").withObject(data).sendInternalLogToServer();
                    resolve(data);
                  } else {
                    self2.checkEnrollmentStatus(callbackOnAudioCollectionComplete).then(function(data2) {
                      connect2.getLog().info("enrollSpeaker succeeded").withObject(data2).sendInternalLogToServer();
                      resolve(data2);
                    }).catch(function(err) {
                      reject(err);
                    });
                  }
                },
                failure: function(err) {
                  connect2.getLog().error("enrollSpeaker failed").withObject({
                    err
                  }).sendInternalLogToServer();
                  var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.ENROLL_SPEAKER_FAILED, "enrollSpeaker failed", err);
                  reject(error);
                }
              });
            }).catch(function(err) {
              reject(err);
            });
          };
          VoiceId.prototype._updateSpeakerIdInLcms = function(speakerId, generatedSpeakerId) {
            var self2 = this;
            var client = connect2.core.getClient();
            return new Promise(function(resolve, reject) {
              const params = {
                "ContactId": self2.contactId,
                "InstanceId": connect2.core.getAgentDataProvider().getInstanceId(),
                "AWSAccountId": connect2.core.getAgentDataProvider().getAWSAccountId(),
                "CustomerId": connect2.assertNotNull(speakerId, "speakerId"),
                "VoiceIdResult": {
                  "generatedSpeakerId": generatedSpeakerId
                }
              };
              connect2.getLog().info("_updateSpeakerIdInLcms called").withObject(params).sendInternalLogToServer();
              client.call(connect2.AgentAppClientMethods.UPDATE_VOICE_ID_DATA, params, {
                success: function(data) {
                  connect2.getLog().info("updateSpeakerIdInLcms succeeded").withObject(data).sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err) {
                  connect2.getLog().error("updateSpeakerIdInLcms failed").withObject({
                    err
                  }).sendInternalLogToServer();
                  var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.UPDATE_SPEAKER_ID_IN_LCMS_FAILED, "updateSpeakerIdInLcms failed", err);
                  reject(error);
                }
              });
            });
          };
          VoiceId.prototype.updateSpeakerIdInVoiceId = function(speakerId) {
            var self2 = this;
            self2.checkConferenceCall();
            var client = connect2.core.getClient();
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            return new Promise(function(resolve, reject) {
              self2.getDomainId().then(function(domainId) {
                const params = {
                  "SessionNameOrId": contactData.initialContactId || this.contactId,
                  "SpeakerId": connect2.assertNotNull(speakerId, "speakerId"),
                  "DomainId": domainId
                };
                connect2.getLog().info("updateSpeakerIdInVoiceId called").withObject(params).sendInternalLogToServer();
                client.call(connect2.AgentAppClientMethods.UPDATE_SESSION, params, {
                  success: function(data) {
                    connect2.getLog().info("updateSpeakerIdInVoiceId succeeded").withObject(data).sendInternalLogToServer();
                    var generatedSpeakerId = data && data.Session && data.Session.GeneratedSpeakerId;
                    self2._updateSpeakerIdInLcms(speakerId, generatedSpeakerId).then(function() {
                      resolve(data);
                    }).catch(function(err) {
                      reject(err);
                    });
                  },
                  failure: function(err) {
                    var error;
                    var parsedErr = JSON.parse(err);
                    switch (parsedErr.status) {
                      case 400:
                      case 404:
                        error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.SESSION_NOT_EXISTS, "updateSpeakerIdInVoiceId failed, session not exists", err);
                        connect2.getLog().error("updateSpeakerIdInVoiceId failed, session not exists").withObject({ err }).sendInternalLogToServer();
                        break;
                      default:
                        error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.UPDATE_SPEAKER_ID_FAILED, "updateSpeakerIdInVoiceId failed", err);
                        connect2.getLog().error("updateSpeakerIdInVoiceId failed").withObject({ err }).sendInternalLogToServer();
                    }
                    reject(error);
                  }
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.syncSpeakerId = function() {
            connect2.getLog().info("syncSpeakerId called").sendInternalLogToServer();
            var self2 = this;
            return new Promise(function(resolve, reject) {
              self2.getSpeakerId().then(function(data) {
                self2.updateSpeakerIdInVoiceId(data.speakerId).then(function(data2) {
                  resolve(data2);
                }).catch(function(err) {
                  reject(err);
                });
              }).catch(function(err) {
                reject(err);
              });
            });
          };
          VoiceId.prototype.getDomainId = function() {
            return new Promise(function(resolve, reject) {
              const agent = new connect2.Agent();
              if (!agent.getPermissions().includes(connect2.AgentPermissions.VOICE_ID)) {
                reject(new Error("Agent doesn't have the permission for Voice ID"));
              } else if (connect2.core.voiceIdDomainId) {
                resolve(connect2.core.voiceIdDomainId);
              } else {
                var client = connect2.core.getClient();
                const params = {
                  "InstanceId": connect2.core.getAgentDataProvider().getInstanceId(),
                  "IntegrationType": "VOICE_ID"
                };
                connect2.getLog().info("getDomainId called").withObject(params).sendInternalLogToServer();
                client.call(connect2.AgentAppClientMethods.LIST_INTEGRATION_ASSOCIATIONS, params, {
                  success: function(data) {
                    try {
                      var domainId;
                      if (data.IntegrationAssociationSummaryList.length >= 1) {
                        var integrationArn = data.IntegrationAssociationSummaryList[0].IntegrationArn;
                        domainId = integrationArn.replace(/^.*domain\//i, "");
                      }
                      if (!domainId) {
                        connect2.getLog().info("getDomainId: no domainId found").sendInternalLogToServer();
                        var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.NO_DOMAIN_ID_FOUND);
                        reject(error);
                        return;
                      }
                      connect2.getLog().info("getDomainId succeeded").withObject(data).sendInternalLogToServer();
                      connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
                        event: connect2.VoiceIdEvents.UPDATE_DOMAIN_ID,
                        data: { domainId }
                      });
                      resolve(domainId);
                    } catch (err) {
                      connect2.getLog().error("getDomainId failed").withObject({ err }).sendInternalLogToServer();
                      var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.GET_DOMAIN_ID_FAILED, "getDomainId failed", err);
                      reject(error);
                    }
                  },
                  failure: function(err) {
                    connect2.getLog().error("getDomainId failed").withObject({ err }).sendInternalLogToServer();
                    var error = connect2.VoiceIdError(connect2.VoiceIdErrorTypes.GET_DOMAIN_ID_FAILED, "getDomainId failed", err);
                    reject(error);
                  }
                });
              }
            });
          };
          VoiceId.prototype.checkConferenceCall = function() {
            var self2 = this;
            var isConferenceCall = connect2.core.getAgentDataProvider().getContactData(self2.contactId).connections.filter(function(conn) {
              return connect2.contains(connect2.CONNECTION_ACTIVE_STATES, conn.state.type);
            }).length > 2;
            if (isConferenceCall) {
              throw new connect2.NotImplementedError("VoiceId is not supported for conference calls");
            }
          };
          VoiceId.prototype.isAuthEnabled = function(authResult) {
            return authResult !== connect2.ContactFlowAuthenticationDecision.NOT_ENABLED;
          };
          VoiceId.prototype.isAuthResultNotEnoughSpeech = function(authResult) {
            return authResult === connect2.VoiceIdAuthenticationDecision.NOT_ENOUGH_SPEECH;
          };
          VoiceId.prototype.isAuthResultInconclusive = function(authResult) {
            return authResult === connect2.ContactFlowAuthenticationDecision.INCONCLUSIVE;
          };
          VoiceId.prototype.isFraudEnabled = function(fraudResult) {
            return fraudResult !== connect2.ContactFlowFraudDetectionDecision.NOT_ENABLED;
          };
          VoiceId.prototype.isFraudResultNotEnoughSpeech = function(fraudResult) {
            return fraudResult === connect2.VoiceIdFraudDetectionDecision.NOT_ENOUGH_SPEECH;
          };
          VoiceId.prototype.isFraudResultInconclusive = function(fraudResult) {
            return fraudResult === connect2.ContactFlowFraudDetectionDecision.INCONCLUSIVE;
          };
          var VoiceConnection = function(contactId, connectionId) {
            this._speakerAuthenticator = new VoiceId(contactId);
            Connection.call(this, contactId, connectionId);
          };
          VoiceConnection.prototype = Object.create(Connection.prototype);
          VoiceConnection.prototype.constructor = VoiceConnection;
          VoiceConnection.prototype.getSoftphoneMediaInfo = function() {
            return this._getData().softphoneMediaInfo;
          };
          VoiceConnection.prototype.getMediaInfo = function() {
            return this._getData().softphoneMediaInfo;
          };
          VoiceConnection.prototype.getMediaType = function() {
            return connect2.MediaType.SOFTPHONE;
          };
          VoiceConnection.prototype.getMediaController = function() {
            return connect2.core.mediaFactory.get(this);
          };
          VoiceConnection.prototype.getVoiceIdSpeakerId = function() {
            return this._speakerAuthenticator.getSpeakerId();
          };
          VoiceConnection.prototype.getVoiceIdSpeakerStatus = function() {
            return this._speakerAuthenticator.getSpeakerStatus();
          };
          VoiceConnection.prototype.optOutVoiceIdSpeaker = function() {
            return this._speakerAuthenticator.optOutSpeaker();
          };
          VoiceConnection.prototype.deleteVoiceIdSpeaker = function() {
            return this._speakerAuthenticator.deleteSpeaker();
          };
          VoiceConnection.prototype.evaluateSpeakerWithVoiceId = function(startNew) {
            return this._speakerAuthenticator.evaluateSpeaker(startNew);
          };
          VoiceConnection.prototype.enrollSpeakerInVoiceId = function(callbackOnAudioCollectionComplete) {
            return this._speakerAuthenticator.enrollSpeaker(callbackOnAudioCollectionComplete);
          };
          VoiceConnection.prototype.updateVoiceIdSpeakerId = function(speakerId) {
            return this._speakerAuthenticator.updateSpeakerIdInVoiceId(speakerId);
          };
          VoiceConnection.prototype.getQuickConnectName = function() {
            return this._getData().quickConnectName;
          };
          VoiceConnection.prototype.isSilentMonitor = function() {
            return this.getMonitorStatus() === connect2.MonitoringMode.SILENT_MONITOR;
          };
          VoiceConnection.prototype.isBarge = function() {
            return this.getMonitorStatus() === connect2.MonitoringMode.BARGE;
          };
          VoiceConnection.prototype.isBargeEnabled = function() {
            var monitoringCapabilities = this.getMonitorCapabilities();
            return monitoringCapabilities && monitoringCapabilities.includes(connect2.MonitoringMode.BARGE);
          };
          VoiceConnection.prototype.isSilentMonitorEnabled = function() {
            var monitoringCapabilities = this.getMonitorCapabilities();
            return monitoringCapabilities && monitoringCapabilities.includes(connect2.MonitoringMode.SILENT_MONITOR);
          };
          VoiceConnection.prototype.getMonitorCapabilities = function() {
            return this._getData().monitorCapabilities;
          };
          VoiceConnection.prototype.getMonitorStatus = function() {
            return this._getData().monitorStatus;
          };
          VoiceConnection.prototype.isMute = function() {
            return this._getData().mute;
          };
          VoiceConnection.prototype.isForcedMute = function() {
            return this._getData().forcedMute;
          };
          VoiceConnection.prototype.muteParticipant = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.MUTE_PARTICIPANT, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId()
            }, callbacks);
          };
          VoiceConnection.prototype.unmuteParticipant = function(callbacks) {
            var client = connect2.core.getClient();
            client.call(connect2.ClientMethods.UNMUTE_PARTICIPANT, {
              contactId: this.getContactId(),
              connectionId: this.getConnectionId()
            }, callbacks);
          };
          VoiceConnection.prototype.canSendVideo = function() {
            const capabilities = this.getCapabilities();
            return capabilities && capabilities.Video === connect2.VideoCapability.SEND;
          };
          VoiceConnection.prototype.getCapabilities = function() {
            return this._getData().capabilities;
          };
          VoiceConnection.prototype.getVideoConnectionInfo = function() {
            const client = connect2.core.getClient();
            const transportDetails = {
              transportType: connect2.TRANSPORT_TYPES.WEB_RTC,
              contactId: this.contactId
            };
            return new Promise(function(resolve, reject) {
              client.call(connect2.ClientMethods.CREATE_TRANSPORT, transportDetails, {
                success: function(data) {
                  connect2.getLog().info("getVideoConnectionInfo succeeded").sendInternalLogToServer();
                  resolve(data.webRTCTransport);
                },
                failure: function(err, data) {
                  connect2.getLog().error("getVideoConnectionInfo failed").sendInternalLogToServer().withObject({
                    err,
                    data
                  });
                  reject(Error("getVideoConnectionInfo failed"));
                }
              });
            });
          };
          var ChatConnection = function(contactId, connectionId) {
            Connection.call(this, contactId, connectionId);
          };
          ChatConnection.prototype = Object.create(Connection.prototype);
          ChatConnection.prototype.constructor = ChatConnection;
          ChatConnection.prototype.getMediaInfo = function() {
            var data = this._getData().chatMediaInfo;
            if (!data) {
              return null;
            } else {
              var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
              var mediaObject = {
                contactId: this.contactId,
                initialContactId: contactData.initialContactId || this.contactId,
                participantId: this.connectionId,
                getConnectionToken: connect2.hitch(this, this.getConnectionToken)
              };
              if (data.connectionData) {
                try {
                  mediaObject.participantToken = JSON.parse(data.connectionData).ConnectionAuthenticationToken;
                } catch (e) {
                  connect2.getLog().error(connect2.LogComponent.CHAT, "Connection data is invalid").withObject(data).withException(e).sendInternalLogToServer();
                  mediaObject.participantToken = null;
                }
              }
              mediaObject.participantToken = mediaObject.participantToken || null;
              mediaObject.originalInfo = this._getData().chatMediaInfo;
              return mediaObject;
            }
          };
          ChatConnection.prototype.getConnectionToken = function() {
            var client = connect2.core.getClient();
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            var transportDetails = {
              transportType: connect2.TRANSPORT_TYPES.CHAT_TOKEN,
              participantId: this.connectionId,
              contactId: this.contactId
            };
            return new Promise(function(resolve, reject) {
              client.call(connect2.ClientMethods.CREATE_TRANSPORT, transportDetails, {
                success: function(data) {
                  connect2.getLog().info("getConnectionToken succeeded").sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err, data) {
                  connect2.getLog().error("getConnectionToken failed").sendInternalLogToServer().withObject({
                    err,
                    data
                  });
                  reject(Error("getConnectionToken failed"));
                }
              });
            });
          };
          ChatConnection.prototype.getMediaType = function() {
            return connect2.MediaType.CHAT;
          };
          ChatConnection.prototype.getMediaController = function() {
            return connect2.core.mediaFactory.get(this);
          };
          ChatConnection.prototype._initMediaController = function() {
            if (this._isAgentConnectionType()) {
              connect2.core.mediaFactory.get(this).catch(function() {
              });
            }
          };
          ChatConnection.prototype.isBargeEnabled = function() {
            var monitoringCapabilities = this.getMonitorCapabilities();
            return monitoringCapabilities && monitoringCapabilities.includes(connect2.MonitoringMode.BARGE);
          };
          ChatConnection.prototype.isSilentMonitorEnabled = function() {
            var monitoringCapabilities = this.getMonitorCapabilities();
            return monitoringCapabilities && monitoringCapabilities.includes(connect2.MonitoringMode.SILENT_MONITOR);
          };
          ChatConnection.prototype.getMonitorCapabilities = function() {
            return this._getData().monitorCapabilities;
          };
          ChatConnection.prototype.isBarge = function() {
            return this.getMonitorStatus() === connect2.MonitoringMode.BARGE;
          };
          ChatConnection.prototype.isSilentMonitor = function() {
            return this.getMonitorStatus() === connect2.MonitoringMode.SILENT_MONITOR;
          };
          ChatConnection.prototype.getMonitorStatus = function() {
            return this._getData().monitorStatus;
          };
          var TaskConnection = function(contactId, connectionId) {
            Connection.call(this, contactId, connectionId);
          };
          TaskConnection.prototype = Object.create(Connection.prototype);
          TaskConnection.prototype.constructor = TaskConnection;
          TaskConnection.prototype.getMediaType = function() {
            return connect2.MediaType.TASK;
          };
          TaskConnection.prototype.getMediaInfo = function() {
            var contactData = connect2.core.getAgentDataProvider().getContactData(this.contactId);
            var mediaObject = {
              contactId: this.contactId,
              initialContactId: contactData.initialContactId || this.contactId
            };
            return mediaObject;
          };
          TaskConnection.prototype.getMediaController = function() {
            return connect2.core.mediaFactory.get(this);
          };
          var ConnectionSnapshot = function(connectionData) {
            connect2.Connection.call(this, connectionData.contactId, connectionData.connectionId);
            this.connectionData = connectionData;
          };
          ConnectionSnapshot.prototype = Object.create(Connection.prototype);
          ConnectionSnapshot.prototype.constructor = ConnectionSnapshot;
          ConnectionSnapshot.prototype._getData = function() {
            return this.connectionData;
          };
          ConnectionSnapshot.prototype._initMediaController = function() {
          };
          var Endpoint = function(paramsIn) {
            var params = paramsIn || {};
            this.endpointARN = params.endpointId || params.endpointARN || null;
            this.endpointId = this.endpointARN;
            this.type = params.type || null;
            this.name = params.name || null;
            this.phoneNumber = params.phoneNumber || null;
            this.agentLogin = params.agentLogin || null;
            this.queue = params.queue || null;
          };
          Endpoint.prototype.stripPhoneNumber = function() {
            return this.phoneNumber ? this.phoneNumber.replace(/sip:([^@]*)@.*/, "$1") : "";
          };
          Endpoint.byPhoneNumber = function(number, name) {
            return new Endpoint({
              type: connect2.EndpointType.PHONE_NUMBER,
              phoneNumber: number,
              name: name || null
            });
          };
          var SoftphoneError = function(errorType, errorMessage, endPointUrl) {
            this.errorType = errorType;
            this.errorMessage = errorMessage;
            this.endPointUrl = endPointUrl;
          };
          SoftphoneError.prototype.getErrorType = function() {
            return this.errorType;
          };
          SoftphoneError.prototype.getErrorMessage = function() {
            return this.errorMessage;
          };
          SoftphoneError.prototype.getEndPointUrl = function() {
            return this.endPointUrl;
          };
          connect2.agent = function(f) {
            var bus = connect2.core.getEventBus();
            var sub = bus.subscribe(connect2.AgentEvents.INIT, f);
            if (connect2.agent.initialized) {
              f(new connect2.Agent());
            }
            return sub;
          };
          connect2.agent.initialized = false;
          connect2.contact = function(f) {
            var bus = connect2.core.getEventBus();
            return bus.subscribe(connect2.ContactEvents.INIT, f);
          };
          connect2.onWebsocketInitFailure = function(f) {
            var bus = connect2.core.getEventBus();
            var sub = bus.subscribe(connect2.WebSocketEvents.INIT_FAILURE, f);
            if (connect2.webSocketInitFailed) {
              f();
            }
            return sub;
          };
          connect2.ifMaster = function(topic, f_true, f_else, shouldNotBecomeMasterIfNone) {
            connect2.assertNotNull(topic, "A topic must be provided.");
            connect2.assertNotNull(f_true, "A true callback must be provided.");
            if (!connect2.core.masterClient) {
              connect2.getLog().warn("We can't be the master for topic '%s' because there is no master client!", topic).sendInternalLogToServer();
              if (f_else) {
                f_else();
              }
              return;
            }
            var masterClient = connect2.core.getMasterClient();
            masterClient.call(connect2.MasterMethods.CHECK_MASTER, {
              topic,
              shouldNotBecomeMasterIfNone
            }, {
              success: function(data) {
                if (data.isMaster) {
                  f_true();
                } else if (f_else) {
                  f_else();
                }
              }
            });
          };
          connect2.becomeMaster = function(topic, successCallback, failureCallback) {
            connect2.assertNotNull(topic, "A topic must be provided.");
            if (!connect2.core.masterClient) {
              connect2.getLog().warn("We can't be the master for topic '%s' because there is no master client!", topic);
              if (failureCallback) {
                failureCallback();
              }
            } else {
              var masterClient = connect2.core.getMasterClient();
              masterClient.call(connect2.MasterMethods.BECOME_MASTER, {
                topic
              }, {
                success: function() {
                  if (successCallback) {
                    successCallback();
                  }
                }
              });
            }
          };
          connect2.Agent = Agent;
          connect2.AgentSnapshot = AgentSnapshot;
          connect2.Contact = Contact;
          connect2.ContactSnapshot = ContactSnapshot;
          connect2.Connection = VoiceConnection;
          connect2.BaseConnection = Connection;
          connect2.VoiceConnection = VoiceConnection;
          connect2.ChatConnection = ChatConnection;
          connect2.TaskConnection = TaskConnection;
          connect2.ConnectionSnapshot = ConnectionSnapshot;
          connect2.Endpoint = Endpoint;
          connect2.Address = Endpoint;
          connect2.SoftphoneError = SoftphoneError;
          connect2.VoiceId = VoiceId;
          connect2.QuickResponses = QuickResponses;
        })();
      }
    ),
    /***/
    827: (
      /***/
      (module, exports, __webpack_require__2) => {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        (/* @__PURE__ */ function() {
          function r(e, n, t) {
            function o(i2, f) {
              if (!n[i2]) {
                if (!e[i2]) {
                  var c = void 0;
                  if (!f && c)
                    return __require(i2, true);
                  if (u)
                    return u(i2, true);
                  var a = new Error("Cannot find module '" + i2 + "'");
                  throw a.code = "MODULE_NOT_FOUND", a;
                }
                var p = n[i2] = { exports: {} };
                e[i2][0].call(p.exports, function(r2) {
                  var n2 = e[i2][1][r2];
                  return o(n2 || r2);
                }, p, p.exports, r, e, n, t);
              }
              return n[i2].exports;
            }
            for (var u = void 0, i = 0; i < t.length; i++)
              o(t[i]);
            return o;
          }
          return r;
        }())({ 1: [function(require2, module2, exports2) {
          module2.exports = {
            "version": "2.0",
            "metadata": {
              "apiVersion": "2014-06-30",
              "endpointPrefix": "cognito-identity",
              "jsonVersion": "1.1",
              "protocol": "json",
              "serviceFullName": "Amazon Cognito Identity",
              "serviceId": "Cognito Identity",
              "signatureVersion": "v4",
              "targetPrefix": "AWSCognitoIdentityService",
              "uid": "cognito-identity-2014-06-30"
            },
            "operations": {
              "CreateIdentityPool": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolName",
                    "AllowUnauthenticatedIdentities"
                  ],
                  "members": {
                    "IdentityPoolName": {},
                    "AllowUnauthenticatedIdentities": {
                      "type": "boolean"
                    },
                    "AllowClassicFlow": {
                      "type": "boolean"
                    },
                    "SupportedLoginProviders": {
                      "shape": "S5"
                    },
                    "DeveloperProviderName": {},
                    "OpenIdConnectProviderARNs": {
                      "shape": "S9"
                    },
                    "CognitoIdentityProviders": {
                      "shape": "Sb"
                    },
                    "SamlProviderARNs": {
                      "shape": "Sg"
                    },
                    "IdentityPoolTags": {
                      "shape": "Sh"
                    }
                  }
                },
                "output": {
                  "shape": "Sk"
                }
              },
              "DeleteIdentities": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityIdsToDelete"
                  ],
                  "members": {
                    "IdentityIdsToDelete": {
                      "type": "list",
                      "member": {}
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "UnprocessedIdentityIds": {
                      "type": "list",
                      "member": {
                        "type": "structure",
                        "members": {
                          "IdentityId": {},
                          "ErrorCode": {}
                        }
                      }
                    }
                  }
                }
              },
              "DeleteIdentityPool": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId"
                  ],
                  "members": {
                    "IdentityPoolId": {}
                  }
                }
              },
              "DescribeIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityId"
                  ],
                  "members": {
                    "IdentityId": {}
                  }
                },
                "output": {
                  "shape": "Sv"
                }
              },
              "DescribeIdentityPool": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId"
                  ],
                  "members": {
                    "IdentityPoolId": {}
                  }
                },
                "output": {
                  "shape": "Sk"
                }
              },
              "GetCredentialsForIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityId"
                  ],
                  "members": {
                    "IdentityId": {},
                    "Logins": {
                      "shape": "S10"
                    },
                    "CustomRoleArn": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {},
                    "Credentials": {
                      "type": "structure",
                      "members": {
                        "AccessKeyId": {},
                        "SecretKey": {},
                        "SessionToken": {},
                        "Expiration": {
                          "type": "timestamp"
                        }
                      }
                    }
                  }
                },
                "authtype": "none"
              },
              "GetId": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId"
                  ],
                  "members": {
                    "AccountId": {},
                    "IdentityPoolId": {},
                    "Logins": {
                      "shape": "S10"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {}
                  }
                },
                "authtype": "none"
              },
              "GetIdentityPoolRoles": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId"
                  ],
                  "members": {
                    "IdentityPoolId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityPoolId": {},
                    "Roles": {
                      "shape": "S1c"
                    },
                    "RoleMappings": {
                      "shape": "S1e"
                    }
                  }
                }
              },
              "GetOpenIdToken": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityId"
                  ],
                  "members": {
                    "IdentityId": {},
                    "Logins": {
                      "shape": "S10"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {},
                    "Token": {}
                  }
                },
                "authtype": "none"
              },
              "GetOpenIdTokenForDeveloperIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId",
                    "Logins"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityId": {},
                    "Logins": {
                      "shape": "S10"
                    },
                    "PrincipalTags": {
                      "shape": "S1s"
                    },
                    "TokenDuration": {
                      "type": "long"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {},
                    "Token": {}
                  }
                }
              },
              "GetPrincipalTagAttributeMap": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId",
                    "IdentityProviderName"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityProviderName": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityProviderName": {},
                    "UseDefaults": {
                      "type": "boolean"
                    },
                    "PrincipalTags": {
                      "shape": "S1s"
                    }
                  }
                }
              },
              "ListIdentities": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId",
                    "MaxResults"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "MaxResults": {
                      "type": "integer"
                    },
                    "NextToken": {},
                    "HideDisabled": {
                      "type": "boolean"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityPoolId": {},
                    "Identities": {
                      "type": "list",
                      "member": {
                        "shape": "Sv"
                      }
                    },
                    "NextToken": {}
                  }
                }
              },
              "ListIdentityPools": {
                "input": {
                  "type": "structure",
                  "required": [
                    "MaxResults"
                  ],
                  "members": {
                    "MaxResults": {
                      "type": "integer"
                    },
                    "NextToken": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityPools": {
                      "type": "list",
                      "member": {
                        "type": "structure",
                        "members": {
                          "IdentityPoolId": {},
                          "IdentityPoolName": {}
                        }
                      }
                    },
                    "NextToken": {}
                  }
                }
              },
              "ListTagsForResource": {
                "input": {
                  "type": "structure",
                  "required": [
                    "ResourceArn"
                  ],
                  "members": {
                    "ResourceArn": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "Tags": {
                      "shape": "Sh"
                    }
                  }
                }
              },
              "LookupDeveloperIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityId": {},
                    "DeveloperUserIdentifier": {},
                    "MaxResults": {
                      "type": "integer"
                    },
                    "NextToken": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {},
                    "DeveloperUserIdentifierList": {
                      "type": "list",
                      "member": {}
                    },
                    "NextToken": {}
                  }
                }
              },
              "MergeDeveloperIdentities": {
                "input": {
                  "type": "structure",
                  "required": [
                    "SourceUserIdentifier",
                    "DestinationUserIdentifier",
                    "DeveloperProviderName",
                    "IdentityPoolId"
                  ],
                  "members": {
                    "SourceUserIdentifier": {},
                    "DestinationUserIdentifier": {},
                    "DeveloperProviderName": {},
                    "IdentityPoolId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityId": {}
                  }
                }
              },
              "SetIdentityPoolRoles": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId",
                    "Roles"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "Roles": {
                      "shape": "S1c"
                    },
                    "RoleMappings": {
                      "shape": "S1e"
                    }
                  }
                }
              },
              "SetPrincipalTagAttributeMap": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityPoolId",
                    "IdentityProviderName"
                  ],
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityProviderName": {},
                    "UseDefaults": {
                      "type": "boolean"
                    },
                    "PrincipalTags": {
                      "shape": "S1s"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "IdentityPoolId": {},
                    "IdentityProviderName": {},
                    "UseDefaults": {
                      "type": "boolean"
                    },
                    "PrincipalTags": {
                      "shape": "S1s"
                    }
                  }
                }
              },
              "TagResource": {
                "input": {
                  "type": "structure",
                  "required": [
                    "ResourceArn",
                    "Tags"
                  ],
                  "members": {
                    "ResourceArn": {},
                    "Tags": {
                      "shape": "Sh"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "UnlinkDeveloperIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityId",
                    "IdentityPoolId",
                    "DeveloperProviderName",
                    "DeveloperUserIdentifier"
                  ],
                  "members": {
                    "IdentityId": {},
                    "IdentityPoolId": {},
                    "DeveloperProviderName": {},
                    "DeveloperUserIdentifier": {}
                  }
                }
              },
              "UnlinkIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "IdentityId",
                    "Logins",
                    "LoginsToRemove"
                  ],
                  "members": {
                    "IdentityId": {},
                    "Logins": {
                      "shape": "S10"
                    },
                    "LoginsToRemove": {
                      "shape": "Sw"
                    }
                  }
                },
                "authtype": "none"
              },
              "UntagResource": {
                "input": {
                  "type": "structure",
                  "required": [
                    "ResourceArn",
                    "TagKeys"
                  ],
                  "members": {
                    "ResourceArn": {},
                    "TagKeys": {
                      "type": "list",
                      "member": {}
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "UpdateIdentityPool": {
                "input": {
                  "shape": "Sk"
                },
                "output": {
                  "shape": "Sk"
                }
              }
            },
            "shapes": {
              "S5": {
                "type": "map",
                "key": {},
                "value": {}
              },
              "S9": {
                "type": "list",
                "member": {}
              },
              "Sb": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "ProviderName": {},
                    "ClientId": {},
                    "ServerSideTokenCheck": {
                      "type": "boolean"
                    }
                  }
                }
              },
              "Sg": {
                "type": "list",
                "member": {}
              },
              "Sh": {
                "type": "map",
                "key": {},
                "value": {}
              },
              "Sk": {
                "type": "structure",
                "required": [
                  "IdentityPoolId",
                  "IdentityPoolName",
                  "AllowUnauthenticatedIdentities"
                ],
                "members": {
                  "IdentityPoolId": {},
                  "IdentityPoolName": {},
                  "AllowUnauthenticatedIdentities": {
                    "type": "boolean"
                  },
                  "AllowClassicFlow": {
                    "type": "boolean"
                  },
                  "SupportedLoginProviders": {
                    "shape": "S5"
                  },
                  "DeveloperProviderName": {},
                  "OpenIdConnectProviderARNs": {
                    "shape": "S9"
                  },
                  "CognitoIdentityProviders": {
                    "shape": "Sb"
                  },
                  "SamlProviderARNs": {
                    "shape": "Sg"
                  },
                  "IdentityPoolTags": {
                    "shape": "Sh"
                  }
                }
              },
              "Sv": {
                "type": "structure",
                "members": {
                  "IdentityId": {},
                  "Logins": {
                    "shape": "Sw"
                  },
                  "CreationDate": {
                    "type": "timestamp"
                  },
                  "LastModifiedDate": {
                    "type": "timestamp"
                  }
                }
              },
              "Sw": {
                "type": "list",
                "member": {}
              },
              "S10": {
                "type": "map",
                "key": {},
                "value": {}
              },
              "S1c": {
                "type": "map",
                "key": {},
                "value": {}
              },
              "S1e": {
                "type": "map",
                "key": {},
                "value": {
                  "type": "structure",
                  "required": [
                    "Type"
                  ],
                  "members": {
                    "Type": {},
                    "AmbiguousRoleResolution": {},
                    "RulesConfiguration": {
                      "type": "structure",
                      "required": [
                        "Rules"
                      ],
                      "members": {
                        "Rules": {
                          "type": "list",
                          "member": {
                            "type": "structure",
                            "required": [
                              "Claim",
                              "MatchType",
                              "Value",
                              "RoleARN"
                            ],
                            "members": {
                              "Claim": {},
                              "MatchType": {},
                              "Value": {},
                              "RoleARN": {}
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "S1s": {
                "type": "map",
                "key": {},
                "value": {}
              }
            }
          };
        }, {}], 2: [function(require2, module2, exports2) {
          module2.exports = {
            "pagination": {
              "ListIdentityPools": {
                "input_token": "NextToken",
                "limit_key": "MaxResults",
                "output_token": "NextToken",
                "result_key": "IdentityPools"
              }
            }
          };
        }, {}], 3: [function(require2, module2, exports2) {
          module2.exports = {
            "version": "2.0",
            "metadata": {
              "apiVersion": "2017-02-15",
              "endpointPrefix": "connect",
              "jsonVersion": "1.0",
              "protocol": "json",
              "serviceAbbreviation": "Connect",
              "serviceFullName": "AmazonConnectCTIService",
              "signatureVersion": "",
              "targetPrefix": "AmazonConnectCTIService",
              "uid": "connect-2017-02-15"
            },
            "operations": {
              "AcceptContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "ClearContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId"
                  ],
                  "members": {
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "CompleteContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId"
                  ],
                  "members": {
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "ConferenceConnections": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "CreateAdditionalConnection": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "endpoint"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "endpoint": {
                      "shape": "Se"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "CreateOutboundContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "endpoint"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "endpoint": {
                      "shape": "Se"
                    },
                    "queueARN": {},
                    "relatedContactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "CreateTaskContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "endpoint",
                    "name"
                  ],
                  "members": {
                    "endpoint": {
                      "shape": "Se"
                    },
                    "previousContactId": {},
                    "name": {},
                    "description": {},
                    "references": {
                      "shape": "Sr"
                    },
                    "idempotencyToken": {},
                    "scheduledTime": {
                      "type": "long"
                    },
                    "relatedContactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "contactId": {}
                  }
                }
              },
              "CreateTransport": {
                "input": {
                  "type": "structure",
                  "required": [
                    "transportType",
                    "authentication"
                  ],
                  "members": {
                    "transportType": {},
                    "participantId": {},
                    "contactId": {},
                    "softphoneClientId": {},
                    "authentication": {
                      "shape": "S2"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "webSocketTransport": {
                      "type": "structure",
                      "required": [
                        "url",
                        "transportLifeTimeInSeconds"
                      ],
                      "members": {
                        "url": {},
                        "transportLifeTimeInSeconds": {
                          "type": "long"
                        },
                        "expiry": {}
                      }
                    },
                    "chatTokenTransport": {
                      "type": "structure",
                      "required": [
                        "participantToken",
                        "expiry"
                      ],
                      "members": {
                        "participantToken": {},
                        "expiry": {}
                      }
                    },
                    "softphoneTransport": {
                      "type": "structure",
                      "required": [
                        "softphoneMediaConnections"
                      ],
                      "members": {
                        "softphoneMediaConnections": {
                          "type": "list",
                          "member": {
                            "type": "structure",
                            "required": [
                              "username",
                              "credential",
                              "urls"
                            ],
                            "members": {
                              "username": {},
                              "credential": {},
                              "urls": {
                                "type": "list",
                                "member": {}
                              }
                            }
                          }
                        }
                      }
                    },
                    "agentDiscoveryTransport": {
                      "type": "structure",
                      "required": [
                        "presignedUrl"
                      ],
                      "members": {
                        "presignedUrl": {}
                      }
                    },
                    "webRTCTransport": {
                      "type": "structure",
                      "required": [
                        "meeting",
                        "attendee"
                      ],
                      "members": {
                        "meeting": {
                          "type": "structure",
                          "members": {
                            "meetingId": {},
                            "mediaRegion": {},
                            "mediaPlacement": {
                              "type": "structure",
                              "members": {
                                "audioHostUrl": {},
                                "audioFallbackUrl": {},
                                "signalingUrl": {},
                                "turnControlUrl": {},
                                "eventIngestionUrl": {}
                              }
                            },
                            "meetingFeatures": {
                              "type": "structure",
                              "members": {
                                "audio": {
                                  "type": "structure",
                                  "members": {
                                    "echoReduction": {}
                                  }
                                }
                              }
                            }
                          }
                        },
                        "attendee": {
                          "type": "structure",
                          "members": {
                            "attendeeId": {},
                            "joinToken": {
                              "type": "string",
                              "sensitive": true
                            }
                          }
                        }
                      }
                    }
                  }
                }
              },
              "DestroyConnection": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "GetAgentConfiguration": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "configuration"
                  ],
                  "members": {
                    "configuration": {
                      "shape": "S1q"
                    }
                  }
                }
              },
              "GetAgentPermissions": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "nextToken": {},
                    "maxResults": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "permissions"
                  ],
                  "members": {
                    "permissions": {
                      "type": "list",
                      "member": {}
                    },
                    "nextToken": {}
                  }
                }
              },
              "GetAgentSnapshot": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "nextToken": {},
                    "timeout": {
                      "type": "long"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "snapshot",
                    "nextToken"
                  ],
                  "members": {
                    "snapshot": {
                      "type": "structure",
                      "required": [
                        "state",
                        "contacts",
                        "snapshotTimestamp"
                      ],
                      "members": {
                        "state": {
                          "shape": "S29"
                        },
                        "nextState": {
                          "shape": "S29"
                        },
                        "agentAvailabilityState": {
                          "type": "structure",
                          "members": {
                            "state": {},
                            "timeStamp": {
                              "type": "timestamp"
                            }
                          }
                        },
                        "contacts": {
                          "type": "list",
                          "member": {
                            "type": "structure",
                            "required": [
                              "contactId",
                              "type",
                              "state",
                              "connections",
                              "attributes"
                            ],
                            "members": {
                              "contactId": {},
                              "initialContactId": {},
                              "type": {},
                              "state": {
                                "type": "structure",
                                "required": [
                                  "type",
                                  "timestamp"
                                ],
                                "members": {
                                  "type": {},
                                  "timestamp": {
                                    "type": "timestamp"
                                  }
                                }
                              },
                              "queue": {
                                "shape": "Sk"
                              },
                              "queueTimestamp": {
                                "type": "timestamp"
                              },
                              "connections": {
                                "type": "list",
                                "member": {
                                  "type": "structure",
                                  "required": [
                                    "connectionId",
                                    "state",
                                    "type",
                                    "initial"
                                  ],
                                  "members": {
                                    "connectionId": {},
                                    "endpoint": {
                                      "shape": "Se"
                                    },
                                    "state": {
                                      "type": "structure",
                                      "required": [
                                        "type",
                                        "timestamp"
                                      ],
                                      "members": {
                                        "type": {},
                                        "timestamp": {
                                          "type": "timestamp"
                                        }
                                      }
                                    },
                                    "type": {},
                                    "initial": {
                                      "type": "boolean"
                                    },
                                    "softphoneMediaInfo": {
                                      "type": "structure",
                                      "members": {
                                        "callType": {},
                                        "autoAccept": {
                                          "type": "boolean"
                                        },
                                        "mediaLegContextToken": {},
                                        "callContextToken": {},
                                        "callConfigJson": {}
                                      }
                                    },
                                    "chatMediaInfo": {
                                      "type": "structure",
                                      "members": {
                                        "chatAutoAccept": {
                                          "type": "boolean"
                                        },
                                        "connectionData": {},
                                        "customerName": {}
                                      }
                                    },
                                    "monitoringInfo": {
                                      "type": "structure",
                                      "members": {
                                        "agent": {
                                          "type": "structure",
                                          "members": {
                                            "agentName": {}
                                          }
                                        },
                                        "joinTimeStamp": {
                                          "type": "timestamp"
                                        }
                                      }
                                    },
                                    "mute": {
                                      "type": "boolean"
                                    },
                                    "forcedMute": {
                                      "type": "boolean"
                                    },
                                    "quickConnectName": {},
                                    "monitorCapabilities": {
                                      "type": "list",
                                      "member": {}
                                    },
                                    "monitorStatus": {},
                                    "capabilities": {
                                      "type": "structure",
                                      "members": {
                                        "Video": {}
                                      }
                                    }
                                  }
                                }
                              },
                              "attributes": {
                                "type": "map",
                                "key": {},
                                "value": {
                                  "type": "structure",
                                  "required": [
                                    "name"
                                  ],
                                  "members": {
                                    "name": {},
                                    "value": {}
                                  }
                                }
                              },
                              "contactDuration": {},
                              "name": {},
                              "description": {},
                              "references": {
                                "shape": "Sr"
                              },
                              "initiationMethod": {},
                              "contactFeatures": {
                                "type": "structure",
                                "members": {
                                  "attachmentsEnabled": {
                                    "type": "boolean"
                                  },
                                  "messagingMarkdownEnabled": {
                                    "type": "boolean"
                                  },
                                  "multiPartyConferenceEnabled": {
                                    "type": "boolean"
                                  },
                                  "screenRecordingEnabled": {
                                    "type": "boolean"
                                  },
                                  "screenRecordingState": {},
                                  "screenRecordingConfig": {
                                    "type": "structure",
                                    "members": {
                                      "screenRecordingEnabled": {
                                        "type": "boolean"
                                      },
                                      "screenRecordingState": {}
                                    }
                                  }
                                }
                              },
                              "channelContext": {
                                "type": "structure",
                                "members": {
                                  "scheduledTime": {
                                    "type": "long"
                                  },
                                  "taskTemplateId": {},
                                  "taskTemplateVersion": {
                                    "type": "integer"
                                  }
                                }
                              },
                              "segmentAttributes": {
                                "type": "map",
                                "key": {},
                                "value": {
                                  "type": "structure",
                                  "members": {
                                    "ValueString": {}
                                  }
                                }
                              }
                            }
                          }
                        },
                        "snapshotTimestamp": {
                          "type": "timestamp"
                        }
                      }
                    },
                    "nextToken": {}
                  }
                }
              },
              "GetAgentStates": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "nextToken": {},
                    "maxResults": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "states"
                  ],
                  "members": {
                    "states": {
                      "type": "list",
                      "member": {
                        "shape": "S29"
                      }
                    },
                    "nextToken": {}
                  }
                }
              },
              "GetDialableCountryCodes": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "nextToken": {},
                    "maxResults": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "countryCodes"
                  ],
                  "members": {
                    "countryCodes": {
                      "type": "list",
                      "member": {}
                    },
                    "nextToken": {}
                  }
                }
              },
              "GetEndpoints": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "queueARNs"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "queueARNs": {
                      "type": "list",
                      "member": {}
                    },
                    "nextToken": {},
                    "maxResults": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "endpoints": {
                      "type": "list",
                      "member": {
                        "shape": "Se"
                      }
                    },
                    "nextToken": {}
                  }
                }
              },
              "GetNewAuthToken": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "refreshToken"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "refreshToken": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {
                    "newAuthToken": {},
                    "expirationDateTime": {
                      "type": "timestamp"
                    }
                  }
                }
              },
              "GetRoutingProfileQueues": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "routingProfileARN"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "routingProfileARN": {},
                    "nextToken": {},
                    "maxResults": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "required": [
                    "queues"
                  ],
                  "members": {
                    "queues": {
                      "type": "list",
                      "member": {
                        "shape": "Sk"
                      }
                    },
                    "nextToken": {}
                  }
                }
              },
              "HoldConnection": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "MuteParticipant": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "NotifyContactIssue": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "issueCode": {},
                    "description": {},
                    "clientLogs": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "PauseContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId"
                  ],
                  "members": {
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "PutAgentState": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "state"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "state": {
                      "shape": "S29"
                    },
                    "enqueueNextState": {
                      "type": "boolean"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "RejectContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId"
                  ],
                  "members": {
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "ResumeConnection": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "ResumeContact": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId"
                  ],
                  "members": {
                    "contactId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "SendClientLogs": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "logEvents"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "logEvents": {
                      "type": "list",
                      "member": {
                        "type": "structure",
                        "members": {
                          "timestamp": {
                            "type": "timestamp"
                          },
                          "component": {},
                          "message": {}
                        }
                      }
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "SendDigits": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId",
                    "digits"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {},
                    "digits": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "SendSoftphoneCallMetrics": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "softphoneStreamStatistics"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "ccpVersion": {},
                    "softphoneStreamStatistics": {
                      "shape": "S4f"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "SendSoftphoneCallReport": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "report"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "ccpVersion": {},
                    "report": {
                      "type": "structure",
                      "members": {
                        "callStartTime": {
                          "type": "timestamp"
                        },
                        "callEndTime": {
                          "type": "timestamp"
                        },
                        "softphoneStreamStatistics": {
                          "shape": "S4f"
                        },
                        "gumTimeMillis": {
                          "type": "long"
                        },
                        "initializationTimeMillis": {
                          "type": "long"
                        },
                        "iceCollectionTimeMillis": {
                          "type": "long"
                        },
                        "signallingConnectTimeMillis": {
                          "type": "long"
                        },
                        "handshakeTimeMillis": {
                          "type": "long"
                        },
                        "preTalkTimeMillis": {
                          "type": "long"
                        },
                        "talkTimeMillis": {
                          "type": "long"
                        },
                        "cleanupTimeMillis": {
                          "type": "long"
                        },
                        "iceCollectionFailure": {
                          "type": "boolean"
                        },
                        "signallingConnectionFailure": {
                          "type": "boolean"
                        },
                        "handshakeFailure": {
                          "type": "boolean"
                        },
                        "gumOtherFailure": {
                          "type": "boolean"
                        },
                        "gumTimeoutFailure": {
                          "type": "boolean"
                        },
                        "createOfferFailure": {
                          "type": "boolean"
                        },
                        "setLocalDescriptionFailure": {
                          "type": "boolean"
                        },
                        "userBusyFailure": {
                          "type": "boolean"
                        },
                        "invalidRemoteSDPFailure": {
                          "type": "boolean"
                        },
                        "noRemoteIceCandidateFailure": {
                          "type": "boolean"
                        },
                        "setRemoteDescriptionFailure": {
                          "type": "boolean"
                        }
                      }
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "ToggleActiveConnections": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "UnmuteParticipant": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "contactId",
                    "connectionId"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "contactId": {},
                    "connectionId": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "UpdateAgentConfiguration": {
                "input": {
                  "type": "structure",
                  "required": [
                    "authentication",
                    "configuration"
                  ],
                  "members": {
                    "authentication": {
                      "shape": "S2"
                    },
                    "configuration": {
                      "shape": "S1q"
                    }
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              },
              "UpdateMonitorParticipantState": {
                "input": {
                  "type": "structure",
                  "required": [
                    "contactId",
                    "targetMonitorMode"
                  ],
                  "members": {
                    "contactId": {},
                    "targetMonitorMode": {}
                  }
                },
                "output": {
                  "type": "structure",
                  "members": {}
                }
              }
            },
            "shapes": {
              "S2": {
                "type": "structure",
                "members": {
                  "agentARN": {},
                  "authToken": {}
                }
              },
              "Se": {
                "type": "structure",
                "required": [
                  "type"
                ],
                "members": {
                  "endpointARN": {},
                  "type": {},
                  "name": {},
                  "phoneNumber": {},
                  "agentLogin": {},
                  "queue": {
                    "shape": "Sk"
                  }
                }
              },
              "Sk": {
                "type": "structure",
                "members": {
                  "queueARN": {},
                  "name": {}
                }
              },
              "Sr": {
                "type": "map",
                "key": {},
                "value": {
                  "type": "structure",
                  "required": [
                    "value",
                    "type"
                  ],
                  "members": {
                    "value": {},
                    "type": {}
                  }
                }
              },
              "S1q": {
                "type": "structure",
                "required": [
                  "name",
                  "softphoneEnabled",
                  "softphoneAutoAccept",
                  "extension",
                  "routingProfile"
                ],
                "members": {
                  "name": {},
                  "username": {},
                  "softphoneEnabled": {
                    "type": "boolean"
                  },
                  "softphoneAutoAccept": {
                    "type": "boolean"
                  },
                  "extension": {},
                  "routingProfile": {
                    "type": "structure",
                    "members": {
                      "name": {},
                      "routingProfileARN": {},
                      "defaultOutboundQueue": {
                        "shape": "Sk"
                      },
                      "channelConcurrencyMap": {
                        "type": "map",
                        "key": {},
                        "value": {
                          "type": "long"
                        }
                      }
                    }
                  },
                  "agentPreferences": {
                    "type": "map",
                    "key": {},
                    "value": {}
                  },
                  "agentARN": {}
                }
              },
              "S29": {
                "type": "structure",
                "required": [
                  "type",
                  "name"
                ],
                "members": {
                  "agentStateARN": {},
                  "type": {},
                  "name": {},
                  "startTimestamp": {
                    "type": "timestamp"
                  }
                }
              },
              "S4f": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "timestamp": {
                      "type": "timestamp"
                    },
                    "softphoneStreamType": {},
                    "packetCount": {
                      "type": "long"
                    },
                    "packetsLost": {
                      "type": "long"
                    },
                    "audioLevel": {
                      "type": "double"
                    },
                    "jitterBufferMillis": {
                      "type": "long"
                    },
                    "roundTripTimeMillis": {
                      "type": "long"
                    }
                  }
                }
              }
            }
          };
        }, {}], 4: [function(require2, module2, exports2) {
          module2.exports = {
            "acm": {
              "name": "ACM",
              "cors": true
            },
            "apigateway": {
              "name": "APIGateway",
              "cors": true
            },
            "applicationautoscaling": {
              "prefix": "application-autoscaling",
              "name": "ApplicationAutoScaling",
              "cors": true
            },
            "appstream": {
              "name": "AppStream"
            },
            "autoscaling": {
              "name": "AutoScaling",
              "cors": true
            },
            "batch": {
              "name": "Batch"
            },
            "budgets": {
              "name": "Budgets"
            },
            "clouddirectory": {
              "name": "CloudDirectory",
              "versions": [
                "2016-05-10*"
              ]
            },
            "cloudformation": {
              "name": "CloudFormation",
              "cors": true
            },
            "cloudfront": {
              "name": "CloudFront",
              "versions": [
                "2013-05-12*",
                "2013-11-11*",
                "2014-05-31*",
                "2014-10-21*",
                "2014-11-06*",
                "2015-04-17*",
                "2015-07-27*",
                "2015-09-17*",
                "2016-01-13*",
                "2016-01-28*",
                "2016-08-01*",
                "2016-08-20*",
                "2016-09-07*",
                "2016-09-29*",
                "2016-11-25*",
                "2017-03-25*",
                "2017-10-30*",
                "2018-06-18*",
                "2018-11-05*",
                "2019-03-26*"
              ],
              "cors": true
            },
            "cloudhsm": {
              "name": "CloudHSM",
              "cors": true
            },
            "cloudsearch": {
              "name": "CloudSearch"
            },
            "cloudsearchdomain": {
              "name": "CloudSearchDomain"
            },
            "cloudtrail": {
              "name": "CloudTrail",
              "cors": true
            },
            "cloudwatch": {
              "prefix": "monitoring",
              "name": "CloudWatch",
              "cors": true
            },
            "cloudwatchevents": {
              "prefix": "events",
              "name": "CloudWatchEvents",
              "versions": [
                "2014-02-03*"
              ],
              "cors": true
            },
            "cloudwatchlogs": {
              "prefix": "logs",
              "name": "CloudWatchLogs",
              "cors": true
            },
            "codebuild": {
              "name": "CodeBuild",
              "cors": true
            },
            "codecommit": {
              "name": "CodeCommit",
              "cors": true
            },
            "codedeploy": {
              "name": "CodeDeploy",
              "cors": true
            },
            "codepipeline": {
              "name": "CodePipeline",
              "cors": true
            },
            "cognitoidentity": {
              "prefix": "cognito-identity",
              "name": "CognitoIdentity",
              "cors": true
            },
            "cognitoidentityserviceprovider": {
              "prefix": "cognito-idp",
              "name": "CognitoIdentityServiceProvider",
              "cors": true
            },
            "cognitosync": {
              "prefix": "cognito-sync",
              "name": "CognitoSync",
              "cors": true
            },
            "configservice": {
              "prefix": "config",
              "name": "ConfigService",
              "cors": true
            },
            "cur": {
              "name": "CUR",
              "cors": true
            },
            "datapipeline": {
              "name": "DataPipeline"
            },
            "devicefarm": {
              "name": "DeviceFarm",
              "cors": true
            },
            "directconnect": {
              "name": "DirectConnect",
              "cors": true
            },
            "directoryservice": {
              "prefix": "ds",
              "name": "DirectoryService"
            },
            "discovery": {
              "name": "Discovery"
            },
            "dms": {
              "name": "DMS"
            },
            "dynamodb": {
              "name": "DynamoDB",
              "cors": true
            },
            "dynamodbstreams": {
              "prefix": "streams.dynamodb",
              "name": "DynamoDBStreams",
              "cors": true
            },
            "ec2": {
              "name": "EC2",
              "versions": [
                "2013-06-15*",
                "2013-10-15*",
                "2014-02-01*",
                "2014-05-01*",
                "2014-06-15*",
                "2014-09-01*",
                "2014-10-01*",
                "2015-03-01*",
                "2015-04-15*",
                "2015-10-01*",
                "2016-04-01*",
                "2016-09-15*"
              ],
              "cors": true
            },
            "ecr": {
              "name": "ECR",
              "cors": true
            },
            "ecs": {
              "name": "ECS",
              "cors": true
            },
            "efs": {
              "prefix": "elasticfilesystem",
              "name": "EFS",
              "cors": true
            },
            "elasticache": {
              "name": "ElastiCache",
              "versions": [
                "2012-11-15*",
                "2014-03-24*",
                "2014-07-15*",
                "2014-09-30*"
              ],
              "cors": true
            },
            "elasticbeanstalk": {
              "name": "ElasticBeanstalk",
              "cors": true
            },
            "elb": {
              "prefix": "elasticloadbalancing",
              "name": "ELB",
              "cors": true
            },
            "elbv2": {
              "prefix": "elasticloadbalancingv2",
              "name": "ELBv2",
              "cors": true
            },
            "emr": {
              "prefix": "elasticmapreduce",
              "name": "EMR",
              "cors": true
            },
            "es": {
              "name": "ES"
            },
            "elastictranscoder": {
              "name": "ElasticTranscoder",
              "cors": true
            },
            "firehose": {
              "name": "Firehose",
              "cors": true
            },
            "gamelift": {
              "name": "GameLift",
              "cors": true
            },
            "glacier": {
              "name": "Glacier"
            },
            "health": {
              "name": "Health"
            },
            "iam": {
              "name": "IAM",
              "cors": true
            },
            "importexport": {
              "name": "ImportExport"
            },
            "inspector": {
              "name": "Inspector",
              "versions": [
                "2015-08-18*"
              ],
              "cors": true
            },
            "iot": {
              "name": "Iot",
              "cors": true
            },
            "iotdata": {
              "prefix": "iot-data",
              "name": "IotData",
              "cors": true
            },
            "kinesis": {
              "name": "Kinesis",
              "cors": true
            },
            "kinesisanalytics": {
              "name": "KinesisAnalytics"
            },
            "kms": {
              "name": "KMS",
              "cors": true
            },
            "lambda": {
              "name": "Lambda",
              "cors": true
            },
            "lexruntime": {
              "prefix": "runtime.lex",
              "name": "LexRuntime",
              "cors": true
            },
            "lightsail": {
              "name": "Lightsail"
            },
            "machinelearning": {
              "name": "MachineLearning",
              "cors": true
            },
            "marketplacecommerceanalytics": {
              "name": "MarketplaceCommerceAnalytics",
              "cors": true
            },
            "marketplacemetering": {
              "prefix": "meteringmarketplace",
              "name": "MarketplaceMetering"
            },
            "mturk": {
              "prefix": "mturk-requester",
              "name": "MTurk",
              "cors": true
            },
            "mobileanalytics": {
              "name": "MobileAnalytics",
              "cors": true
            },
            "opsworks": {
              "name": "OpsWorks",
              "cors": true
            },
            "opsworkscm": {
              "name": "OpsWorksCM"
            },
            "organizations": {
              "name": "Organizations"
            },
            "pinpoint": {
              "name": "Pinpoint"
            },
            "polly": {
              "name": "Polly",
              "cors": true
            },
            "rds": {
              "name": "RDS",
              "versions": [
                "2014-09-01*"
              ],
              "cors": true
            },
            "redshift": {
              "name": "Redshift",
              "cors": true
            },
            "rekognition": {
              "name": "Rekognition",
              "cors": true
            },
            "resourcegroupstaggingapi": {
              "name": "ResourceGroupsTaggingAPI"
            },
            "route53": {
              "name": "Route53",
              "cors": true
            },
            "route53domains": {
              "name": "Route53Domains",
              "cors": true
            },
            "s3": {
              "name": "S3",
              "dualstackAvailable": true,
              "cors": true
            },
            "s3control": {
              "name": "S3Control",
              "dualstackAvailable": true,
              "xmlNoDefaultLists": true
            },
            "servicecatalog": {
              "name": "ServiceCatalog",
              "cors": true
            },
            "ses": {
              "prefix": "email",
              "name": "SES",
              "cors": true
            },
            "shield": {
              "name": "Shield"
            },
            "simpledb": {
              "prefix": "sdb",
              "name": "SimpleDB"
            },
            "sms": {
              "name": "SMS"
            },
            "snowball": {
              "name": "Snowball"
            },
            "sns": {
              "name": "SNS",
              "cors": true
            },
            "sqs": {
              "name": "SQS",
              "cors": true
            },
            "ssm": {
              "name": "SSM",
              "cors": true
            },
            "storagegateway": {
              "name": "StorageGateway",
              "cors": true
            },
            "stepfunctions": {
              "prefix": "states",
              "name": "StepFunctions"
            },
            "sts": {
              "name": "STS",
              "cors": true
            },
            "support": {
              "name": "Support"
            },
            "swf": {
              "name": "SWF"
            },
            "xray": {
              "name": "XRay",
              "cors": true
            },
            "waf": {
              "name": "WAF",
              "cors": true
            },
            "wafregional": {
              "prefix": "waf-regional",
              "name": "WAFRegional"
            },
            "workdocs": {
              "name": "WorkDocs",
              "cors": true
            },
            "workspaces": {
              "name": "WorkSpaces"
            },
            "codestar": {
              "name": "CodeStar"
            },
            "lexmodelbuildingservice": {
              "prefix": "lex-models",
              "name": "LexModelBuildingService",
              "cors": true
            },
            "marketplaceentitlementservice": {
              "prefix": "entitlement.marketplace",
              "name": "MarketplaceEntitlementService"
            },
            "athena": {
              "name": "Athena",
              "cors": true
            },
            "greengrass": {
              "name": "Greengrass"
            },
            "dax": {
              "name": "DAX"
            },
            "migrationhub": {
              "prefix": "AWSMigrationHub",
              "name": "MigrationHub"
            },
            "cloudhsmv2": {
              "name": "CloudHSMV2",
              "cors": true
            },
            "glue": {
              "name": "Glue"
            },
            "mobile": {
              "name": "Mobile"
            },
            "pricing": {
              "name": "Pricing",
              "cors": true
            },
            "costexplorer": {
              "prefix": "ce",
              "name": "CostExplorer",
              "cors": true
            },
            "mediaconvert": {
              "name": "MediaConvert"
            },
            "medialive": {
              "name": "MediaLive"
            },
            "mediapackage": {
              "name": "MediaPackage"
            },
            "mediastore": {
              "name": "MediaStore"
            },
            "mediastoredata": {
              "prefix": "mediastore-data",
              "name": "MediaStoreData",
              "cors": true
            },
            "appsync": {
              "name": "AppSync"
            },
            "guardduty": {
              "name": "GuardDuty"
            },
            "mq": {
              "name": "MQ"
            },
            "comprehend": {
              "name": "Comprehend",
              "cors": true
            },
            "iotjobsdataplane": {
              "prefix": "iot-jobs-data",
              "name": "IoTJobsDataPlane"
            },
            "kinesisvideoarchivedmedia": {
              "prefix": "kinesis-video-archived-media",
              "name": "KinesisVideoArchivedMedia",
              "cors": true
            },
            "kinesisvideomedia": {
              "prefix": "kinesis-video-media",
              "name": "KinesisVideoMedia",
              "cors": true
            },
            "kinesisvideo": {
              "name": "KinesisVideo",
              "cors": true
            },
            "sagemakerruntime": {
              "prefix": "runtime.sagemaker",
              "name": "SageMakerRuntime"
            },
            "sagemaker": {
              "name": "SageMaker"
            },
            "translate": {
              "name": "Translate",
              "cors": true
            },
            "resourcegroups": {
              "prefix": "resource-groups",
              "name": "ResourceGroups",
              "cors": true
            },
            "alexaforbusiness": {
              "name": "AlexaForBusiness"
            },
            "cloud9": {
              "name": "Cloud9"
            },
            "serverlessapplicationrepository": {
              "prefix": "serverlessrepo",
              "name": "ServerlessApplicationRepository"
            },
            "servicediscovery": {
              "name": "ServiceDiscovery"
            },
            "workmail": {
              "name": "WorkMail"
            },
            "autoscalingplans": {
              "prefix": "autoscaling-plans",
              "name": "AutoScalingPlans"
            },
            "transcribeservice": {
              "prefix": "transcribe",
              "name": "TranscribeService"
            },
            "connect": {
              "name": "Connect",
              "cors": true
            },
            "acmpca": {
              "prefix": "acm-pca",
              "name": "ACMPCA"
            },
            "fms": {
              "name": "FMS"
            },
            "secretsmanager": {
              "name": "SecretsManager",
              "cors": true
            },
            "iotanalytics": {
              "name": "IoTAnalytics",
              "cors": true
            },
            "iot1clickdevicesservice": {
              "prefix": "iot1click-devices",
              "name": "IoT1ClickDevicesService"
            },
            "iot1clickprojects": {
              "prefix": "iot1click-projects",
              "name": "IoT1ClickProjects"
            },
            "pi": {
              "name": "PI"
            },
            "neptune": {
              "name": "Neptune"
            },
            "mediatailor": {
              "name": "MediaTailor"
            },
            "eks": {
              "name": "EKS"
            },
            "macie": {
              "name": "Macie"
            },
            "dlm": {
              "name": "DLM"
            },
            "signer": {
              "name": "Signer"
            },
            "chime": {
              "name": "Chime"
            },
            "pinpointemail": {
              "prefix": "pinpoint-email",
              "name": "PinpointEmail"
            },
            "ram": {
              "name": "RAM"
            },
            "route53resolver": {
              "name": "Route53Resolver"
            },
            "pinpointsmsvoice": {
              "prefix": "sms-voice",
              "name": "PinpointSMSVoice"
            },
            "quicksight": {
              "name": "QuickSight"
            },
            "rdsdataservice": {
              "prefix": "rds-data",
              "name": "RDSDataService"
            },
            "amplify": {
              "name": "Amplify"
            },
            "datasync": {
              "name": "DataSync"
            },
            "robomaker": {
              "name": "RoboMaker"
            },
            "transfer": {
              "name": "Transfer"
            },
            "globalaccelerator": {
              "name": "GlobalAccelerator"
            },
            "comprehendmedical": {
              "name": "ComprehendMedical",
              "cors": true
            },
            "kinesisanalyticsv2": {
              "name": "KinesisAnalyticsV2"
            },
            "mediaconnect": {
              "name": "MediaConnect"
            },
            "fsx": {
              "name": "FSx"
            },
            "securityhub": {
              "name": "SecurityHub"
            },
            "appmesh": {
              "name": "AppMesh",
              "versions": [
                "2018-10-01*"
              ]
            },
            "licensemanager": {
              "prefix": "license-manager",
              "name": "LicenseManager"
            },
            "kafka": {
              "name": "Kafka"
            },
            "apigatewaymanagementapi": {
              "name": "ApiGatewayManagementApi"
            },
            "apigatewayv2": {
              "name": "ApiGatewayV2"
            },
            "docdb": {
              "name": "DocDB"
            },
            "backup": {
              "name": "Backup"
            },
            "worklink": {
              "name": "WorkLink"
            },
            "textract": {
              "name": "Textract"
            },
            "managedblockchain": {
              "name": "ManagedBlockchain"
            },
            "mediapackagevod": {
              "prefix": "mediapackage-vod",
              "name": "MediaPackageVod"
            },
            "groundstation": {
              "name": "GroundStation"
            },
            "iotthingsgraph": {
              "name": "IoTThingsGraph"
            },
            "iotevents": {
              "name": "IoTEvents"
            },
            "ioteventsdata": {
              "prefix": "iotevents-data",
              "name": "IoTEventsData"
            },
            "personalize": {
              "name": "Personalize",
              "cors": true
            },
            "personalizeevents": {
              "prefix": "personalize-events",
              "name": "PersonalizeEvents",
              "cors": true
            },
            "personalizeruntime": {
              "prefix": "personalize-runtime",
              "name": "PersonalizeRuntime",
              "cors": true
            },
            "applicationinsights": {
              "prefix": "application-insights",
              "name": "ApplicationInsights"
            },
            "servicequotas": {
              "prefix": "service-quotas",
              "name": "ServiceQuotas"
            },
            "ec2instanceconnect": {
              "prefix": "ec2-instance-connect",
              "name": "EC2InstanceConnect"
            },
            "eventbridge": {
              "name": "EventBridge"
            },
            "lakeformation": {
              "name": "LakeFormation"
            },
            "forecastservice": {
              "prefix": "forecast",
              "name": "ForecastService",
              "cors": true
            },
            "forecastqueryservice": {
              "prefix": "forecastquery",
              "name": "ForecastQueryService",
              "cors": true
            },
            "qldb": {
              "name": "QLDB"
            },
            "qldbsession": {
              "prefix": "qldb-session",
              "name": "QLDBSession"
            },
            "workmailmessageflow": {
              "name": "WorkMailMessageFlow"
            },
            "codestarnotifications": {
              "prefix": "codestar-notifications",
              "name": "CodeStarNotifications"
            },
            "savingsplans": {
              "name": "SavingsPlans"
            },
            "sso": {
              "name": "SSO"
            },
            "ssooidc": {
              "prefix": "sso-oidc",
              "name": "SSOOIDC"
            },
            "marketplacecatalog": {
              "prefix": "marketplace-catalog",
              "name": "MarketplaceCatalog",
              "cors": true
            },
            "dataexchange": {
              "name": "DataExchange"
            },
            "sesv2": {
              "name": "SESV2"
            },
            "migrationhubconfig": {
              "prefix": "migrationhub-config",
              "name": "MigrationHubConfig"
            },
            "connectparticipant": {
              "name": "ConnectParticipant"
            },
            "appconfig": {
              "name": "AppConfig"
            },
            "iotsecuretunneling": {
              "name": "IoTSecureTunneling"
            },
            "wafv2": {
              "name": "WAFV2"
            },
            "elasticinference": {
              "prefix": "elastic-inference",
              "name": "ElasticInference"
            },
            "imagebuilder": {
              "name": "Imagebuilder"
            },
            "schemas": {
              "name": "Schemas"
            },
            "accessanalyzer": {
              "name": "AccessAnalyzer"
            },
            "codegurureviewer": {
              "prefix": "codeguru-reviewer",
              "name": "CodeGuruReviewer"
            },
            "codeguruprofiler": {
              "name": "CodeGuruProfiler"
            },
            "computeoptimizer": {
              "prefix": "compute-optimizer",
              "name": "ComputeOptimizer"
            },
            "frauddetector": {
              "name": "FraudDetector"
            },
            "kendra": {
              "name": "Kendra"
            },
            "networkmanager": {
              "name": "NetworkManager"
            },
            "outposts": {
              "name": "Outposts"
            },
            "augmentedairuntime": {
              "prefix": "sagemaker-a2i-runtime",
              "name": "AugmentedAIRuntime"
            },
            "ebs": {
              "name": "EBS"
            },
            "kinesisvideosignalingchannels": {
              "prefix": "kinesis-video-signaling",
              "name": "KinesisVideoSignalingChannels",
              "cors": true
            },
            "detective": {
              "name": "Detective"
            },
            "codestarconnections": {
              "prefix": "codestar-connections",
              "name": "CodeStarconnections"
            },
            "synthetics": {
              "name": "Synthetics"
            },
            "iotsitewise": {
              "name": "IoTSiteWise"
            },
            "macie2": {
              "name": "Macie2"
            },
            "codeartifact": {
              "name": "CodeArtifact"
            },
            "honeycode": {
              "name": "Honeycode"
            },
            "ivs": {
              "name": "IVS"
            },
            "braket": {
              "name": "Braket"
            },
            "identitystore": {
              "name": "IdentityStore"
            },
            "appflow": {
              "name": "Appflow"
            },
            "redshiftdata": {
              "prefix": "redshift-data",
              "name": "RedshiftData"
            },
            "ssoadmin": {
              "prefix": "sso-admin",
              "name": "SSOAdmin"
            },
            "timestreamquery": {
              "prefix": "timestream-query",
              "name": "TimestreamQuery"
            },
            "timestreamwrite": {
              "prefix": "timestream-write",
              "name": "TimestreamWrite"
            },
            "s3outposts": {
              "name": "S3Outposts"
            },
            "databrew": {
              "name": "DataBrew"
            },
            "servicecatalogappregistry": {
              "prefix": "servicecatalog-appregistry",
              "name": "ServiceCatalogAppRegistry"
            },
            "networkfirewall": {
              "prefix": "network-firewall",
              "name": "NetworkFirewall"
            },
            "mwaa": {
              "name": "MWAA"
            },
            "amplifybackend": {
              "name": "AmplifyBackend"
            },
            "appintegrations": {
              "name": "AppIntegrations"
            },
            "connectcontactlens": {
              "prefix": "connect-contact-lens",
              "name": "ConnectContactLens"
            },
            "devopsguru": {
              "prefix": "devops-guru",
              "name": "DevOpsGuru"
            },
            "ecrpublic": {
              "prefix": "ecr-public",
              "name": "ECRPUBLIC"
            },
            "lookoutvision": {
              "name": "LookoutVision"
            },
            "sagemakerfeaturestoreruntime": {
              "prefix": "sagemaker-featurestore-runtime",
              "name": "SageMakerFeatureStoreRuntime"
            },
            "customerprofiles": {
              "prefix": "customer-profiles",
              "name": "CustomerProfiles"
            },
            "auditmanager": {
              "name": "AuditManager"
            },
            "emrcontainers": {
              "prefix": "emr-containers",
              "name": "EMRcontainers"
            },
            "healthlake": {
              "name": "HealthLake"
            },
            "sagemakeredge": {
              "prefix": "sagemaker-edge",
              "name": "SagemakerEdge"
            },
            "amp": {
              "name": "Amp",
              "cors": true
            },
            "greengrassv2": {
              "name": "GreengrassV2"
            },
            "iotdeviceadvisor": {
              "name": "IotDeviceAdvisor"
            },
            "iotfleethub": {
              "name": "IoTFleetHub"
            },
            "iotwireless": {
              "name": "IoTWireless"
            },
            "location": {
              "name": "Location",
              "cors": true
            },
            "wellarchitected": {
              "name": "WellArchitected"
            },
            "lexmodelsv2": {
              "prefix": "models.lex.v2",
              "name": "LexModelsV2"
            },
            "lexruntimev2": {
              "prefix": "runtime.lex.v2",
              "name": "LexRuntimeV2",
              "cors": true
            },
            "fis": {
              "name": "Fis"
            },
            "lookoutmetrics": {
              "name": "LookoutMetrics"
            },
            "mgn": {
              "name": "Mgn"
            },
            "lookoutequipment": {
              "name": "LookoutEquipment"
            },
            "nimble": {
              "name": "Nimble"
            },
            "finspace": {
              "name": "Finspace"
            },
            "finspacedata": {
              "prefix": "finspace-data",
              "name": "Finspacedata"
            },
            "ssmcontacts": {
              "prefix": "ssm-contacts",
              "name": "SSMContacts"
            },
            "ssmincidents": {
              "prefix": "ssm-incidents",
              "name": "SSMIncidents"
            },
            "applicationcostprofiler": {
              "name": "ApplicationCostProfiler"
            },
            "apprunner": {
              "name": "AppRunner"
            },
            "proton": {
              "name": "Proton"
            },
            "route53recoverycluster": {
              "prefix": "route53-recovery-cluster",
              "name": "Route53RecoveryCluster"
            },
            "route53recoverycontrolconfig": {
              "prefix": "route53-recovery-control-config",
              "name": "Route53RecoveryControlConfig"
            },
            "route53recoveryreadiness": {
              "prefix": "route53-recovery-readiness",
              "name": "Route53RecoveryReadiness"
            },
            "chimesdkidentity": {
              "prefix": "chime-sdk-identity",
              "name": "ChimeSDKIdentity"
            },
            "chimesdkmessaging": {
              "prefix": "chime-sdk-messaging",
              "name": "ChimeSDKMessaging"
            },
            "snowdevicemanagement": {
              "prefix": "snow-device-management",
              "name": "SnowDeviceManagement"
            },
            "memorydb": {
              "name": "MemoryDB"
            },
            "opensearch": {
              "name": "OpenSearch"
            },
            "kafkaconnect": {
              "name": "KafkaConnect"
            },
            "voiceid": {
              "prefix": "voice-id",
              "name": "VoiceID"
            },
            "wisdom": {
              "name": "Wisdom"
            },
            "account": {
              "name": "Account"
            },
            "cloudcontrol": {
              "name": "CloudControl"
            },
            "grafana": {
              "name": "Grafana"
            },
            "panorama": {
              "name": "Panorama"
            },
            "chimesdkmeetings": {
              "prefix": "chime-sdk-meetings",
              "name": "ChimeSDKMeetings"
            },
            "resiliencehub": {
              "name": "Resiliencehub"
            },
            "migrationhubstrategy": {
              "name": "MigrationHubStrategy"
            },
            "appconfigdata": {
              "name": "AppConfigData"
            },
            "drs": {
              "name": "Drs"
            },
            "migrationhubrefactorspaces": {
              "prefix": "migration-hub-refactor-spaces",
              "name": "MigrationHubRefactorSpaces"
            },
            "evidently": {
              "name": "Evidently"
            },
            "inspector2": {
              "name": "Inspector2"
            },
            "rbin": {
              "name": "Rbin"
            },
            "rum": {
              "name": "RUM"
            },
            "backupgateway": {
              "prefix": "backup-gateway",
              "name": "BackupGateway"
            },
            "iottwinmaker": {
              "name": "IoTTwinMaker"
            },
            "workspacesweb": {
              "prefix": "workspaces-web",
              "name": "WorkSpacesWeb"
            },
            "amplifyuibuilder": {
              "name": "AmplifyUIBuilder"
            },
            "keyspaces": {
              "name": "Keyspaces"
            },
            "billingconductor": {
              "name": "Billingconductor"
            },
            "gamesparks": {
              "name": "GameSparks"
            },
            "pinpointsmsvoicev2": {
              "prefix": "pinpoint-sms-voice-v2",
              "name": "PinpointSMSVoiceV2"
            },
            "ivschat": {
              "name": "Ivschat"
            },
            "chimesdkmediapipelines": {
              "prefix": "chime-sdk-media-pipelines",
              "name": "ChimeSDKMediaPipelines"
            },
            "emrserverless": {
              "prefix": "emr-serverless",
              "name": "EMRServerless"
            },
            "m2": {
              "name": "M2"
            },
            "connectcampaigns": {
              "name": "ConnectCampaigns"
            },
            "redshiftserverless": {
              "prefix": "redshift-serverless",
              "name": "RedshiftServerless"
            },
            "rolesanywhere": {
              "name": "RolesAnywhere"
            },
            "licensemanagerusersubscriptions": {
              "prefix": "license-manager-user-subscriptions",
              "name": "LicenseManagerUserSubscriptions"
            },
            "backupstorage": {
              "name": "BackupStorage"
            },
            "privatenetworks": {
              "name": "PrivateNetworks"
            },
            "supportapp": {
              "prefix": "support-app",
              "name": "SupportApp"
            },
            "controltower": {
              "name": "ControlTower"
            },
            "iotfleetwise": {
              "name": "IoTFleetWise"
            },
            "migrationhuborchestrator": {
              "name": "MigrationHubOrchestrator"
            },
            "connectcases": {
              "name": "ConnectCases"
            },
            "resourceexplorer2": {
              "prefix": "resource-explorer-2",
              "name": "ResourceExplorer2"
            },
            "scheduler": {
              "name": "Scheduler"
            },
            "chimesdkvoice": {
              "prefix": "chime-sdk-voice",
              "name": "ChimeSDKVoice"
            },
            "iotroborunner": {
              "prefix": "iot-roborunner",
              "name": "IoTRoboRunner"
            },
            "ssmsap": {
              "prefix": "ssm-sap",
              "name": "SsmSap"
            },
            "oam": {
              "name": "OAM"
            },
            "arczonalshift": {
              "prefix": "arc-zonal-shift",
              "name": "ARCZonalShift"
            },
            "omics": {
              "name": "Omics"
            },
            "opensearchserverless": {
              "name": "OpenSearchServerless"
            },
            "securitylake": {
              "name": "SecurityLake"
            },
            "simspaceweaver": {
              "name": "SimSpaceWeaver"
            },
            "docdbelastic": {
              "prefix": "docdb-elastic",
              "name": "DocDBElastic"
            },
            "sagemakergeospatial": {
              "prefix": "sagemaker-geospatial",
              "name": "SageMakerGeospatial"
            },
            "codecatalyst": {
              "name": "CodeCatalyst"
            },
            "pipes": {
              "name": "Pipes"
            },
            "sagemakermetrics": {
              "prefix": "sagemaker-metrics",
              "name": "SageMakerMetrics"
            },
            "kinesisvideowebrtcstorage": {
              "prefix": "kinesis-video-webrtc-storage",
              "name": "KinesisVideoWebRTCStorage"
            },
            "licensemanagerlinuxsubscriptions": {
              "prefix": "license-manager-linux-subscriptions",
              "name": "LicenseManagerLinuxSubscriptions"
            },
            "kendraranking": {
              "prefix": "kendra-ranking",
              "name": "KendraRanking"
            },
            "cleanrooms": {
              "name": "CleanRooms"
            },
            "cloudtraildata": {
              "prefix": "cloudtrail-data",
              "name": "CloudTrailData"
            },
            "tnb": {
              "name": "Tnb"
            },
            "internetmonitor": {
              "name": "InternetMonitor"
            },
            "ivsrealtime": {
              "prefix": "ivs-realtime",
              "name": "IVSRealTime"
            },
            "vpclattice": {
              "prefix": "vpc-lattice",
              "name": "VPCLattice"
            },
            "osis": {
              "name": "OSIS"
            },
            "mediapackagev2": {
              "name": "MediaPackageV2"
            },
            "paymentcryptography": {
              "prefix": "payment-cryptography",
              "name": "PaymentCryptography"
            },
            "paymentcryptographydata": {
              "prefix": "payment-cryptography-data",
              "name": "PaymentCryptographyData"
            },
            "codegurusecurity": {
              "prefix": "codeguru-security",
              "name": "CodeGuruSecurity"
            },
            "verifiedpermissions": {
              "name": "VerifiedPermissions"
            },
            "appfabric": {
              "name": "AppFabric"
            },
            "medicalimaging": {
              "prefix": "medical-imaging",
              "name": "MedicalImaging"
            },
            "entityresolution": {
              "name": "EntityResolution"
            },
            "managedblockchainquery": {
              "prefix": "managedblockchain-query",
              "name": "ManagedBlockchainQuery"
            },
            "neptunedata": {
              "name": "Neptunedata"
            },
            "pcaconnectorad": {
              "prefix": "pca-connector-ad",
              "name": "PcaConnectorAd"
            }
          };
        }, {}], 5: [function(require2, module2, exports2) {
          module2.exports = {
            "version": "2.0",
            "metadata": {
              "apiVersion": "2011-06-15",
              "endpointPrefix": "sts",
              "globalEndpoint": "sts.amazonaws.com",
              "protocol": "query",
              "serviceAbbreviation": "AWS STS",
              "serviceFullName": "AWS Security Token Service",
              "serviceId": "STS",
              "signatureVersion": "v4",
              "uid": "sts-2011-06-15",
              "xmlNamespace": "https://sts.amazonaws.com/doc/2011-06-15/"
            },
            "operations": {
              "AssumeRole": {
                "input": {
                  "type": "structure",
                  "required": [
                    "RoleArn",
                    "RoleSessionName"
                  ],
                  "members": {
                    "RoleArn": {},
                    "RoleSessionName": {},
                    "PolicyArns": {
                      "shape": "S4"
                    },
                    "Policy": {},
                    "DurationSeconds": {
                      "type": "integer"
                    },
                    "Tags": {
                      "shape": "S8"
                    },
                    "TransitiveTagKeys": {
                      "type": "list",
                      "member": {}
                    },
                    "ExternalId": {},
                    "SerialNumber": {},
                    "TokenCode": {},
                    "SourceIdentity": {},
                    "ProvidedContexts": {
                      "type": "list",
                      "member": {
                        "type": "structure",
                        "members": {
                          "ProviderArn": {},
                          "ContextAssertion": {}
                        }
                      }
                    }
                  }
                },
                "output": {
                  "resultWrapper": "AssumeRoleResult",
                  "type": "structure",
                  "members": {
                    "Credentials": {
                      "shape": "Sl"
                    },
                    "AssumedRoleUser": {
                      "shape": "Sq"
                    },
                    "PackedPolicySize": {
                      "type": "integer"
                    },
                    "SourceIdentity": {}
                  }
                }
              },
              "AssumeRoleWithSAML": {
                "input": {
                  "type": "structure",
                  "required": [
                    "RoleArn",
                    "PrincipalArn",
                    "SAMLAssertion"
                  ],
                  "members": {
                    "RoleArn": {},
                    "PrincipalArn": {},
                    "SAMLAssertion": {
                      "type": "string",
                      "sensitive": true
                    },
                    "PolicyArns": {
                      "shape": "S4"
                    },
                    "Policy": {},
                    "DurationSeconds": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "resultWrapper": "AssumeRoleWithSAMLResult",
                  "type": "structure",
                  "members": {
                    "Credentials": {
                      "shape": "Sl"
                    },
                    "AssumedRoleUser": {
                      "shape": "Sq"
                    },
                    "PackedPolicySize": {
                      "type": "integer"
                    },
                    "Subject": {},
                    "SubjectType": {},
                    "Issuer": {},
                    "Audience": {},
                    "NameQualifier": {},
                    "SourceIdentity": {}
                  }
                }
              },
              "AssumeRoleWithWebIdentity": {
                "input": {
                  "type": "structure",
                  "required": [
                    "RoleArn",
                    "RoleSessionName",
                    "WebIdentityToken"
                  ],
                  "members": {
                    "RoleArn": {},
                    "RoleSessionName": {},
                    "WebIdentityToken": {
                      "type": "string",
                      "sensitive": true
                    },
                    "ProviderId": {},
                    "PolicyArns": {
                      "shape": "S4"
                    },
                    "Policy": {},
                    "DurationSeconds": {
                      "type": "integer"
                    }
                  }
                },
                "output": {
                  "resultWrapper": "AssumeRoleWithWebIdentityResult",
                  "type": "structure",
                  "members": {
                    "Credentials": {
                      "shape": "Sl"
                    },
                    "SubjectFromWebIdentityToken": {},
                    "AssumedRoleUser": {
                      "shape": "Sq"
                    },
                    "PackedPolicySize": {
                      "type": "integer"
                    },
                    "Provider": {},
                    "Audience": {},
                    "SourceIdentity": {}
                  }
                }
              },
              "DecodeAuthorizationMessage": {
                "input": {
                  "type": "structure",
                  "required": [
                    "EncodedMessage"
                  ],
                  "members": {
                    "EncodedMessage": {}
                  }
                },
                "output": {
                  "resultWrapper": "DecodeAuthorizationMessageResult",
                  "type": "structure",
                  "members": {
                    "DecodedMessage": {}
                  }
                }
              },
              "GetAccessKeyInfo": {
                "input": {
                  "type": "structure",
                  "required": [
                    "AccessKeyId"
                  ],
                  "members": {
                    "AccessKeyId": {}
                  }
                },
                "output": {
                  "resultWrapper": "GetAccessKeyInfoResult",
                  "type": "structure",
                  "members": {
                    "Account": {}
                  }
                }
              },
              "GetCallerIdentity": {
                "input": {
                  "type": "structure",
                  "members": {}
                },
                "output": {
                  "resultWrapper": "GetCallerIdentityResult",
                  "type": "structure",
                  "members": {
                    "UserId": {},
                    "Account": {},
                    "Arn": {}
                  }
                }
              },
              "GetFederationToken": {
                "input": {
                  "type": "structure",
                  "required": [
                    "Name"
                  ],
                  "members": {
                    "Name": {},
                    "Policy": {},
                    "PolicyArns": {
                      "shape": "S4"
                    },
                    "DurationSeconds": {
                      "type": "integer"
                    },
                    "Tags": {
                      "shape": "S8"
                    }
                  }
                },
                "output": {
                  "resultWrapper": "GetFederationTokenResult",
                  "type": "structure",
                  "members": {
                    "Credentials": {
                      "shape": "Sl"
                    },
                    "FederatedUser": {
                      "type": "structure",
                      "required": [
                        "FederatedUserId",
                        "Arn"
                      ],
                      "members": {
                        "FederatedUserId": {},
                        "Arn": {}
                      }
                    },
                    "PackedPolicySize": {
                      "type": "integer"
                    }
                  }
                }
              },
              "GetSessionToken": {
                "input": {
                  "type": "structure",
                  "members": {
                    "DurationSeconds": {
                      "type": "integer"
                    },
                    "SerialNumber": {},
                    "TokenCode": {}
                  }
                },
                "output": {
                  "resultWrapper": "GetSessionTokenResult",
                  "type": "structure",
                  "members": {
                    "Credentials": {
                      "shape": "Sl"
                    }
                  }
                }
              }
            },
            "shapes": {
              "S4": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "members": {
                    "arn": {}
                  }
                }
              },
              "S8": {
                "type": "list",
                "member": {
                  "type": "structure",
                  "required": [
                    "Key",
                    "Value"
                  ],
                  "members": {
                    "Key": {},
                    "Value": {}
                  }
                }
              },
              "Sl": {
                "type": "structure",
                "required": [
                  "AccessKeyId",
                  "SecretAccessKey",
                  "SessionToken",
                  "Expiration"
                ],
                "members": {
                  "AccessKeyId": {},
                  "SecretAccessKey": {
                    "type": "string",
                    "sensitive": true
                  },
                  "SessionToken": {},
                  "Expiration": {
                    "type": "timestamp"
                  }
                }
              },
              "Sq": {
                "type": "structure",
                "required": [
                  "AssumedRoleId",
                  "Arn"
                ],
                "members": {
                  "AssumedRoleId": {},
                  "Arn": {}
                }
              }
            }
          };
        }, {}], 6: [function(require2, module2, exports2) {
          module2.exports = {
            "pagination": {}
          };
        }, {}], 7: [function(require2, module2, exports2) {
          require2("../lib/node_loader");
          var AWS2 = require2("../lib/core");
          var Service = AWS2.Service;
          var apiLoader = AWS2.apiLoader;
          apiLoader.services["cognitoidentity"] = {};
          AWS2.CognitoIdentity = Service.defineService("cognitoidentity", ["2014-06-30"]);
          Object.defineProperty(apiLoader.services["cognitoidentity"], "2014-06-30", {
            get: function get() {
              var model = require2("../apis/cognito-identity-2014-06-30.min.json");
              model.paginators = require2("../apis/cognito-identity-2014-06-30.paginators.json").pagination;
              return model;
            },
            enumerable: true,
            configurable: true
          });
          module2.exports = AWS2.CognitoIdentity;
        }, { "../apis/cognito-identity-2014-06-30.min.json": 1, "../apis/cognito-identity-2014-06-30.paginators.json": 2, "../lib/core": 19, "../lib/node_loader": 16 }], 8: [function(require2, module2, exports2) {
          require2("../lib/node_loader");
          var AWS2 = require2("../lib/core");
          var Service = AWS2.Service;
          var apiLoader = AWS2.apiLoader;
          apiLoader.services["sts"] = {};
          AWS2.STS = Service.defineService("sts", ["2011-06-15"]);
          require2("../lib/services/sts");
          Object.defineProperty(apiLoader.services["sts"], "2011-06-15", {
            get: function get() {
              var model = require2("../apis/sts-2011-06-15.min.json");
              model.paginators = require2("../apis/sts-2011-06-15.paginators.json").pagination;
              return model;
            },
            enumerable: true,
            configurable: true
          });
          module2.exports = AWS2.STS;
        }, { "../apis/sts-2011-06-15.min.json": 5, "../apis/sts-2011-06-15.paginators.json": 6, "../lib/core": 19, "../lib/node_loader": 16, "../lib/services/sts": 63 }], 9: [function(require2, module2, exports2) {
          function apiLoader(svc, version) {
            if (!apiLoader.services.hasOwnProperty(svc)) {
              throw new Error("InvalidService: Failed to load api for " + svc);
            }
            return apiLoader.services[svc][version];
          }
          apiLoader.services = {};
          module2.exports = apiLoader;
        }, {}], 10: [function(require2, module2, exports2) {
          var Hmac = require2("./browserHmac");
          var Md5 = require2("./browserMd5");
          var Sha1 = require2("./browserSha1");
          var Sha256 = require2("./browserSha256");
          module2.exports = exports2 = {
            createHash: function createHash(alg) {
              alg = alg.toLowerCase();
              if (alg === "md5") {
                return new Md5();
              } else if (alg === "sha256") {
                return new Sha256();
              } else if (alg === "sha1") {
                return new Sha1();
              }
              throw new Error("Hash algorithm " + alg + " is not supported in the browser SDK");
            },
            createHmac: function createHmac(alg, key) {
              alg = alg.toLowerCase();
              if (alg === "md5") {
                return new Hmac(Md5, key);
              } else if (alg === "sha256") {
                return new Hmac(Sha256, key);
              } else if (alg === "sha1") {
                return new Hmac(Sha1, key);
              }
              throw new Error("HMAC algorithm " + alg + " is not supported in the browser SDK");
            },
            createSign: function() {
              throw new Error("createSign is not implemented in the browser");
            }
          };
        }, { "./browserHmac": 12, "./browserMd5": 13, "./browserSha1": 14, "./browserSha256": 15 }], 11: [function(require2, module2, exports2) {
          var Buffer = require2("buffer/").Buffer;
          if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "undefined") {
            ArrayBuffer.isView = function(arg) {
              return viewStrings.indexOf(Object.prototype.toString.call(arg)) > -1;
            };
          }
          var viewStrings = [
            "[object Int8Array]",
            "[object Uint8Array]",
            "[object Uint8ClampedArray]",
            "[object Int16Array]",
            "[object Uint16Array]",
            "[object Int32Array]",
            "[object Uint32Array]",
            "[object Float32Array]",
            "[object Float64Array]",
            "[object DataView]"
          ];
          function isEmptyData(data) {
            if (typeof data === "string") {
              return data.length === 0;
            }
            return data.byteLength === 0;
          }
          function convertToBuffer(data) {
            if (typeof data === "string") {
              data = new Buffer(data, "utf8");
            }
            if (ArrayBuffer.isView(data)) {
              return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
            }
            return new Uint8Array(data);
          }
          module2.exports = exports2 = {
            isEmptyData,
            convertToBuffer
          };
        }, { "buffer/": 86 }], 12: [function(require2, module2, exports2) {
          var hashUtils = require2("./browserHashUtils");
          function Hmac(hashCtor, secret) {
            this.hash = new hashCtor();
            this.outer = new hashCtor();
            var inner = bufferFromSecret(hashCtor, secret);
            var outer = new Uint8Array(hashCtor.BLOCK_SIZE);
            outer.set(inner);
            for (var i = 0; i < hashCtor.BLOCK_SIZE; i++) {
              inner[i] ^= 54;
              outer[i] ^= 92;
            }
            this.hash.update(inner);
            this.outer.update(outer);
            for (var i = 0; i < inner.byteLength; i++) {
              inner[i] = 0;
            }
          }
          module2.exports = exports2 = Hmac;
          Hmac.prototype.update = function(toHash) {
            if (hashUtils.isEmptyData(toHash) || this.error) {
              return this;
            }
            try {
              this.hash.update(hashUtils.convertToBuffer(toHash));
            } catch (e) {
              this.error = e;
            }
            return this;
          };
          Hmac.prototype.digest = function(encoding) {
            if (!this.outer.finished) {
              this.outer.update(this.hash.digest());
            }
            return this.outer.digest(encoding);
          };
          function bufferFromSecret(hashCtor, secret) {
            var input = hashUtils.convertToBuffer(secret);
            if (input.byteLength > hashCtor.BLOCK_SIZE) {
              var bufferHash = new hashCtor();
              bufferHash.update(input);
              input = bufferHash.digest();
            }
            var buffer = new Uint8Array(hashCtor.BLOCK_SIZE);
            buffer.set(input);
            return buffer;
          }
        }, { "./browserHashUtils": 11 }], 13: [function(require2, module2, exports2) {
          var hashUtils = require2("./browserHashUtils");
          var Buffer = require2("buffer/").Buffer;
          var BLOCK_SIZE = 64;
          var DIGEST_LENGTH = 16;
          var INIT = [
            1732584193,
            4023233417,
            2562383102,
            271733878
          ];
          function Md5() {
            this.state = [
              1732584193,
              4023233417,
              2562383102,
              271733878
            ];
            this.buffer = new DataView(new ArrayBuffer(BLOCK_SIZE));
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
          }
          module2.exports = exports2 = Md5;
          Md5.BLOCK_SIZE = BLOCK_SIZE;
          Md5.prototype.update = function(sourceData) {
            if (hashUtils.isEmptyData(sourceData)) {
              return this;
            } else if (this.finished) {
              throw new Error("Attempted to update an already finished hash.");
            }
            var data = hashUtils.convertToBuffer(sourceData);
            var position = 0;
            var byteLength = data.byteLength;
            this.bytesHashed += byteLength;
            while (byteLength > 0) {
              this.buffer.setUint8(this.bufferLength++, data[position++]);
              byteLength--;
              if (this.bufferLength === BLOCK_SIZE) {
                this.hashBuffer();
                this.bufferLength = 0;
              }
            }
            return this;
          };
          Md5.prototype.digest = function(encoding) {
            if (!this.finished) {
              var _a = this, buffer = _a.buffer, undecoratedLength = _a.bufferLength, bytesHashed = _a.bytesHashed;
              var bitsHashed = bytesHashed * 8;
              buffer.setUint8(this.bufferLength++, 128);
              if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
                for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                  buffer.setUint8(i, 0);
                }
                this.hashBuffer();
                this.bufferLength = 0;
              }
              for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
                buffer.setUint8(i, 0);
              }
              buffer.setUint32(BLOCK_SIZE - 8, bitsHashed >>> 0, true);
              buffer.setUint32(BLOCK_SIZE - 4, Math.floor(bitsHashed / 4294967296), true);
              this.hashBuffer();
              this.finished = true;
            }
            var out = new DataView(new ArrayBuffer(DIGEST_LENGTH));
            for (var i = 0; i < 4; i++) {
              out.setUint32(i * 4, this.state[i], true);
            }
            var buff = new Buffer(out.buffer, out.byteOffset, out.byteLength);
            return encoding ? buff.toString(encoding) : buff;
          };
          Md5.prototype.hashBuffer = function() {
            var _a = this, buffer = _a.buffer, state = _a.state;
            var a = state[0], b = state[1], c = state[2], d = state[3];
            a = ff(a, b, c, d, buffer.getUint32(0, true), 7, 3614090360);
            d = ff(d, a, b, c, buffer.getUint32(4, true), 12, 3905402710);
            c = ff(c, d, a, b, buffer.getUint32(8, true), 17, 606105819);
            b = ff(b, c, d, a, buffer.getUint32(12, true), 22, 3250441966);
            a = ff(a, b, c, d, buffer.getUint32(16, true), 7, 4118548399);
            d = ff(d, a, b, c, buffer.getUint32(20, true), 12, 1200080426);
            c = ff(c, d, a, b, buffer.getUint32(24, true), 17, 2821735955);
            b = ff(b, c, d, a, buffer.getUint32(28, true), 22, 4249261313);
            a = ff(a, b, c, d, buffer.getUint32(32, true), 7, 1770035416);
            d = ff(d, a, b, c, buffer.getUint32(36, true), 12, 2336552879);
            c = ff(c, d, a, b, buffer.getUint32(40, true), 17, 4294925233);
            b = ff(b, c, d, a, buffer.getUint32(44, true), 22, 2304563134);
            a = ff(a, b, c, d, buffer.getUint32(48, true), 7, 1804603682);
            d = ff(d, a, b, c, buffer.getUint32(52, true), 12, 4254626195);
            c = ff(c, d, a, b, buffer.getUint32(56, true), 17, 2792965006);
            b = ff(b, c, d, a, buffer.getUint32(60, true), 22, 1236535329);
            a = gg(a, b, c, d, buffer.getUint32(4, true), 5, 4129170786);
            d = gg(d, a, b, c, buffer.getUint32(24, true), 9, 3225465664);
            c = gg(c, d, a, b, buffer.getUint32(44, true), 14, 643717713);
            b = gg(b, c, d, a, buffer.getUint32(0, true), 20, 3921069994);
            a = gg(a, b, c, d, buffer.getUint32(20, true), 5, 3593408605);
            d = gg(d, a, b, c, buffer.getUint32(40, true), 9, 38016083);
            c = gg(c, d, a, b, buffer.getUint32(60, true), 14, 3634488961);
            b = gg(b, c, d, a, buffer.getUint32(16, true), 20, 3889429448);
            a = gg(a, b, c, d, buffer.getUint32(36, true), 5, 568446438);
            d = gg(d, a, b, c, buffer.getUint32(56, true), 9, 3275163606);
            c = gg(c, d, a, b, buffer.getUint32(12, true), 14, 4107603335);
            b = gg(b, c, d, a, buffer.getUint32(32, true), 20, 1163531501);
            a = gg(a, b, c, d, buffer.getUint32(52, true), 5, 2850285829);
            d = gg(d, a, b, c, buffer.getUint32(8, true), 9, 4243563512);
            c = gg(c, d, a, b, buffer.getUint32(28, true), 14, 1735328473);
            b = gg(b, c, d, a, buffer.getUint32(48, true), 20, 2368359562);
            a = hh(a, b, c, d, buffer.getUint32(20, true), 4, 4294588738);
            d = hh(d, a, b, c, buffer.getUint32(32, true), 11, 2272392833);
            c = hh(c, d, a, b, buffer.getUint32(44, true), 16, 1839030562);
            b = hh(b, c, d, a, buffer.getUint32(56, true), 23, 4259657740);
            a = hh(a, b, c, d, buffer.getUint32(4, true), 4, 2763975236);
            d = hh(d, a, b, c, buffer.getUint32(16, true), 11, 1272893353);
            c = hh(c, d, a, b, buffer.getUint32(28, true), 16, 4139469664);
            b = hh(b, c, d, a, buffer.getUint32(40, true), 23, 3200236656);
            a = hh(a, b, c, d, buffer.getUint32(52, true), 4, 681279174);
            d = hh(d, a, b, c, buffer.getUint32(0, true), 11, 3936430074);
            c = hh(c, d, a, b, buffer.getUint32(12, true), 16, 3572445317);
            b = hh(b, c, d, a, buffer.getUint32(24, true), 23, 76029189);
            a = hh(a, b, c, d, buffer.getUint32(36, true), 4, 3654602809);
            d = hh(d, a, b, c, buffer.getUint32(48, true), 11, 3873151461);
            c = hh(c, d, a, b, buffer.getUint32(60, true), 16, 530742520);
            b = hh(b, c, d, a, buffer.getUint32(8, true), 23, 3299628645);
            a = ii(a, b, c, d, buffer.getUint32(0, true), 6, 4096336452);
            d = ii(d, a, b, c, buffer.getUint32(28, true), 10, 1126891415);
            c = ii(c, d, a, b, buffer.getUint32(56, true), 15, 2878612391);
            b = ii(b, c, d, a, buffer.getUint32(20, true), 21, 4237533241);
            a = ii(a, b, c, d, buffer.getUint32(48, true), 6, 1700485571);
            d = ii(d, a, b, c, buffer.getUint32(12, true), 10, 2399980690);
            c = ii(c, d, a, b, buffer.getUint32(40, true), 15, 4293915773);
            b = ii(b, c, d, a, buffer.getUint32(4, true), 21, 2240044497);
            a = ii(a, b, c, d, buffer.getUint32(32, true), 6, 1873313359);
            d = ii(d, a, b, c, buffer.getUint32(60, true), 10, 4264355552);
            c = ii(c, d, a, b, buffer.getUint32(24, true), 15, 2734768916);
            b = ii(b, c, d, a, buffer.getUint32(52, true), 21, 1309151649);
            a = ii(a, b, c, d, buffer.getUint32(16, true), 6, 4149444226);
            d = ii(d, a, b, c, buffer.getUint32(44, true), 10, 3174756917);
            c = ii(c, d, a, b, buffer.getUint32(8, true), 15, 718787259);
            b = ii(b, c, d, a, buffer.getUint32(36, true), 21, 3951481745);
            state[0] = a + state[0] & 4294967295;
            state[1] = b + state[1] & 4294967295;
            state[2] = c + state[2] & 4294967295;
            state[3] = d + state[3] & 4294967295;
          };
          function cmn(q, a, b, x, s, t) {
            a = (a + q & 4294967295) + (x + t & 4294967295) & 4294967295;
            return (a << s | a >>> 32 - s) + b & 4294967295;
          }
          function ff(a, b, c, d, x, s, t) {
            return cmn(b & c | ~b & d, a, b, x, s, t);
          }
          function gg(a, b, c, d, x, s, t) {
            return cmn(b & d | c & ~d, a, b, x, s, t);
          }
          function hh(a, b, c, d, x, s, t) {
            return cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function ii(a, b, c, d, x, s, t) {
            return cmn(c ^ (b | ~d), a, b, x, s, t);
          }
        }, { "./browserHashUtils": 11, "buffer/": 86 }], 14: [function(require2, module2, exports2) {
          var Buffer = require2("buffer/").Buffer;
          var hashUtils = require2("./browserHashUtils");
          var BLOCK_SIZE = 64;
          var DIGEST_LENGTH = 20;
          var KEY = new Uint32Array([
            1518500249,
            1859775393,
            2400959708 | 0,
            3395469782 | 0
          ]);
          var INIT = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
          ];
          var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
          function Sha1() {
            this.h0 = 1732584193;
            this.h1 = 4023233417;
            this.h2 = 2562383102;
            this.h3 = 271733878;
            this.h4 = 3285377520;
            this.block = new Uint32Array(80);
            this.offset = 0;
            this.shift = 24;
            this.totalLength = 0;
          }
          module2.exports = exports2 = Sha1;
          Sha1.BLOCK_SIZE = BLOCK_SIZE;
          Sha1.prototype.update = function(data) {
            if (this.finished) {
              throw new Error("Attempted to update an already finished hash.");
            }
            if (hashUtils.isEmptyData(data)) {
              return this;
            }
            data = hashUtils.convertToBuffer(data);
            var length = data.length;
            this.totalLength += length * 8;
            for (var i = 0; i < length; i++) {
              this.write(data[i]);
            }
            return this;
          };
          Sha1.prototype.write = function write(byte) {
            this.block[this.offset] |= (byte & 255) << this.shift;
            if (this.shift) {
              this.shift -= 8;
            } else {
              this.offset++;
              this.shift = 24;
            }
            if (this.offset === 16)
              this.processBlock();
          };
          Sha1.prototype.digest = function(encoding) {
            this.write(128);
            if (this.offset > 14 || this.offset === 14 && this.shift < 24) {
              this.processBlock();
            }
            this.offset = 14;
            this.shift = 24;
            this.write(0);
            this.write(0);
            this.write(this.totalLength > 1099511627775 ? this.totalLength / 1099511627776 : 0);
            this.write(this.totalLength > 4294967295 ? this.totalLength / 4294967296 : 0);
            for (var s = 24; s >= 0; s -= 8) {
              this.write(this.totalLength >> s);
            }
            var out = new Buffer(DIGEST_LENGTH);
            var outView = new DataView(out.buffer);
            outView.setUint32(0, this.h0, false);
            outView.setUint32(4, this.h1, false);
            outView.setUint32(8, this.h2, false);
            outView.setUint32(12, this.h3, false);
            outView.setUint32(16, this.h4, false);
            return encoding ? out.toString(encoding) : out;
          };
          Sha1.prototype.processBlock = function processBlock() {
            for (var i = 16; i < 80; i++) {
              var w = this.block[i - 3] ^ this.block[i - 8] ^ this.block[i - 14] ^ this.block[i - 16];
              this.block[i] = w << 1 | w >>> 31;
            }
            var a = this.h0;
            var b = this.h1;
            var c = this.h2;
            var d = this.h3;
            var e = this.h4;
            var f, k;
            for (i = 0; i < 80; i++) {
              if (i < 20) {
                f = d ^ b & (c ^ d);
                k = 1518500249;
              } else if (i < 40) {
                f = b ^ c ^ d;
                k = 1859775393;
              } else if (i < 60) {
                f = b & c | d & (b | c);
                k = 2400959708;
              } else {
                f = b ^ c ^ d;
                k = 3395469782;
              }
              var temp = (a << 5 | a >>> 27) + f + e + k + (this.block[i] | 0);
              e = d;
              d = c;
              c = b << 30 | b >>> 2;
              b = a;
              a = temp;
            }
            this.h0 = this.h0 + a | 0;
            this.h1 = this.h1 + b | 0;
            this.h2 = this.h2 + c | 0;
            this.h3 = this.h3 + d | 0;
            this.h4 = this.h4 + e | 0;
            this.offset = 0;
            for (i = 0; i < 16; i++) {
              this.block[i] = 0;
            }
          };
        }, { "./browserHashUtils": 11, "buffer/": 86 }], 15: [function(require2, module2, exports2) {
          var Buffer = require2("buffer/").Buffer;
          var hashUtils = require2("./browserHashUtils");
          var BLOCK_SIZE = 64;
          var DIGEST_LENGTH = 32;
          var KEY = new Uint32Array([
            1116352408,
            1899447441,
            3049323471,
            3921009573,
            961987163,
            1508970993,
            2453635748,
            2870763221,
            3624381080,
            310598401,
            607225278,
            1426881987,
            1925078388,
            2162078206,
            2614888103,
            3248222580,
            3835390401,
            4022224774,
            264347078,
            604807628,
            770255983,
            1249150122,
            1555081692,
            1996064986,
            2554220882,
            2821834349,
            2952996808,
            3210313671,
            3336571891,
            3584528711,
            113926993,
            338241895,
            666307205,
            773529912,
            1294757372,
            1396182291,
            1695183700,
            1986661051,
            2177026350,
            2456956037,
            2730485921,
            2820302411,
            3259730800,
            3345764771,
            3516065817,
            3600352804,
            4094571909,
            275423344,
            430227734,
            506948616,
            659060556,
            883997877,
            958139571,
            1322822218,
            1537002063,
            1747873779,
            1955562222,
            2024104815,
            2227730452,
            2361852424,
            2428436474,
            2756734187,
            3204031479,
            3329325298
          ]);
          var INIT = [
            1779033703,
            3144134277,
            1013904242,
            2773480762,
            1359893119,
            2600822924,
            528734635,
            1541459225
          ];
          var MAX_HASHABLE_LENGTH = Math.pow(2, 53) - 1;
          function Sha256() {
            this.state = [
              1779033703,
              3144134277,
              1013904242,
              2773480762,
              1359893119,
              2600822924,
              528734635,
              1541459225
            ];
            this.temp = new Int32Array(64);
            this.buffer = new Uint8Array(64);
            this.bufferLength = 0;
            this.bytesHashed = 0;
            this.finished = false;
          }
          module2.exports = exports2 = Sha256;
          Sha256.BLOCK_SIZE = BLOCK_SIZE;
          Sha256.prototype.update = function(data) {
            if (this.finished) {
              throw new Error("Attempted to update an already finished hash.");
            }
            if (hashUtils.isEmptyData(data)) {
              return this;
            }
            data = hashUtils.convertToBuffer(data);
            var position = 0;
            var byteLength = data.byteLength;
            this.bytesHashed += byteLength;
            if (this.bytesHashed * 8 > MAX_HASHABLE_LENGTH) {
              throw new Error("Cannot hash more than 2^53 - 1 bits");
            }
            while (byteLength > 0) {
              this.buffer[this.bufferLength++] = data[position++];
              byteLength--;
              if (this.bufferLength === BLOCK_SIZE) {
                this.hashBuffer();
                this.bufferLength = 0;
              }
            }
            return this;
          };
          Sha256.prototype.digest = function(encoding) {
            if (!this.finished) {
              var bitsHashed = this.bytesHashed * 8;
              var bufferView = new DataView(this.buffer.buffer, this.buffer.byteOffset, this.buffer.byteLength);
              var undecoratedLength = this.bufferLength;
              bufferView.setUint8(this.bufferLength++, 128);
              if (undecoratedLength % BLOCK_SIZE >= BLOCK_SIZE - 8) {
                for (var i = this.bufferLength; i < BLOCK_SIZE; i++) {
                  bufferView.setUint8(i, 0);
                }
                this.hashBuffer();
                this.bufferLength = 0;
              }
              for (var i = this.bufferLength; i < BLOCK_SIZE - 8; i++) {
                bufferView.setUint8(i, 0);
              }
              bufferView.setUint32(BLOCK_SIZE - 8, Math.floor(bitsHashed / 4294967296), true);
              bufferView.setUint32(BLOCK_SIZE - 4, bitsHashed);
              this.hashBuffer();
              this.finished = true;
            }
            var out = new Buffer(DIGEST_LENGTH);
            for (var i = 0; i < 8; i++) {
              out[i * 4] = this.state[i] >>> 24 & 255;
              out[i * 4 + 1] = this.state[i] >>> 16 & 255;
              out[i * 4 + 2] = this.state[i] >>> 8 & 255;
              out[i * 4 + 3] = this.state[i] >>> 0 & 255;
            }
            return encoding ? out.toString(encoding) : out;
          };
          Sha256.prototype.hashBuffer = function() {
            var _a = this, buffer = _a.buffer, state = _a.state;
            var state0 = state[0], state1 = state[1], state2 = state[2], state3 = state[3], state4 = state[4], state5 = state[5], state6 = state[6], state7 = state[7];
            for (var i = 0; i < BLOCK_SIZE; i++) {
              if (i < 16) {
                this.temp[i] = (buffer[i * 4] & 255) << 24 | (buffer[i * 4 + 1] & 255) << 16 | (buffer[i * 4 + 2] & 255) << 8 | buffer[i * 4 + 3] & 255;
              } else {
                var u = this.temp[i - 2];
                var t1_1 = (u >>> 17 | u << 15) ^ (u >>> 19 | u << 13) ^ u >>> 10;
                u = this.temp[i - 15];
                var t2_1 = (u >>> 7 | u << 25) ^ (u >>> 18 | u << 14) ^ u >>> 3;
                this.temp[i] = (t1_1 + this.temp[i - 7] | 0) + (t2_1 + this.temp[i - 16] | 0);
              }
              var t1 = (((state4 >>> 6 | state4 << 26) ^ (state4 >>> 11 | state4 << 21) ^ (state4 >>> 25 | state4 << 7)) + (state4 & state5 ^ ~state4 & state6) | 0) + (state7 + (KEY[i] + this.temp[i] | 0) | 0) | 0;
              var t2 = ((state0 >>> 2 | state0 << 30) ^ (state0 >>> 13 | state0 << 19) ^ (state0 >>> 22 | state0 << 10)) + (state0 & state1 ^ state0 & state2 ^ state1 & state2) | 0;
              state7 = state6;
              state6 = state5;
              state5 = state4;
              state4 = state3 + t1 | 0;
              state3 = state2;
              state2 = state1;
              state1 = state0;
              state0 = t1 + t2 | 0;
            }
            state[0] += state0;
            state[1] += state1;
            state[2] += state2;
            state[3] += state3;
            state[4] += state4;
            state[5] += state5;
            state[6] += state6;
            state[7] += state7;
          };
        }, { "./browserHashUtils": 11, "buffer/": 86 }], 16: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var util = require2("./util");
              util.crypto.lib = require2("./browserCryptoLib");
              util.Buffer = require2("buffer/").Buffer;
              util.url = require2("url/");
              util.querystring = require2("querystring/");
              util.realClock = require2("./realclock/browserClock");
              util.environment = "js";
              util.createEventStream = require2("./event-stream/buffered-create-event-stream").createEventStream;
              util.isBrowser = function() {
                return true;
              };
              util.isNode = function() {
                return false;
              };
              var AWS2 = require2("./core");
              module2.exports = AWS2;
              require2("./credentials");
              require2("./credentials/credential_provider_chain");
              require2("./credentials/temporary_credentials");
              require2("./credentials/chainable_temporary_credentials");
              require2("./credentials/web_identity_credentials");
              require2("./credentials/cognito_identity_credentials");
              require2("./credentials/saml_credentials");
              AWS2.XML.Parser = require2("./xml/browser_parser");
              require2("./http/xhr");
              if (typeof process2 === "undefined") {
                var process2 = {
                  browser: true
                };
              }
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./browserCryptoLib": 10, "./core": 19, "./credentials": 20, "./credentials/chainable_temporary_credentials": 21, "./credentials/cognito_identity_credentials": 22, "./credentials/credential_provider_chain": 23, "./credentials/saml_credentials": 24, "./credentials/temporary_credentials": 25, "./credentials/web_identity_credentials": 26, "./event-stream/buffered-create-event-stream": 28, "./http/xhr": 36, "./realclock/browserClock": 54, "./util": 74, "./xml/browser_parser": 75, "_process": 91, "buffer/": 86, "querystring/": 98, "url/": 100 }], 17: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          require2("./credentials");
          require2("./credentials/credential_provider_chain");
          var PromisesDependency;
          AWS2.Config = AWS2.util.inherit({
            /**
             * @!endgroup
             */
            /**
             * Creates a new configuration object. This is the object that passes
             * option data along to service requests, including credentials, security,
             * region information, and some service specific settings.
             *
             * @example Creating a new configuration object with credentials and region
             *   var config = new AWS.Config({
             *     accessKeyId: 'AKID', secretAccessKey: 'SECRET', region: 'us-west-2'
             *   });
             * @option options accessKeyId [String] your AWS access key ID.
             * @option options secretAccessKey [String] your AWS secret access key.
             * @option options sessionToken [AWS.Credentials] the optional AWS
             *   session token to sign requests with.
             * @option options credentials [AWS.Credentials] the AWS credentials
             *   to sign requests with. You can either specify this object, or
             *   specify the accessKeyId and secretAccessKey options directly.
             * @option options credentialProvider [AWS.CredentialProviderChain] the
             *   provider chain used to resolve credentials if no static `credentials`
             *   property is set.
             * @option options region [String] the region to send service requests to.
             *   See {region} for more information.
             * @option options maxRetries [Integer] the maximum amount of retries to
             *   attempt with a request. See {maxRetries} for more information.
             * @option options maxRedirects [Integer] the maximum amount of redirects to
             *   follow with a request. See {maxRedirects} for more information.
             * @option options sslEnabled [Boolean] whether to enable SSL for
             *   requests.
             * @option options paramValidation [Boolean|map] whether input parameters
             *   should be validated against the operation description before sending
             *   the request. Defaults to true. Pass a map to enable any of the
             *   following specific validation features:
             *
             *   * **min** [Boolean] &mdash; Validates that a value meets the min
             *     constraint. This is enabled by default when paramValidation is set
             *     to `true`.
             *   * **max** [Boolean] &mdash; Validates that a value meets the max
             *     constraint.
             *   * **pattern** [Boolean] &mdash; Validates that a string value matches a
             *     regular expression.
             *   * **enum** [Boolean] &mdash; Validates that a string value matches one
             *     of the allowable enum values.
             * @option options computeChecksums [Boolean] whether to compute checksums
             *   for payload bodies when the service accepts it (currently supported
             *   in S3 only)
             * @option options convertResponseTypes [Boolean] whether types are converted
             *     when parsing response data. Currently only supported for JSON based
             *     services. Turning this off may improve performance on large response
             *     payloads. Defaults to `true`.
             * @option options correctClockSkew [Boolean] whether to apply a clock skew
             *     correction and retry requests that fail because of an skewed client
             *     clock. Defaults to `false`.
             * @option options s3ForcePathStyle [Boolean] whether to force path
             *   style URLs for S3 objects.
             * @option options s3BucketEndpoint [Boolean] whether the provided endpoint
             *   addresses an individual bucket (false if it addresses the root API
             *   endpoint). Note that setting this configuration option requires an
             *   `endpoint` to be provided explicitly to the service constructor.
             * @option options s3DisableBodySigning [Boolean] whether S3 body signing
             *   should be disabled when using signature version `v4`. Body signing
             *   can only be disabled when using https. Defaults to `true`.
             * @option options s3UsEast1RegionalEndpoint ['legacy'|'regional'] when region
             *   is set to 'us-east-1', whether to send s3 request to global endpoints or
             *   'us-east-1' regional endpoints. This config is only applicable to S3 client.
             *   Defaults to `legacy`
             * @option options s3UseArnRegion [Boolean] whether to override the request region
             *   with the region inferred from requested resource's ARN. Only available for S3 buckets
             *   Defaults to `true`
             *
             * @option options retryDelayOptions [map] A set of options to configure
             *   the retry delay on retryable errors. Currently supported options are:
             *
             *   * **base** [Integer] &mdash; The base number of milliseconds to use in the
             *     exponential backoff for operation retries. Defaults to 100 ms for all
             *     services except DynamoDB, where it defaults to 50ms.
             *   * **customBackoff ** [function] &mdash; A custom function that accepts a
             *     retry count and error and returns the amount of time to delay in
             *     milliseconds. If the result is a non-zero negative value, no further
             *     retry attempts will be made. The `base` option will be ignored if this
             *     option is supplied. The function is only called for retryable errors.
             * @option options httpOptions [map] A set of options to pass to the low-level
             *   HTTP request. Currently supported options are:
             *
             *   * **proxy** [String] &mdash; the URL to proxy requests through
             *   * **agent** [http.Agent, https.Agent] &mdash; the Agent object to perform
             *     HTTP requests with. Used for connection pooling. Defaults to the global
             *     agent (`http.globalAgent`) for non-SSL connections. Note that for
             *     SSL connections, a special Agent object is used in order to enable
             *     peer certificate verification. This feature is only available in the
             *     Node.js environment.
             *   * **connectTimeout** [Integer] &mdash; Sets the socket to timeout after
             *     failing to establish a connection with the server after
             *     `connectTimeout` milliseconds. This timeout has no effect once a socket
             *     connection has been established.
             *   * **timeout** [Integer] &mdash; Sets the socket to timeout after timeout
             *     milliseconds of inactivity on the socket. Defaults to two minutes
             *     (120000).
             *   * **xhrAsync** [Boolean] &mdash; Whether the SDK will send asynchronous
             *     HTTP requests. Used in the browser environment only. Set to false to
             *     send requests synchronously. Defaults to true (async on).
             *   * **xhrWithCredentials** [Boolean] &mdash; Sets the "withCredentials"
             *     property of an XMLHttpRequest object. Used in the browser environment
             *     only. Defaults to false.
             * @option options apiVersion [String, Date] a String in YYYY-MM-DD format
             *   (or a date) that represents the latest possible API version that can be
             *   used in all services (unless overridden by `apiVersions`). Specify
             *   'latest' to use the latest possible version.
             * @option options apiVersions [map<String, String|Date>] a map of service
             *   identifiers (the lowercase service class name) with the API version to
             *   use when instantiating a service. Specify 'latest' for each individual
             *   that can use the latest available version.
             * @option options logger [#write,#log] an object that responds to .write()
             *   (like a stream) or .log() (like the console object) in order to log
             *   information about requests
             * @option options systemClockOffset [Number] an offset value in milliseconds
             *   to apply to all signing times. Use this to compensate for clock skew
             *   when your system may be out of sync with the service time. Note that
             *   this configuration option can only be applied to the global `AWS.config`
             *   object and cannot be overridden in service-specific configuration.
             *   Defaults to 0 milliseconds.
             * @option options signatureVersion [String] the signature version to sign
             *   requests with (overriding the API configuration). Possible values are:
             *   'v2', 'v3', 'v4'.
             * @option options signatureCache [Boolean] whether the signature to sign
             *   requests with (overriding the API configuration) is cached. Only applies
             *   to the signature version 'v4'. Defaults to `true`.
             * @option options dynamoDbCrc32 [Boolean] whether to validate the CRC32
             *   checksum of HTTP response bodies returned by DynamoDB. Default: `true`.
             * @option options useAccelerateEndpoint [Boolean] Whether to use the
             *   S3 Transfer Acceleration endpoint with the S3 service. Default: `false`.
             * @option options clientSideMonitoring [Boolean] whether to collect and
             *   publish this client's performance metrics of all its API requests.
             * @option options endpointDiscoveryEnabled [Boolean|undefined] whether to
             *   call operations with endpoints given by service dynamically. Setting this
             * config to `true` will enable endpoint discovery for all applicable operations.
             *   Setting it to `false` will explicitly disable endpoint discovery even though
             *   operations that require endpoint discovery will presumably fail. Leaving it
             *   to `undefined` means SDK will only do endpoint discovery when it's required.
             *   Defaults to `undefined`
             * @option options endpointCacheSize [Number] the size of the global cache storing
             *   endpoints from endpoint discovery operations. Once endpoint cache is created,
             *   updating this setting cannot change existing cache size.
             *   Defaults to 1000
             * @option options hostPrefixEnabled [Boolean] whether to marshal request
             *   parameters to the prefix of hostname.
             *   Defaults to `true`.
             * @option options stsRegionalEndpoints ['legacy'|'regional'] whether to send sts request
             *   to global endpoints or regional endpoints.
             *   Defaults to 'legacy'.
             * @option options useFipsEndpoint [Boolean] Enables FIPS compatible endpoints.
             *   Defaults to `false`.
             * @option options useDualstackEndpoint [Boolean] Enables IPv6 dualstack endpoint.
             *   Defaults to `false`.
             */
            constructor: function Config(options) {
              if (options === void 0)
                options = {};
              options = this.extractCredentials(options);
              AWS2.util.each.call(this, this.keys, function(key, value) {
                this.set(key, options[key], value);
              });
            },
            /**
             * @!group Managing Credentials
             */
            /**
             * Loads credentials from the configuration object. This is used internally
             * by the SDK to ensure that refreshable {Credentials} objects are properly
             * refreshed and loaded when sending a request. If you want to ensure that
             * your credentials are loaded prior to a request, you can use this method
             * directly to provide accurate credential data stored in the object.
             *
             * @note If you configure the SDK with static or environment credentials,
             *   the credential data should already be present in {credentials} attribute.
             *   This method is primarily necessary to load credentials from asynchronous
             *   sources, or sources that can refresh credentials periodically.
             * @example Getting your access key
             *   AWS.config.getCredentials(function(err) {
             *     if (err) console.log(err.stack); // credentials not loaded
             *     else console.log("Access Key:", AWS.config.credentials.accessKeyId);
             *   })
             * @callback callback function(err)
             *   Called when the {credentials} have been properly set on the configuration
             *   object.
             *
             *   @param err [Error] if this is set, credentials were not successfully
             *     loaded and this error provides information why.
             * @see credentials
             * @see Credentials
             */
            getCredentials: function getCredentials(callback) {
              var self2 = this;
              function finish(err) {
                callback(err, err ? null : self2.credentials);
              }
              function credError(msg, err) {
                return new AWS2.util.error(err || new Error(), {
                  code: "CredentialsError",
                  message: msg,
                  name: "CredentialsError"
                });
              }
              function getAsyncCredentials() {
                self2.credentials.get(function(err) {
                  if (err) {
                    var msg = "Could not load credentials from " + self2.credentials.constructor.name;
                    err = credError(msg, err);
                  }
                  finish(err);
                });
              }
              function getStaticCredentials() {
                var err = null;
                if (!self2.credentials.accessKeyId || !self2.credentials.secretAccessKey) {
                  err = credError("Missing credentials");
                }
                finish(err);
              }
              if (self2.credentials) {
                if (typeof self2.credentials.get === "function") {
                  getAsyncCredentials();
                } else {
                  getStaticCredentials();
                }
              } else if (self2.credentialProvider) {
                self2.credentialProvider.resolve(function(err, creds) {
                  if (err) {
                    err = credError("Could not load credentials from any providers", err);
                  }
                  self2.credentials = creds;
                  finish(err);
                });
              } else {
                finish(credError("No credentials to load"));
              }
            },
            /**
             * Loads token from the configuration object. This is used internally
             * by the SDK to ensure that refreshable {Token} objects are properly
             * refreshed and loaded when sending a request. If you want to ensure that
             * your token is loaded prior to a request, you can use this method
             * directly to provide accurate token data stored in the object.
             *
             * @note If you configure the SDK with static token, the token data should
             *   already be present in {token} attribute. This method is primarily necessary
             *   to load token from asynchronous sources, or sources that can refresh
             *   token periodically.
             * @example Getting your access token
             *   AWS.config.getToken(function(err) {
             *     if (err) console.log(err.stack); // token not loaded
             *     else console.log("Token:", AWS.config.token.token);
             *   })
             * @callback callback function(err)
             *   Called when the {token} have been properly set on the configuration object.
             *
             *   @param err [Error] if this is set, token was not successfully loaded and
             *     this error provides information why.
             * @see token
             */
            getToken: function getToken(callback) {
              var self2 = this;
              function finish(err) {
                callback(err, err ? null : self2.token);
              }
              function tokenError(msg, err) {
                return new AWS2.util.error(err || new Error(), {
                  code: "TokenError",
                  message: msg,
                  name: "TokenError"
                });
              }
              function getAsyncToken() {
                self2.token.get(function(err) {
                  if (err) {
                    var msg = "Could not load token from " + self2.token.constructor.name;
                    err = tokenError(msg, err);
                  }
                  finish(err);
                });
              }
              function getStaticToken() {
                var err = null;
                if (!self2.token.token) {
                  err = tokenError("Missing token");
                }
                finish(err);
              }
              if (self2.token) {
                if (typeof self2.token.get === "function") {
                  getAsyncToken();
                } else {
                  getStaticToken();
                }
              } else if (self2.tokenProvider) {
                self2.tokenProvider.resolve(function(err, token) {
                  if (err) {
                    err = tokenError("Could not load token from any providers", err);
                  }
                  self2.token = token;
                  finish(err);
                });
              } else {
                finish(tokenError("No token to load"));
              }
            },
            /**
             * @!group Loading and Setting Configuration Options
             */
            /**
             * @overload update(options, allowUnknownKeys = false)
             *   Updates the current configuration object with new options.
             *
             *   @example Update maxRetries property of a configuration object
             *     config.update({maxRetries: 10});
             *   @param [Object] options a map of option keys and values.
             *   @param [Boolean] allowUnknownKeys whether unknown keys can be set on
             *     the configuration object. Defaults to `false`.
             *   @see constructor
             */
            update: function update(options, allowUnknownKeys) {
              allowUnknownKeys = allowUnknownKeys || false;
              options = this.extractCredentials(options);
              AWS2.util.each.call(this, options, function(key, value) {
                if (allowUnknownKeys || Object.prototype.hasOwnProperty.call(this.keys, key) || AWS2.Service.hasService(key)) {
                  this.set(key, value);
                }
              });
            },
            /**
             * Loads configuration data from a JSON file into this config object.
             * @note Loading configuration will reset all existing configuration
             *   on the object.
             * @!macro nobrowser
             * @param path [String] the path relative to your process's current
             *    working directory to load configuration from.
             * @return [AWS.Config] the same configuration object
             */
            loadFromPath: function loadFromPath(path) {
              this.clear();
              var options = JSON.parse(AWS2.util.readFileSync(path));
              var fileSystemCreds = new AWS2.FileSystemCredentials(path);
              var chain = new AWS2.CredentialProviderChain();
              chain.providers.unshift(fileSystemCreds);
              chain.resolve(function(err, creds) {
                if (err)
                  throw err;
                else
                  options.credentials = creds;
              });
              this.constructor(options);
              return this;
            },
            /**
             * Clears configuration data on this object
             *
             * @api private
             */
            clear: function clear() {
              AWS2.util.each.call(this, this.keys, function(key) {
                delete this[key];
              });
              this.set("credentials", void 0);
              this.set("credentialProvider", void 0);
            },
            /**
             * Sets a property on the configuration object, allowing for a
             * default value
             * @api private
             */
            set: function set(property, value, defaultValue) {
              if (value === void 0) {
                if (defaultValue === void 0) {
                  defaultValue = this.keys[property];
                }
                if (typeof defaultValue === "function") {
                  this[property] = defaultValue.call(this);
                } else {
                  this[property] = defaultValue;
                }
              } else if (property === "httpOptions" && this[property]) {
                this[property] = AWS2.util.merge(this[property], value);
              } else {
                this[property] = value;
              }
            },
            /**
             * All of the keys with their default values.
             *
             * @constant
             * @api private
             */
            keys: {
              credentials: null,
              credentialProvider: null,
              region: null,
              logger: null,
              apiVersions: {},
              apiVersion: null,
              endpoint: void 0,
              httpOptions: {
                timeout: 12e4
              },
              maxRetries: void 0,
              maxRedirects: 10,
              paramValidation: true,
              sslEnabled: true,
              s3ForcePathStyle: false,
              s3BucketEndpoint: false,
              s3DisableBodySigning: true,
              s3UsEast1RegionalEndpoint: "legacy",
              s3UseArnRegion: void 0,
              computeChecksums: true,
              convertResponseTypes: true,
              correctClockSkew: false,
              customUserAgent: null,
              dynamoDbCrc32: true,
              systemClockOffset: 0,
              signatureVersion: null,
              signatureCache: true,
              retryDelayOptions: {},
              useAccelerateEndpoint: false,
              clientSideMonitoring: false,
              endpointDiscoveryEnabled: void 0,
              endpointCacheSize: 1e3,
              hostPrefixEnabled: true,
              stsRegionalEndpoints: "legacy",
              useFipsEndpoint: false,
              useDualstackEndpoint: false,
              token: null
            },
            /**
             * Extracts accessKeyId, secretAccessKey and sessionToken
             * from a configuration hash.
             *
             * @api private
             */
            extractCredentials: function extractCredentials(options) {
              if (options.accessKeyId && options.secretAccessKey) {
                options = AWS2.util.copy(options);
                options.credentials = new AWS2.Credentials(options);
              }
              return options;
            },
            /**
             * Sets the promise dependency the SDK will use wherever Promises are returned.
             * Passing `null` will force the SDK to use native Promises if they are available.
             * If native Promises are not available, passing `null` will have no effect.
             * @param [Constructor] dep A reference to a Promise constructor
             */
            setPromisesDependency: function setPromisesDependency(dep) {
              PromisesDependency = dep;
              if (dep === null && typeof Promise === "function") {
                PromisesDependency = Promise;
              }
              var constructors = [AWS2.Request, AWS2.Credentials, AWS2.CredentialProviderChain];
              if (AWS2.S3) {
                constructors.push(AWS2.S3);
                if (AWS2.S3.ManagedUpload) {
                  constructors.push(AWS2.S3.ManagedUpload);
                }
              }
              AWS2.util.addPromises(constructors, PromisesDependency);
            },
            /**
             * Gets the promise dependency set by `AWS.config.setPromisesDependency`.
             */
            getPromisesDependency: function getPromisesDependency() {
              return PromisesDependency;
            }
          });
          AWS2.config = new AWS2.Config();
        }, { "./core": 19, "./credentials": 20, "./credentials/credential_provider_chain": 23 }], 18: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var AWS2 = require2("./core");
              function validateRegionalEndpointsFlagValue(configValue, errorOptions) {
                if (typeof configValue !== "string")
                  return void 0;
                else if (["legacy", "regional"].indexOf(configValue.toLowerCase()) >= 0) {
                  return configValue.toLowerCase();
                } else {
                  throw AWS2.util.error(new Error(), errorOptions);
                }
              }
              function resolveRegionalEndpointsFlag(originalConfig, options) {
                originalConfig = originalConfig || {};
                var resolved;
                if (originalConfig[options.clientConfig]) {
                  resolved = validateRegionalEndpointsFlagValue(originalConfig[options.clientConfig], {
                    code: "InvalidConfiguration",
                    message: 'invalid "' + options.clientConfig + '" configuration. Expect "legacy"  or "regional". Got "' + originalConfig[options.clientConfig] + '".'
                  });
                  if (resolved)
                    return resolved;
                }
                if (!AWS2.util.isNode())
                  return resolved;
                if (Object.prototype.hasOwnProperty.call(process.env, options.env)) {
                  var envFlag = process.env[options.env];
                  resolved = validateRegionalEndpointsFlagValue(envFlag, {
                    code: "InvalidEnvironmentalVariable",
                    message: "invalid " + options.env + ' environmental variable. Expect "legacy"  or "regional". Got "' + process.env[options.env] + '".'
                  });
                  if (resolved)
                    return resolved;
                }
                var profile = {};
                try {
                  var profiles = AWS2.util.getProfilesFromSharedConfig(AWS2.util.iniLoader);
                  profile = profiles[process.env.AWS_PROFILE || AWS2.util.defaultProfile];
                } catch (e) {
                }
                ;
                if (profile && Object.prototype.hasOwnProperty.call(profile, options.sharedConfig)) {
                  var fileFlag = profile[options.sharedConfig];
                  resolved = validateRegionalEndpointsFlagValue(fileFlag, {
                    code: "InvalidConfiguration",
                    message: "invalid " + options.sharedConfig + ' profile config. Expect "legacy"  or "regional". Got "' + profile[options.sharedConfig] + '".'
                  });
                  if (resolved)
                    return resolved;
                }
                return resolved;
              }
              module2.exports = resolveRegionalEndpointsFlag;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./core": 19, "_process": 91 }], 19: [function(require2, module2, exports2) {
          var AWS2 = { util: require2("./util") };
          var _hidden = {};
          _hidden.toString();
          module2.exports = AWS2;
          AWS2.util.update(AWS2, {
            /**
             * @constant
             */
            VERSION: "2.1455.0",
            /**
             * @api private
             */
            Signers: {},
            /**
             * @api private
             */
            Protocol: {
              Json: require2("./protocol/json"),
              Query: require2("./protocol/query"),
              Rest: require2("./protocol/rest"),
              RestJson: require2("./protocol/rest_json"),
              RestXml: require2("./protocol/rest_xml")
            },
            /**
             * @api private
             */
            XML: {
              Builder: require2("./xml/builder"),
              Parser: null
              // conditionally set based on environment
            },
            /**
             * @api private
             */
            JSON: {
              Builder: require2("./json/builder"),
              Parser: require2("./json/parser")
            },
            /**
             * @api private
             */
            Model: {
              Api: require2("./model/api"),
              Operation: require2("./model/operation"),
              Shape: require2("./model/shape"),
              Paginator: require2("./model/paginator"),
              ResourceWaiter: require2("./model/resource_waiter")
            },
            /**
             * @api private
             */
            apiLoader: require2("./api_loader"),
            /**
             * @api private
             */
            EndpointCache: require2("../vendor/endpoint-cache").EndpointCache
          });
          require2("./sequential_executor");
          require2("./service");
          require2("./config");
          require2("./http");
          require2("./event_listeners");
          require2("./request");
          require2("./response");
          require2("./resource_waiter");
          require2("./signers/request_signer");
          require2("./param_validator");
          require2("./maintenance_mode_message");
          AWS2.events = new AWS2.SequentialExecutor();
          AWS2.util.memoizedProperty(AWS2, "endpointCache", function() {
            return new AWS2.EndpointCache(AWS2.config.endpointCacheSize);
          }, true);
        }, { "../vendor/endpoint-cache": 111, "./api_loader": 9, "./config": 17, "./event_listeners": 34, "./http": 35, "./json/builder": 37, "./json/parser": 38, "./maintenance_mode_message": 39, "./model/api": 40, "./model/operation": 42, "./model/paginator": 43, "./model/resource_waiter": 44, "./model/shape": 45, "./param_validator": 46, "./protocol/json": 48, "./protocol/query": 49, "./protocol/rest": 50, "./protocol/rest_json": 51, "./protocol/rest_xml": 52, "./request": 58, "./resource_waiter": 59, "./response": 60, "./sequential_executor": 61, "./service": 62, "./signers/request_signer": 66, "./util": 74, "./xml/builder": 76 }], 20: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          AWS2.Credentials = AWS2.util.inherit({
            /**
             * A credentials object can be created using positional arguments or an options
             * hash.
             *
             * @overload AWS.Credentials(accessKeyId, secretAccessKey, sessionToken=null)
             *   Creates a Credentials object with a given set of credential information
             *   as positional arguments.
             *   @param accessKeyId [String] the AWS access key ID
             *   @param secretAccessKey [String] the AWS secret access key
             *   @param sessionToken [String] the optional AWS session token
             *   @example Create a credentials object with AWS credentials
             *     var creds = new AWS.Credentials('akid', 'secret', 'session');
             * @overload AWS.Credentials(options)
             *   Creates a Credentials object with a given set of credential information
             *   as an options hash.
             *   @option options accessKeyId [String] the AWS access key ID
             *   @option options secretAccessKey [String] the AWS secret access key
             *   @option options sessionToken [String] the optional AWS session token
             *   @example Create a credentials object with AWS credentials
             *     var creds = new AWS.Credentials({
             *       accessKeyId: 'akid', secretAccessKey: 'secret', sessionToken: 'session'
             *     });
             */
            constructor: function Credentials() {
              AWS2.util.hideProperties(this, ["secretAccessKey"]);
              this.expired = false;
              this.expireTime = null;
              this.refreshCallbacks = [];
              if (arguments.length === 1 && typeof arguments[0] === "object") {
                var creds = arguments[0].credentials || arguments[0];
                this.accessKeyId = creds.accessKeyId;
                this.secretAccessKey = creds.secretAccessKey;
                this.sessionToken = creds.sessionToken;
              } else {
                this.accessKeyId = arguments[0];
                this.secretAccessKey = arguments[1];
                this.sessionToken = arguments[2];
              }
            },
            /**
             * @return [Integer] the number of seconds before {expireTime} during which
             *   the credentials will be considered expired.
             */
            expiryWindow: 15,
            /**
             * @return [Boolean] whether the credentials object should call {refresh}
             * @note Subclasses should override this method to provide custom refresh
             *   logic.
             */
            needsRefresh: function needsRefresh() {
              var currentTime = AWS2.util.date.getDate().getTime();
              var adjustedTime = new Date(currentTime + this.expiryWindow * 1e3);
              if (this.expireTime && adjustedTime > this.expireTime) {
                return true;
              } else {
                return this.expired || !this.accessKeyId || !this.secretAccessKey;
              }
            },
            /**
             * Gets the existing credentials, refreshing them if they are not yet loaded
             * or have expired. Users should call this method before using {refresh},
             * as this will not attempt to reload credentials when they are already
             * loaded into the object.
             *
             * @callback callback function(err)
             *   When this callback is called with no error, it means either credentials
             *   do not need to be refreshed or refreshed credentials information has
             *   been loaded into the object (as the `accessKeyId`, `secretAccessKey`,
             *   and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             */
            get: function get(callback) {
              var self2 = this;
              if (this.needsRefresh()) {
                this.refresh(function(err) {
                  if (!err)
                    self2.expired = false;
                  if (callback)
                    callback(err);
                });
              } else if (callback) {
                callback();
              }
            },
            /**
             * @!method  getPromise()
             *   Returns a 'thenable' promise.
             *   Gets the existing credentials, refreshing them if they are not yet loaded
             *   or have expired. Users should call this method before using {refresh},
             *   as this will not attempt to reload credentials when they are already
             *   loaded into the object.
             *
             *   Two callbacks can be provided to the `then` method on the returned promise.
             *   The first callback will be called if the promise is fulfilled, and the second
             *   callback will be called if the promise is rejected.
             *   @callback fulfilledCallback function()
             *     Called if the promise is fulfilled. When this callback is called, it
             *     means either credentials do not need to be refreshed or refreshed
             *     credentials information has been loaded into the object (as the
             *     `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
             *   @callback rejectedCallback function(err)
             *     Called if the promise is rejected.
             *     @param err [Error] if an error occurred, this value will be filled
             *   @return [Promise] A promise that represents the state of the `get` call.
             *   @example Calling the `getPromise` method.
             *     var promise = credProvider.getPromise();
             *     promise.then(function() { ... }, function(err) { ... });
             */
            /**
             * @!method  refreshPromise()
             *   Returns a 'thenable' promise.
             *   Refreshes the credentials. Users should call {get} before attempting
             *   to forcibly refresh credentials.
             *
             *   Two callbacks can be provided to the `then` method on the returned promise.
             *   The first callback will be called if the promise is fulfilled, and the second
             *   callback will be called if the promise is rejected.
             *   @callback fulfilledCallback function()
             *     Called if the promise is fulfilled. When this callback is called, it
             *     means refreshed credentials information has been loaded into the object
             *     (as the `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
             *   @callback rejectedCallback function(err)
             *     Called if the promise is rejected.
             *     @param err [Error] if an error occurred, this value will be filled
             *   @return [Promise] A promise that represents the state of the `refresh` call.
             *   @example Calling the `refreshPromise` method.
             *     var promise = credProvider.refreshPromise();
             *     promise.then(function() { ... }, function(err) { ... });
             */
            /**
             * Refreshes the credentials. Users should call {get} before attempting
             * to forcibly refresh credentials.
             *
             * @callback callback function(err)
             *   When this callback is called with no error, it means refreshed
             *   credentials information has been loaded into the object (as the
             *   `accessKeyId`, `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @note Subclasses should override this class to reset the
             *   {accessKeyId}, {secretAccessKey} and optional {sessionToken}
             *   on the credentials object and then call the callback with
             *   any error information.
             * @see get
             */
            refresh: function refresh(callback) {
              this.expired = false;
              callback();
            },
            /**
             * @api private
             * @param callback
             */
            coalesceRefresh: function coalesceRefresh(callback, sync) {
              var self2 = this;
              if (self2.refreshCallbacks.push(callback) === 1) {
                self2.load(function onLoad(err) {
                  AWS2.util.arrayEach(self2.refreshCallbacks, function(callback2) {
                    if (sync) {
                      callback2(err);
                    } else {
                      AWS2.util.defer(function() {
                        callback2(err);
                      });
                    }
                  });
                  self2.refreshCallbacks.length = 0;
                });
              }
            },
            /**
             * @api private
             * @param callback
             */
            load: function load(callback) {
              callback();
            }
          });
          AWS2.Credentials.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
            this.prototype.getPromise = AWS2.util.promisifyMethod("get", PromiseDependency);
            this.prototype.refreshPromise = AWS2.util.promisifyMethod("refresh", PromiseDependency);
          };
          AWS2.Credentials.deletePromisesFromClass = function deletePromisesFromClass() {
            delete this.prototype.getPromise;
            delete this.prototype.refreshPromise;
          };
          AWS2.util.addPromises(AWS2.Credentials);
        }, { "./core": 19 }], 21: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var STS = require2("../../clients/sts");
          AWS2.ChainableTemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * Creates a new temporary credentials object.
             *
             * @param options [map] a set of options
             * @option options params [map] ({}) a map of options that are passed to the
             *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
             *   If a `RoleArn` parameter is passed in, credentials will be based on the
             *   IAM role. If a `SerialNumber` parameter is passed in, {tokenCodeFn} must
             *   also be passed in or an error will be thrown.
             * @option options masterCredentials [AWS.Credentials] the master credentials
             *   used to get and refresh temporary credentials from AWS STS. By default,
             *   AWS.config.credentials or AWS.config.credentialProvider will be used.
             * @option options tokenCodeFn [Function] (null) Function to provide
             *   `TokenCode`, if `SerialNumber` is provided for profile in {params}. Function
             *   is called with value of `SerialNumber` and `callback`, and should provide
             *   the `TokenCode` or an error to the callback in the format
             *   `callback(err, token)`.
             * @example Creating a new credentials object for generic temporary credentials
             *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials();
             * @example Creating a new credentials object for an IAM role
             *   AWS.config.credentials = new AWS.ChainableTemporaryCredentials({
             *     params: {
             *       RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials'
             *     }
             *   });
             * @see AWS.STS.assumeRole
             * @see AWS.STS.getSessionToken
             */
            constructor: function ChainableTemporaryCredentials(options) {
              AWS2.Credentials.call(this);
              options = options || {};
              this.errorCode = "ChainableTemporaryCredentialsProviderFailure";
              this.expired = true;
              this.tokenCodeFn = null;
              var params = AWS2.util.copy(options.params) || {};
              if (params.RoleArn) {
                params.RoleSessionName = params.RoleSessionName || "temporary-credentials";
              }
              if (params.SerialNumber) {
                if (!options.tokenCodeFn || typeof options.tokenCodeFn !== "function") {
                  throw new AWS2.util.error(
                    new Error("tokenCodeFn must be a function when params.SerialNumber is given"),
                    { code: this.errorCode }
                  );
                } else {
                  this.tokenCodeFn = options.tokenCodeFn;
                }
              }
              var config = AWS2.util.merge(
                {
                  params,
                  credentials: options.masterCredentials || AWS2.config.credentials
                },
                options.stsConfig || {}
              );
              this.service = new STS(config);
            },
            /**
             * Refreshes credentials using {AWS.STS.assumeRole} or
             * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
             * to the credentials {constructor}.
             *
             * @callback callback function(err)
             *   Called when the STS service responds (or fails). When
             *   this callback is called with no error, it means that the credentials
             *   information has been loaded into the object (as the `accessKeyId`,
             *   `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @see AWS.Credentials.get
             */
            refresh: function refresh(callback) {
              this.coalesceRefresh(callback || AWS2.util.fn.callback);
            },
            /**
             * @api private
             * @param callback
             */
            load: function load(callback) {
              var self2 = this;
              var operation = self2.service.config.params.RoleArn ? "assumeRole" : "getSessionToken";
              this.getTokenCode(function(err, tokenCode) {
                var params = {};
                if (err) {
                  callback(err);
                  return;
                }
                if (tokenCode) {
                  params.TokenCode = tokenCode;
                }
                self2.service[operation](params, function(err2, data) {
                  if (!err2) {
                    self2.service.credentialsFrom(data, self2);
                  }
                  callback(err2);
                });
              });
            },
            /**
             * @api private
             */
            getTokenCode: function getTokenCode(callback) {
              var self2 = this;
              if (this.tokenCodeFn) {
                this.tokenCodeFn(this.service.config.params.SerialNumber, function(err, token) {
                  if (err) {
                    var message = err;
                    if (err instanceof Error) {
                      message = err.message;
                    }
                    callback(
                      AWS2.util.error(
                        new Error("Error fetching MFA token: " + message),
                        { code: self2.errorCode }
                      )
                    );
                    return;
                  }
                  callback(null, token);
                });
              } else {
                callback(null);
              }
            }
          });
        }, { "../../clients/sts": 8, "../core": 19 }], 22: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var CognitoIdentity = require2("../../clients/cognitoidentity");
          var STS = require2("../../clients/sts");
          AWS2.CognitoIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * @api private
             */
            localStorageKey: {
              id: "aws.cognito.identity-id.",
              providers: "aws.cognito.identity-providers."
            },
            /**
             * Creates a new credentials object.
             * @example Creating a new credentials object
             *   AWS.config.credentials = new AWS.CognitoIdentityCredentials({
             *
             *     // either IdentityPoolId or IdentityId is required
             *     // See the IdentityPoolId param for AWS.CognitoIdentity.getID (linked below)
             *     // See the IdentityId param for AWS.CognitoIdentity.getCredentialsForIdentity
             *     // or AWS.CognitoIdentity.getOpenIdToken (linked below)
             *     IdentityPoolId: 'us-east-1:1699ebc0-7900-4099-b910-2df94f52a030',
             *     IdentityId: 'us-east-1:128d0a74-c82f-4553-916d-90053e4a8b0f'
             *
             *     // optional, only necessary when the identity pool is not configured
             *     // to use IAM roles in the Amazon Cognito Console
             *     // See the RoleArn param for AWS.STS.assumeRoleWithWebIdentity (linked below)
             *     RoleArn: 'arn:aws:iam::1234567890:role/MYAPP-CognitoIdentity',
             *
             *     // optional tokens, used for authenticated login
             *     // See the Logins param for AWS.CognitoIdentity.getID (linked below)
             *     Logins: {
             *       'graph.facebook.com': 'FBTOKEN',
             *       'www.amazon.com': 'AMAZONTOKEN',
             *       'accounts.google.com': 'GOOGLETOKEN',
             *       'api.twitter.com': 'TWITTERTOKEN',
             *       'www.digits.com': 'DIGITSTOKEN'
             *     },
             *
             *     // optional name, defaults to web-identity
             *     // See the RoleSessionName param for AWS.STS.assumeRoleWithWebIdentity (linked below)
             *     RoleSessionName: 'web',
             *
             *     // optional, only necessary when application runs in a browser
             *     // and multiple users are signed in at once, used for caching
             *     LoginId: 'example@gmail.com'
             *
             *   }, {
             *      // optionally provide configuration to apply to the underlying service clients
             *      // if configuration is not provided, then configuration will be pulled from AWS.config
             *
             *      // region should match the region your identity pool is located in
             *      region: 'us-east-1',
             *
             *      // specify timeout options
             *      httpOptions: {
             *        timeout: 100
             *      }
             *   });
             * @see AWS.CognitoIdentity.getId
             * @see AWS.CognitoIdentity.getCredentialsForIdentity
             * @see AWS.STS.assumeRoleWithWebIdentity
             * @see AWS.CognitoIdentity.getOpenIdToken
             * @see AWS.Config
             * @note If a region is not provided in the global AWS.config, or
             *   specified in the `clientConfig` to the CognitoIdentityCredentials
             *   constructor, you may encounter a 'Missing credentials in config' error
             *   when calling making a service call.
             */
            constructor: function CognitoIdentityCredentials(params, clientConfig) {
              AWS2.Credentials.call(this);
              this.expired = true;
              this.params = params;
              this.data = null;
              this._identityId = null;
              this._clientConfig = AWS2.util.copy(clientConfig || {});
              this.loadCachedId();
              var self2 = this;
              Object.defineProperty(this, "identityId", {
                get: function() {
                  self2.loadCachedId();
                  return self2._identityId || self2.params.IdentityId;
                },
                set: function(identityId) {
                  self2._identityId = identityId;
                }
              });
            },
            /**
             * Refreshes credentials using {AWS.CognitoIdentity.getCredentialsForIdentity},
             * or {AWS.STS.assumeRoleWithWebIdentity}.
             *
             * @callback callback function(err)
             *   Called when the STS service responds (or fails). When
             *   this callback is called with no error, it means that the credentials
             *   information has been loaded into the object (as the `accessKeyId`,
             *   `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @see AWS.Credentials.get
             */
            refresh: function refresh(callback) {
              this.coalesceRefresh(callback || AWS2.util.fn.callback);
            },
            /**
             * @api private
             * @param callback
             */
            load: function load(callback) {
              var self2 = this;
              self2.createClients();
              self2.data = null;
              self2._identityId = null;
              self2.getId(function(err) {
                if (!err) {
                  if (!self2.params.RoleArn) {
                    self2.getCredentialsForIdentity(callback);
                  } else {
                    self2.getCredentialsFromSTS(callback);
                  }
                } else {
                  self2.clearIdOnNotAuthorized(err);
                  callback(err);
                }
              });
            },
            /**
             * Clears the cached Cognito ID associated with the currently configured
             * identity pool ID. Use this to manually invalidate your cache if
             * the identity pool ID was deleted.
             */
            clearCachedId: function clearCache() {
              this._identityId = null;
              delete this.params.IdentityId;
              var poolId = this.params.IdentityPoolId;
              var loginId = this.params.LoginId || "";
              delete this.storage[this.localStorageKey.id + poolId + loginId];
              delete this.storage[this.localStorageKey.providers + poolId + loginId];
            },
            /**
             * @api private
             */
            clearIdOnNotAuthorized: function clearIdOnNotAuthorized(err) {
              var self2 = this;
              if (err.code == "NotAuthorizedException") {
                self2.clearCachedId();
              }
            },
            /**
             * Retrieves a Cognito ID, loading from cache if it was already retrieved
             * on this device.
             *
             * @callback callback function(err, identityId)
             *   @param err [Error, null] an error object if the call failed or null if
             *     it succeeded.
             *   @param identityId [String, null] if successful, the callback will return
             *     the Cognito ID.
             * @note If not loaded explicitly, the Cognito ID is loaded and stored in
             *   localStorage in the browser environment of a device.
             * @api private
             */
            getId: function getId(callback) {
              var self2 = this;
              if (typeof self2.params.IdentityId === "string") {
                return callback(null, self2.params.IdentityId);
              }
              self2.cognito.getId(function(err, data) {
                if (!err && data.IdentityId) {
                  self2.params.IdentityId = data.IdentityId;
                  callback(null, data.IdentityId);
                } else {
                  callback(err);
                }
              });
            },
            /**
             * @api private
             */
            loadCredentials: function loadCredentials(data, credentials) {
              if (!data || !credentials)
                return;
              credentials.expired = false;
              credentials.accessKeyId = data.Credentials.AccessKeyId;
              credentials.secretAccessKey = data.Credentials.SecretKey;
              credentials.sessionToken = data.Credentials.SessionToken;
              credentials.expireTime = data.Credentials.Expiration;
            },
            /**
             * @api private
             */
            getCredentialsForIdentity: function getCredentialsForIdentity(callback) {
              var self2 = this;
              self2.cognito.getCredentialsForIdentity(function(err, data) {
                if (!err) {
                  self2.cacheId(data);
                  self2.data = data;
                  self2.loadCredentials(self2.data, self2);
                } else {
                  self2.clearIdOnNotAuthorized(err);
                }
                callback(err);
              });
            },
            /**
             * @api private
             */
            getCredentialsFromSTS: function getCredentialsFromSTS(callback) {
              var self2 = this;
              self2.cognito.getOpenIdToken(function(err, data) {
                if (!err) {
                  self2.cacheId(data);
                  self2.params.WebIdentityToken = data.Token;
                  self2.webIdentityCredentials.refresh(function(webErr) {
                    if (!webErr) {
                      self2.data = self2.webIdentityCredentials.data;
                      self2.sts.credentialsFrom(self2.data, self2);
                    }
                    callback(webErr);
                  });
                } else {
                  self2.clearIdOnNotAuthorized(err);
                  callback(err);
                }
              });
            },
            /**
             * @api private
             */
            loadCachedId: function loadCachedId() {
              var self2 = this;
              if (AWS2.util.isBrowser() && !self2.params.IdentityId) {
                var id = self2.getStorage("id");
                if (id && self2.params.Logins) {
                  var actualProviders = Object.keys(self2.params.Logins);
                  var cachedProviders = (self2.getStorage("providers") || "").split(",");
                  var intersect = cachedProviders.filter(function(n) {
                    return actualProviders.indexOf(n) !== -1;
                  });
                  if (intersect.length !== 0) {
                    self2.params.IdentityId = id;
                  }
                } else if (id) {
                  self2.params.IdentityId = id;
                }
              }
            },
            /**
             * @api private
             */
            createClients: function() {
              var clientConfig = this._clientConfig;
              this.webIdentityCredentials = this.webIdentityCredentials || new AWS2.WebIdentityCredentials(this.params, clientConfig);
              if (!this.cognito) {
                var cognitoConfig = AWS2.util.merge({}, clientConfig);
                cognitoConfig.params = this.params;
                this.cognito = new CognitoIdentity(cognitoConfig);
              }
              this.sts = this.sts || new STS(clientConfig);
            },
            /**
             * @api private
             */
            cacheId: function cacheId(data) {
              this._identityId = data.IdentityId;
              this.params.IdentityId = this._identityId;
              if (AWS2.util.isBrowser()) {
                this.setStorage("id", data.IdentityId);
                if (this.params.Logins) {
                  this.setStorage("providers", Object.keys(this.params.Logins).join(","));
                }
              }
            },
            /**
             * @api private
             */
            getStorage: function getStorage(key) {
              return this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")];
            },
            /**
             * @api private
             */
            setStorage: function setStorage(key, val) {
              try {
                this.storage[this.localStorageKey[key] + this.params.IdentityPoolId + (this.params.LoginId || "")] = val;
              } catch (_) {
              }
            },
            /**
             * @api private
             */
            storage: function() {
              try {
                var storage = AWS2.util.isBrowser() && window.localStorage !== null && typeof window.localStorage === "object" ? window.localStorage : {};
                storage["aws.test-storage"] = "foobar";
                delete storage["aws.test-storage"];
                return storage;
              } catch (_) {
                return {};
              }
            }()
          });
        }, { "../../clients/cognitoidentity": 7, "../../clients/sts": 8, "../core": 19 }], 23: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          AWS2.CredentialProviderChain = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * Creates a new CredentialProviderChain with a default set of providers
             * specified by {defaultProviders}.
             */
            constructor: function CredentialProviderChain(providers) {
              if (providers) {
                this.providers = providers;
              } else {
                this.providers = AWS2.CredentialProviderChain.defaultProviders.slice(0);
              }
              this.resolveCallbacks = [];
            },
            /**
             * @!method  resolvePromise()
             *   Returns a 'thenable' promise.
             *   Resolves the provider chain by searching for the first set of
             *   credentials in {providers}.
             *
             *   Two callbacks can be provided to the `then` method on the returned promise.
             *   The first callback will be called if the promise is fulfilled, and the second
             *   callback will be called if the promise is rejected.
             *   @callback fulfilledCallback function(credentials)
             *     Called if the promise is fulfilled and the provider resolves the chain
             *     to a credentials object
             *     @param credentials [AWS.Credentials] the credentials object resolved
             *       by the provider chain.
             *   @callback rejectedCallback function(error)
             *     Called if the promise is rejected.
             *     @param err [Error] the error object returned if no credentials are found.
             *   @return [Promise] A promise that represents the state of the `resolve` method call.
             *   @example Calling the `resolvePromise` method.
             *     var promise = chain.resolvePromise();
             *     promise.then(function(credentials) { ... }, function(err) { ... });
             */
            /**
             * Resolves the provider chain by searching for the first set of
             * credentials in {providers}.
             *
             * @callback callback function(err, credentials)
             *   Called when the provider resolves the chain to a credentials object
             *   or null if no credentials can be found.
             *
             *   @param err [Error] the error object returned if no credentials are
             *     found.
             *   @param credentials [AWS.Credentials] the credentials object resolved
             *     by the provider chain.
             * @return [AWS.CredentialProviderChain] the provider, for chaining.
             */
            resolve: function resolve(callback) {
              var self2 = this;
              if (self2.providers.length === 0) {
                callback(new Error("No providers"));
                return self2;
              }
              if (self2.resolveCallbacks.push(callback) === 1) {
                let resolveNext2 = function(err, creds) {
                  if (!err && creds || index === providers.length) {
                    AWS2.util.arrayEach(self2.resolveCallbacks, function(callback2) {
                      callback2(err, creds);
                    });
                    self2.resolveCallbacks.length = 0;
                    return;
                  }
                  var provider = providers[index++];
                  if (typeof provider === "function") {
                    creds = provider.call();
                  } else {
                    creds = provider;
                  }
                  if (creds.get) {
                    creds.get(function(getErr) {
                      resolveNext2(getErr, getErr ? null : creds);
                    });
                  } else {
                    resolveNext2(null, creds);
                  }
                };
                var resolveNext = resolveNext2;
                var index = 0;
                var providers = self2.providers.slice(0);
                resolveNext2();
              }
              return self2;
            }
          });
          AWS2.CredentialProviderChain.defaultProviders = [];
          AWS2.CredentialProviderChain.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
            this.prototype.resolvePromise = AWS2.util.promisifyMethod("resolve", PromiseDependency);
          };
          AWS2.CredentialProviderChain.deletePromisesFromClass = function deletePromisesFromClass() {
            delete this.prototype.resolvePromise;
          };
          AWS2.util.addPromises(AWS2.CredentialProviderChain);
        }, { "../core": 19 }], 24: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var STS = require2("../../clients/sts");
          AWS2.SAMLCredentials = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * Creates a new credentials object.
             * @param (see AWS.STS.assumeRoleWithSAML)
             * @example Creating a new credentials object
             *   AWS.config.credentials = new AWS.SAMLCredentials({
             *     RoleArn: 'arn:aws:iam::1234567890:role/SAMLRole',
             *     PrincipalArn: 'arn:aws:iam::1234567890:role/SAMLPrincipal',
             *     SAMLAssertion: 'base64-token', // base64-encoded token from IdP
             *   });
             * @see AWS.STS.assumeRoleWithSAML
             */
            constructor: function SAMLCredentials(params) {
              AWS2.Credentials.call(this);
              this.expired = true;
              this.params = params;
            },
            /**
             * Refreshes credentials using {AWS.STS.assumeRoleWithSAML}
             *
             * @callback callback function(err)
             *   Called when the STS service responds (or fails). When
             *   this callback is called with no error, it means that the credentials
             *   information has been loaded into the object (as the `accessKeyId`,
             *   `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @see get
             */
            refresh: function refresh(callback) {
              this.coalesceRefresh(callback || AWS2.util.fn.callback);
            },
            /**
             * @api private
             */
            load: function load(callback) {
              var self2 = this;
              self2.createClients();
              self2.service.assumeRoleWithSAML(function(err, data) {
                if (!err) {
                  self2.service.credentialsFrom(data, self2);
                }
                callback(err);
              });
            },
            /**
             * @api private
             */
            createClients: function() {
              this.service = this.service || new STS({ params: this.params });
            }
          });
        }, { "../../clients/sts": 8, "../core": 19 }], 25: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var STS = require2("../../clients/sts");
          AWS2.TemporaryCredentials = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * Creates a new temporary credentials object.
             *
             * @note In order to create temporary credentials, you first need to have
             *   "master" credentials configured in {AWS.Config.credentials}. These
             *   master credentials are necessary to retrieve the temporary credentials,
             *   as well as refresh the credentials when they expire.
             * @param params [map] a map of options that are passed to the
             *   {AWS.STS.assumeRole} or {AWS.STS.getSessionToken} operations.
             *   If a `RoleArn` parameter is passed in, credentials will be based on the
             *   IAM role.
             * @param masterCredentials [AWS.Credentials] the master (non-temporary) credentials
             *  used to get and refresh temporary credentials from AWS STS.
             * @example Creating a new credentials object for generic temporary credentials
             *   AWS.config.credentials = new AWS.TemporaryCredentials();
             * @example Creating a new credentials object for an IAM role
             *   AWS.config.credentials = new AWS.TemporaryCredentials({
             *     RoleArn: 'arn:aws:iam::1234567890:role/TemporaryCredentials',
             *   });
             * @see AWS.STS.assumeRole
             * @see AWS.STS.getSessionToken
             */
            constructor: function TemporaryCredentials(params, masterCredentials) {
              AWS2.Credentials.call(this);
              this.loadMasterCredentials(masterCredentials);
              this.expired = true;
              this.params = params || {};
              if (this.params.RoleArn) {
                this.params.RoleSessionName = this.params.RoleSessionName || "temporary-credentials";
              }
            },
            /**
             * Refreshes credentials using {AWS.STS.assumeRole} or
             * {AWS.STS.getSessionToken}, depending on whether an IAM role ARN was passed
             * to the credentials {constructor}.
             *
             * @callback callback function(err)
             *   Called when the STS service responds (or fails). When
             *   this callback is called with no error, it means that the credentials
             *   information has been loaded into the object (as the `accessKeyId`,
             *   `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @see get
             */
            refresh: function refresh(callback) {
              this.coalesceRefresh(callback || AWS2.util.fn.callback);
            },
            /**
             * @api private
             */
            load: function load(callback) {
              var self2 = this;
              self2.createClients();
              self2.masterCredentials.get(function() {
                self2.service.config.credentials = self2.masterCredentials;
                var operation = self2.params.RoleArn ? self2.service.assumeRole : self2.service.getSessionToken;
                operation.call(self2.service, function(err, data) {
                  if (!err) {
                    self2.service.credentialsFrom(data, self2);
                  }
                  callback(err);
                });
              });
            },
            /**
             * @api private
             */
            loadMasterCredentials: function loadMasterCredentials(masterCredentials) {
              this.masterCredentials = masterCredentials || AWS2.config.credentials;
              while (this.masterCredentials.masterCredentials) {
                this.masterCredentials = this.masterCredentials.masterCredentials;
              }
              if (typeof this.masterCredentials.get !== "function") {
                this.masterCredentials = new AWS2.Credentials(this.masterCredentials);
              }
            },
            /**
             * @api private
             */
            createClients: function() {
              this.service = this.service || new STS({ params: this.params });
            }
          });
        }, { "../../clients/sts": 8, "../core": 19 }], 26: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var STS = require2("../../clients/sts");
          AWS2.WebIdentityCredentials = AWS2.util.inherit(AWS2.Credentials, {
            /**
             * Creates a new credentials object.
             * @param (see AWS.STS.assumeRoleWithWebIdentity)
             * @example Creating a new credentials object
             *   AWS.config.credentials = new AWS.WebIdentityCredentials({
             *     RoleArn: 'arn:aws:iam::1234567890:role/WebIdentity',
             *     WebIdentityToken: 'ABCDEFGHIJKLMNOP', // token from identity service
             *     RoleSessionName: 'web' // optional name, defaults to web-identity
             *   }, {
             *     // optionally provide configuration to apply to the underlying AWS.STS service client
             *     // if configuration is not provided, then configuration will be pulled from AWS.config
             *
             *     // specify timeout options
             *     httpOptions: {
             *       timeout: 100
             *     }
             *   });
             * @see AWS.STS.assumeRoleWithWebIdentity
             * @see AWS.Config
             */
            constructor: function WebIdentityCredentials(params, clientConfig) {
              AWS2.Credentials.call(this);
              this.expired = true;
              this.params = params;
              this.params.RoleSessionName = this.params.RoleSessionName || "web-identity";
              this.data = null;
              this._clientConfig = AWS2.util.copy(clientConfig || {});
            },
            /**
             * Refreshes credentials using {AWS.STS.assumeRoleWithWebIdentity}
             *
             * @callback callback function(err)
             *   Called when the STS service responds (or fails). When
             *   this callback is called with no error, it means that the credentials
             *   information has been loaded into the object (as the `accessKeyId`,
             *   `secretAccessKey`, and `sessionToken` properties).
             *   @param err [Error] if an error occurred, this value will be filled
             * @see get
             */
            refresh: function refresh(callback) {
              this.coalesceRefresh(callback || AWS2.util.fn.callback);
            },
            /**
             * @api private
             */
            load: function load(callback) {
              var self2 = this;
              self2.createClients();
              self2.service.assumeRoleWithWebIdentity(function(err, data) {
                self2.data = null;
                if (!err) {
                  self2.data = data;
                  self2.service.credentialsFrom(data, self2);
                }
                callback(err);
              });
            },
            /**
             * @api private
             */
            createClients: function() {
              if (!this.service) {
                var stsConfig = AWS2.util.merge({}, this._clientConfig);
                stsConfig.params = this.params;
                this.service = new STS(stsConfig);
              }
            }
          });
        }, { "../../clients/sts": 8, "../core": 19 }], 27: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var AWS2 = require2("./core");
              var util = require2("./util");
              var endpointDiscoveryEnabledEnvs = ["AWS_ENABLE_ENDPOINT_DISCOVERY", "AWS_ENDPOINT_DISCOVERY_ENABLED"];
              function getCacheKey(request) {
                var service = request.service;
                var api = service.api || {};
                var operations = api.operations;
                var identifiers = {};
                if (service.config.region) {
                  identifiers.region = service.config.region;
                }
                if (api.serviceId) {
                  identifiers.serviceId = api.serviceId;
                }
                if (service.config.credentials.accessKeyId) {
                  identifiers.accessKeyId = service.config.credentials.accessKeyId;
                }
                return identifiers;
              }
              function marshallCustomIdentifiersHelper(result, params, shape) {
                if (!shape || params === void 0 || params === null)
                  return;
                if (shape.type === "structure" && shape.required && shape.required.length > 0) {
                  util.arrayEach(shape.required, function(name) {
                    var memberShape = shape.members[name];
                    if (memberShape.endpointDiscoveryId === true) {
                      var locationName = memberShape.isLocationName ? memberShape.name : name;
                      result[locationName] = String(params[name]);
                    } else {
                      marshallCustomIdentifiersHelper(result, params[name], memberShape);
                    }
                  });
                }
              }
              function marshallCustomIdentifiers(request, shape) {
                var identifiers = {};
                marshallCustomIdentifiersHelper(identifiers, request.params, shape);
                return identifiers;
              }
              function optionalDiscoverEndpoint(request) {
                var service = request.service;
                var api = service.api;
                var operationModel = api.operations ? api.operations[request.operation] : void 0;
                var inputShape = operationModel ? operationModel.input : void 0;
                var identifiers = marshallCustomIdentifiers(request, inputShape);
                var cacheKey = getCacheKey(request);
                if (Object.keys(identifiers).length > 0) {
                  cacheKey = util.update(cacheKey, identifiers);
                  if (operationModel)
                    cacheKey.operation = operationModel.name;
                }
                var endpoints = AWS2.endpointCache.get(cacheKey);
                if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
                  return;
                } else if (endpoints && endpoints.length > 0) {
                  request.httpRequest.updateEndpoint(endpoints[0].Address);
                } else {
                  var endpointRequest = service.makeRequest(api.endpointOperation, {
                    Operation: operationModel.name,
                    Identifiers: identifiers
                  });
                  addApiVersionHeader(endpointRequest);
                  endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
                  endpointRequest.removeListener("retry", AWS2.EventListeners.Core.RETRY_CHECK);
                  AWS2.endpointCache.put(cacheKey, [{
                    Address: "",
                    CachePeriodInMinutes: 1
                  }]);
                  endpointRequest.send(function(err, data) {
                    if (data && data.Endpoints) {
                      AWS2.endpointCache.put(cacheKey, data.Endpoints);
                    } else if (err) {
                      AWS2.endpointCache.put(cacheKey, [{
                        Address: "",
                        CachePeriodInMinutes: 1
                        //not to make more endpoint operation in next 1 minute
                      }]);
                    }
                  });
                }
              }
              var requestQueue = {};
              function requiredDiscoverEndpoint(request, done) {
                var service = request.service;
                var api = service.api;
                var operationModel = api.operations ? api.operations[request.operation] : void 0;
                var inputShape = operationModel ? operationModel.input : void 0;
                var identifiers = marshallCustomIdentifiers(request, inputShape);
                var cacheKey = getCacheKey(request);
                if (Object.keys(identifiers).length > 0) {
                  cacheKey = util.update(cacheKey, identifiers);
                  if (operationModel)
                    cacheKey.operation = operationModel.name;
                }
                var cacheKeyStr = AWS2.EndpointCache.getKeyString(cacheKey);
                var endpoints = AWS2.endpointCache.get(cacheKeyStr);
                if (endpoints && endpoints.length === 1 && endpoints[0].Address === "") {
                  if (!requestQueue[cacheKeyStr])
                    requestQueue[cacheKeyStr] = [];
                  requestQueue[cacheKeyStr].push({ request, callback: done });
                  return;
                } else if (endpoints && endpoints.length > 0) {
                  request.httpRequest.updateEndpoint(endpoints[0].Address);
                  done();
                } else {
                  var endpointRequest = service.makeRequest(api.endpointOperation, {
                    Operation: operationModel.name,
                    Identifiers: identifiers
                  });
                  endpointRequest.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_PARAMETERS);
                  addApiVersionHeader(endpointRequest);
                  AWS2.endpointCache.put(cacheKeyStr, [{
                    Address: "",
                    CachePeriodInMinutes: 60
                    //long-live cache
                  }]);
                  endpointRequest.send(function(err, data) {
                    if (err) {
                      request.response.error = util.error(err, { retryable: false });
                      AWS2.endpointCache.remove(cacheKey);
                      if (requestQueue[cacheKeyStr]) {
                        var pendingRequests = requestQueue[cacheKeyStr];
                        util.arrayEach(pendingRequests, function(requestContext) {
                          requestContext.request.response.error = util.error(err, { retryable: false });
                          requestContext.callback();
                        });
                        delete requestQueue[cacheKeyStr];
                      }
                    } else if (data) {
                      AWS2.endpointCache.put(cacheKeyStr, data.Endpoints);
                      request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                      if (requestQueue[cacheKeyStr]) {
                        var pendingRequests = requestQueue[cacheKeyStr];
                        util.arrayEach(pendingRequests, function(requestContext) {
                          requestContext.request.httpRequest.updateEndpoint(data.Endpoints[0].Address);
                          requestContext.callback();
                        });
                        delete requestQueue[cacheKeyStr];
                      }
                    }
                    done();
                  });
                }
              }
              function addApiVersionHeader(endpointRequest) {
                var api = endpointRequest.service.api;
                var apiVersion = api.apiVersion;
                if (apiVersion && !endpointRequest.httpRequest.headers["x-amz-api-version"]) {
                  endpointRequest.httpRequest.headers["x-amz-api-version"] = apiVersion;
                }
              }
              function invalidateCachedEndpoints(response) {
                var error = response.error;
                var httpResponse = response.httpResponse;
                if (error && (error.code === "InvalidEndpointException" || httpResponse.statusCode === 421)) {
                  var request = response.request;
                  var operations = request.service.api.operations || {};
                  var inputShape = operations[request.operation] ? operations[request.operation].input : void 0;
                  var identifiers = marshallCustomIdentifiers(request, inputShape);
                  var cacheKey = getCacheKey(request);
                  if (Object.keys(identifiers).length > 0) {
                    cacheKey = util.update(cacheKey, identifiers);
                    if (operations[request.operation])
                      cacheKey.operation = operations[request.operation].name;
                  }
                  AWS2.endpointCache.remove(cacheKey);
                }
              }
              function hasCustomEndpoint(client) {
                if (client._originalConfig && client._originalConfig.endpoint && client._originalConfig.endpointDiscoveryEnabled === true) {
                  throw util.error(new Error(), {
                    code: "ConfigurationException",
                    message: "Custom endpoint is supplied; endpointDiscoveryEnabled must not be true."
                  });
                }
                ;
                var svcConfig = AWS2.config[client.serviceIdentifier] || {};
                return Boolean(AWS2.config.endpoint || svcConfig.endpoint || client._originalConfig && client._originalConfig.endpoint);
              }
              function isFalsy(value) {
                return ["false", "0"].indexOf(value) >= 0;
              }
              function resolveEndpointDiscoveryConfig(request) {
                var service = request.service || {};
                if (service.config.endpointDiscoveryEnabled !== void 0) {
                  return service.config.endpointDiscoveryEnabled;
                }
                if (util.isBrowser())
                  return void 0;
                for (var i = 0; i < endpointDiscoveryEnabledEnvs.length; i++) {
                  var env = endpointDiscoveryEnabledEnvs[i];
                  if (Object.prototype.hasOwnProperty.call(process.env, env)) {
                    if (process.env[env] === "" || process.env[env] === void 0) {
                      throw util.error(new Error(), {
                        code: "ConfigurationException",
                        message: "environmental variable " + env + " cannot be set to nothing"
                      });
                    }
                    return !isFalsy(process.env[env]);
                  }
                }
                var configFile = {};
                try {
                  configFile = AWS2.util.iniLoader ? AWS2.util.iniLoader.loadFrom({
                    isConfig: true,
                    filename: process.env[AWS2.util.sharedConfigFileEnv]
                  }) : {};
                } catch (e) {
                }
                var sharedFileConfig = configFile[process.env.AWS_PROFILE || AWS2.util.defaultProfile] || {};
                if (Object.prototype.hasOwnProperty.call(sharedFileConfig, "endpoint_discovery_enabled")) {
                  if (sharedFileConfig.endpoint_discovery_enabled === void 0) {
                    throw util.error(new Error(), {
                      code: "ConfigurationException",
                      message: "config file entry 'endpoint_discovery_enabled' cannot be set to nothing"
                    });
                  }
                  return !isFalsy(sharedFileConfig.endpoint_discovery_enabled);
                }
                return void 0;
              }
              function discoverEndpoint(request, done) {
                var service = request.service || {};
                if (hasCustomEndpoint(service) || request.isPresigned())
                  return done();
                var operations = service.api.operations || {};
                var operationModel = operations[request.operation];
                var isEndpointDiscoveryRequired = operationModel ? operationModel.endpointDiscoveryRequired : "NULL";
                var isEnabled = resolveEndpointDiscoveryConfig(request);
                var hasRequiredEndpointDiscovery = service.api.hasRequiredEndpointDiscovery;
                if (isEnabled || hasRequiredEndpointDiscovery) {
                  request.httpRequest.appendToUserAgent("endpoint-discovery");
                }
                switch (isEndpointDiscoveryRequired) {
                  case "OPTIONAL":
                    if (isEnabled || hasRequiredEndpointDiscovery) {
                      optionalDiscoverEndpoint(request);
                      request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
                    }
                    done();
                    break;
                  case "REQUIRED":
                    if (isEnabled === false) {
                      request.response.error = util.error(new Error(), {
                        code: "ConfigurationException",
                        message: "Endpoint Discovery is disabled but " + service.api.className + "." + request.operation + "() requires it. Please check your configurations."
                      });
                      done();
                      break;
                    }
                    request.addNamedListener("INVALIDATE_CACHED_ENDPOINTS", "extractError", invalidateCachedEndpoints);
                    requiredDiscoverEndpoint(request, done);
                    break;
                  case "NULL":
                  default:
                    done();
                    break;
                }
              }
              module2.exports = {
                discoverEndpoint,
                requiredDiscoverEndpoint,
                optionalDiscoverEndpoint,
                marshallCustomIdentifiers,
                getCacheKey,
                invalidateCachedEndpoint: invalidateCachedEndpoints
              };
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./core": 19, "./util": 74, "_process": 91 }], 28: [function(require2, module2, exports2) {
          var eventMessageChunker = require2("../event-stream/event-message-chunker").eventMessageChunker;
          var parseEvent = require2("./parse-event").parseEvent;
          function createEventStream(body, parser, model) {
            var eventMessages = eventMessageChunker(body);
            var events = [];
            for (var i = 0; i < eventMessages.length; i++) {
              events.push(parseEvent(parser, eventMessages[i], model));
            }
            return events;
          }
          module2.exports = {
            createEventStream
          };
        }, { "../event-stream/event-message-chunker": 29, "./parse-event": 31 }], 29: [function(require2, module2, exports2) {
          function eventMessageChunker(buffer) {
            var messages = [];
            var offset = 0;
            while (offset < buffer.length) {
              var totalLength = buffer.readInt32BE(offset);
              var message = buffer.slice(offset, totalLength + offset);
              offset += totalLength;
              messages.push(message);
            }
            return messages;
          }
          module2.exports = {
            eventMessageChunker
          };
        }, {}], 30: [function(require2, module2, exports2) {
          var util = require2("../core").util;
          var toBuffer = util.buffer.toBuffer;
          function Int64(bytes) {
            if (bytes.length !== 8) {
              throw new Error("Int64 buffers must be exactly 8 bytes");
            }
            if (!util.Buffer.isBuffer(bytes))
              bytes = toBuffer(bytes);
            this.bytes = bytes;
          }
          Int64.fromNumber = function(number) {
            if (number > 9223372036854776e3 || number < -9223372036854776e3) {
              throw new Error(
                number + " is too large (or, if negative, too small) to represent as an Int64"
              );
            }
            var bytes = new Uint8Array(8);
            for (var i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256) {
              bytes[i] = remaining;
            }
            if (number < 0) {
              negate(bytes);
            }
            return new Int64(bytes);
          };
          Int64.prototype.valueOf = function() {
            var bytes = this.bytes.slice(0);
            var negative = bytes[0] & 128;
            if (negative) {
              negate(bytes);
            }
            return parseInt(bytes.toString("hex"), 16) * (negative ? -1 : 1);
          };
          Int64.prototype.toString = function() {
            return String(this.valueOf());
          };
          function negate(bytes) {
            for (var i = 0; i < 8; i++) {
              bytes[i] ^= 255;
            }
            for (var i = 7; i > -1; i--) {
              bytes[i]++;
              if (bytes[i] !== 0) {
                break;
              }
            }
          }
          module2.exports = {
            Int64
          };
        }, { "../core": 19 }], 31: [function(require2, module2, exports2) {
          var parseMessage = require2("./parse-message").parseMessage;
          function parseEvent(parser, message, shape) {
            var parsedMessage = parseMessage(message);
            var messageType = parsedMessage.headers[":message-type"];
            if (messageType) {
              if (messageType.value === "error") {
                throw parseError(parsedMessage);
              } else if (messageType.value !== "event") {
                return;
              }
            }
            var eventType = parsedMessage.headers[":event-type"];
            var eventModel = shape.members[eventType.value];
            if (!eventModel) {
              return;
            }
            var result = {};
            var eventPayloadMemberName = eventModel.eventPayloadMemberName;
            if (eventPayloadMemberName) {
              var payloadShape = eventModel.members[eventPayloadMemberName];
              if (payloadShape.type === "binary") {
                result[eventPayloadMemberName] = parsedMessage.body;
              } else {
                result[eventPayloadMemberName] = parser.parse(parsedMessage.body.toString(), payloadShape);
              }
            }
            var eventHeaderNames = eventModel.eventHeaderMemberNames;
            for (var i = 0; i < eventHeaderNames.length; i++) {
              var name = eventHeaderNames[i];
              if (parsedMessage.headers[name]) {
                result[name] = eventModel.members[name].toType(parsedMessage.headers[name].value);
              }
            }
            var output = {};
            output[eventType.value] = result;
            return output;
          }
          function parseError(message) {
            var errorCode = message.headers[":error-code"];
            var errorMessage = message.headers[":error-message"];
            var error = new Error(errorMessage.value || errorMessage);
            error.code = error.name = errorCode.value || errorCode;
            return error;
          }
          module2.exports = {
            parseEvent
          };
        }, { "./parse-message": 32 }], 32: [function(require2, module2, exports2) {
          var Int64 = require2("./int64").Int64;
          var splitMessage = require2("./split-message").splitMessage;
          var BOOLEAN_TAG = "boolean";
          var BYTE_TAG = "byte";
          var SHORT_TAG = "short";
          var INT_TAG = "integer";
          var LONG_TAG = "long";
          var BINARY_TAG = "binary";
          var STRING_TAG = "string";
          var TIMESTAMP_TAG = "timestamp";
          var UUID_TAG = "uuid";
          function parseHeaders(headers) {
            var out = {};
            var position = 0;
            while (position < headers.length) {
              var nameLength = headers.readUInt8(position++);
              var name = headers.slice(position, position + nameLength).toString();
              position += nameLength;
              switch (headers.readUInt8(position++)) {
                case 0:
                  out[name] = {
                    type: BOOLEAN_TAG,
                    value: true
                  };
                  break;
                case 1:
                  out[name] = {
                    type: BOOLEAN_TAG,
                    value: false
                  };
                  break;
                case 2:
                  out[name] = {
                    type: BYTE_TAG,
                    value: headers.readInt8(position++)
                  };
                  break;
                case 3:
                  out[name] = {
                    type: SHORT_TAG,
                    value: headers.readInt16BE(position)
                  };
                  position += 2;
                  break;
                case 4:
                  out[name] = {
                    type: INT_TAG,
                    value: headers.readInt32BE(position)
                  };
                  position += 4;
                  break;
                case 5:
                  out[name] = {
                    type: LONG_TAG,
                    value: new Int64(headers.slice(position, position + 8))
                  };
                  position += 8;
                  break;
                case 6:
                  var binaryLength = headers.readUInt16BE(position);
                  position += 2;
                  out[name] = {
                    type: BINARY_TAG,
                    value: headers.slice(position, position + binaryLength)
                  };
                  position += binaryLength;
                  break;
                case 7:
                  var stringLength = headers.readUInt16BE(position);
                  position += 2;
                  out[name] = {
                    type: STRING_TAG,
                    value: headers.slice(
                      position,
                      position + stringLength
                    ).toString()
                  };
                  position += stringLength;
                  break;
                case 8:
                  out[name] = {
                    type: TIMESTAMP_TAG,
                    value: new Date(
                      new Int64(headers.slice(position, position + 8)).valueOf()
                    )
                  };
                  position += 8;
                  break;
                case 9:
                  var uuidChars = headers.slice(position, position + 16).toString("hex");
                  position += 16;
                  out[name] = {
                    type: UUID_TAG,
                    value: uuidChars.substr(0, 8) + "-" + uuidChars.substr(8, 4) + "-" + uuidChars.substr(12, 4) + "-" + uuidChars.substr(16, 4) + "-" + uuidChars.substr(20)
                  };
                  break;
                default:
                  throw new Error("Unrecognized header type tag");
              }
            }
            return out;
          }
          function parseMessage(message) {
            var parsed = splitMessage(message);
            return { headers: parseHeaders(parsed.headers), body: parsed.body };
          }
          module2.exports = {
            parseMessage
          };
        }, { "./int64": 30, "./split-message": 33 }], 33: [function(require2, module2, exports2) {
          var util = require2("../core").util;
          var toBuffer = util.buffer.toBuffer;
          var PRELUDE_MEMBER_LENGTH = 4;
          var PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
          var CHECKSUM_LENGTH = 4;
          var MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
          function splitMessage(message) {
            if (!util.Buffer.isBuffer(message))
              message = toBuffer(message);
            if (message.length < MINIMUM_MESSAGE_LENGTH) {
              throw new Error("Provided message too short to accommodate event stream message overhead");
            }
            if (message.length !== message.readUInt32BE(0)) {
              throw new Error("Reported message length does not match received message length");
            }
            var expectedPreludeChecksum = message.readUInt32BE(PRELUDE_LENGTH);
            if (expectedPreludeChecksum !== util.crypto.crc32(
              message.slice(0, PRELUDE_LENGTH)
            )) {
              throw new Error(
                "The prelude checksum specified in the message (" + expectedPreludeChecksum + ") does not match the calculated CRC32 checksum."
              );
            }
            var expectedMessageChecksum = message.readUInt32BE(message.length - CHECKSUM_LENGTH);
            if (expectedMessageChecksum !== util.crypto.crc32(
              message.slice(0, message.length - CHECKSUM_LENGTH)
            )) {
              throw new Error(
                "The message checksum did not match the expected value of " + expectedMessageChecksum
              );
            }
            var headersStart = PRELUDE_LENGTH + CHECKSUM_LENGTH;
            var headersEnd = headersStart + message.readUInt32BE(PRELUDE_MEMBER_LENGTH);
            return {
              headers: message.slice(headersStart, headersEnd),
              body: message.slice(headersEnd, message.length - CHECKSUM_LENGTH)
            };
          }
          module2.exports = {
            splitMessage
          };
        }, { "../core": 19 }], 34: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var AWS2 = require2("./core");
              var SequentialExecutor = require2("./sequential_executor");
              var DISCOVER_ENDPOINT = require2("./discover_endpoint").discoverEndpoint;
              AWS2.EventListeners = {
                /**
                 * @!attribute VALIDATE_CREDENTIALS
                 *   A request listener that validates whether the request is being
                 *   sent with credentials.
                 *   Handles the {AWS.Request~validate 'validate' Request event}
                 *   @example Sending a request without validating credentials
                 *     var listener = AWS.EventListeners.Core.VALIDATE_CREDENTIALS;
                 *     request.removeListener('validate', listener);
                 *   @readonly
                 *   @return [Function]
                 * @!attribute VALIDATE_REGION
                 *   A request listener that validates whether the region is set
                 *   for a request.
                 *   Handles the {AWS.Request~validate 'validate' Request event}
                 *   @example Sending a request without validating region configuration
                 *     var listener = AWS.EventListeners.Core.VALIDATE_REGION;
                 *     request.removeListener('validate', listener);
                 *   @readonly
                 *   @return [Function]
                 * @!attribute VALIDATE_PARAMETERS
                 *   A request listener that validates input parameters in a request.
                 *   Handles the {AWS.Request~validate 'validate' Request event}
                 *   @example Sending a request without validating parameters
                 *     var listener = AWS.EventListeners.Core.VALIDATE_PARAMETERS;
                 *     request.removeListener('validate', listener);
                 *   @example Disable parameter validation globally
                 *     AWS.EventListeners.Core.removeListener('validate',
                 *       AWS.EventListeners.Core.VALIDATE_REGION);
                 *   @readonly
                 *   @return [Function]
                 * @!attribute SEND
                 *   A request listener that initiates the HTTP connection for a
                 *   request being sent. Handles the {AWS.Request~send 'send' Request event}
                 *   @example Replacing the HTTP handler
                 *     var listener = AWS.EventListeners.Core.SEND;
                 *     request.removeListener('send', listener);
                 *     request.on('send', function(response) {
                 *       customHandler.send(response);
                 *     });
                 *   @return [Function]
                 *   @readonly
                 * @!attribute HTTP_DATA
                 *   A request listener that reads data from the HTTP connection in order
                 *   to build the response data.
                 *   Handles the {AWS.Request~httpData 'httpData' Request event}.
                 *   Remove this handler if you are overriding the 'httpData' event and
                 *   do not want extra data processing and buffering overhead.
                 *   @example Disabling default data processing
                 *     var listener = AWS.EventListeners.Core.HTTP_DATA;
                 *     request.removeListener('httpData', listener);
                 *   @return [Function]
                 *   @readonly
                 */
                Core: {}
                /* doc hack */
              };
              function getOperationAuthtype(req) {
                if (!req.service.api.operations) {
                  return "";
                }
                var operation = req.service.api.operations[req.operation];
                return operation ? operation.authtype : "";
              }
              function getIdentityType(req) {
                var service = req.service;
                if (service.config.signatureVersion) {
                  return service.config.signatureVersion;
                }
                if (service.api.signatureVersion) {
                  return service.api.signatureVersion;
                }
                return getOperationAuthtype(req);
              }
              AWS2.EventListeners = {
                Core: new SequentialExecutor().addNamedListeners(function(add, addAsync) {
                  addAsync(
                    "VALIDATE_CREDENTIALS",
                    "validate",
                    function VALIDATE_CREDENTIALS(req, done) {
                      if (!req.service.api.signatureVersion && !req.service.config.signatureVersion)
                        return done();
                      var identityType = getIdentityType(req);
                      if (identityType === "bearer") {
                        req.service.config.getToken(function(err) {
                          if (err) {
                            req.response.error = AWS2.util.error(err, { code: "TokenError" });
                          }
                          done();
                        });
                        return;
                      }
                      req.service.config.getCredentials(function(err) {
                        if (err) {
                          req.response.error = AWS2.util.error(
                            err,
                            {
                              code: "CredentialsError",
                              message: "Missing credentials in config, if using AWS_CONFIG_FILE, set AWS_SDK_LOAD_CONFIG=1"
                            }
                          );
                        }
                        done();
                      });
                    }
                  );
                  add("VALIDATE_REGION", "validate", function VALIDATE_REGION(req) {
                    if (!req.service.isGlobalEndpoint) {
                      var dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
                      if (!req.service.config.region) {
                        req.response.error = AWS2.util.error(
                          new Error(),
                          { code: "ConfigError", message: "Missing region in config" }
                        );
                      } else if (!dnsHostRegex.test(req.service.config.region)) {
                        req.response.error = AWS2.util.error(
                          new Error(),
                          { code: "ConfigError", message: "Invalid region in config" }
                        );
                      }
                    }
                  });
                  add("BUILD_IDEMPOTENCY_TOKENS", "validate", function BUILD_IDEMPOTENCY_TOKENS(req) {
                    if (!req.service.api.operations) {
                      return;
                    }
                    var operation = req.service.api.operations[req.operation];
                    if (!operation) {
                      return;
                    }
                    var idempotentMembers = operation.idempotentMembers;
                    if (!idempotentMembers.length) {
                      return;
                    }
                    var params = AWS2.util.copy(req.params);
                    for (var i = 0, iLen = idempotentMembers.length; i < iLen; i++) {
                      if (!params[idempotentMembers[i]]) {
                        params[idempotentMembers[i]] = AWS2.util.uuid.v4();
                      }
                    }
                    req.params = params;
                  });
                  add("VALIDATE_PARAMETERS", "validate", function VALIDATE_PARAMETERS(req) {
                    if (!req.service.api.operations) {
                      return;
                    }
                    var rules = req.service.api.operations[req.operation].input;
                    var validation = req.service.config.paramValidation;
                    new AWS2.ParamValidator(validation).validate(rules, req.params);
                  });
                  add("COMPUTE_CHECKSUM", "afterBuild", function COMPUTE_CHECKSUM(req) {
                    if (!req.service.api.operations) {
                      return;
                    }
                    var operation = req.service.api.operations[req.operation];
                    if (!operation) {
                      return;
                    }
                    var body = req.httpRequest.body;
                    var isNonStreamingPayload = body && (AWS2.util.Buffer.isBuffer(body) || typeof body === "string");
                    var headers = req.httpRequest.headers;
                    if (operation.httpChecksumRequired && req.service.config.computeChecksums && isNonStreamingPayload && !headers["Content-MD5"]) {
                      var md52 = AWS2.util.crypto.md5(body, "base64");
                      headers["Content-MD5"] = md52;
                    }
                  });
                  addAsync("COMPUTE_SHA256", "afterBuild", function COMPUTE_SHA256(req, done) {
                    req.haltHandlersOnError();
                    if (!req.service.api.operations) {
                      return;
                    }
                    var operation = req.service.api.operations[req.operation];
                    var authtype = operation ? operation.authtype : "";
                    if (!req.service.api.signatureVersion && !authtype && !req.service.config.signatureVersion)
                      return done();
                    if (req.service.getSignerClass(req) === AWS2.Signers.V4) {
                      var body = req.httpRequest.body || "";
                      if (authtype.indexOf("unsigned-body") >= 0) {
                        req.httpRequest.headers["X-Amz-Content-Sha256"] = "UNSIGNED-PAYLOAD";
                        return done();
                      }
                      AWS2.util.computeSha256(body, function(err, sha) {
                        if (err) {
                          done(err);
                        } else {
                          req.httpRequest.headers["X-Amz-Content-Sha256"] = sha;
                          done();
                        }
                      });
                    } else {
                      done();
                    }
                  });
                  add("SET_CONTENT_LENGTH", "afterBuild", function SET_CONTENT_LENGTH(req) {
                    var authtype = getOperationAuthtype(req);
                    var payloadMember = AWS2.util.getRequestPayloadShape(req);
                    if (req.httpRequest.headers["Content-Length"] === void 0) {
                      try {
                        var length = AWS2.util.string.byteLength(req.httpRequest.body);
                        req.httpRequest.headers["Content-Length"] = length;
                      } catch (err) {
                        if (payloadMember && payloadMember.isStreaming) {
                          if (payloadMember.requiresLength) {
                            throw err;
                          } else if (authtype.indexOf("unsigned-body") >= 0) {
                            req.httpRequest.headers["Transfer-Encoding"] = "chunked";
                            return;
                          } else {
                            throw err;
                          }
                        }
                        throw err;
                      }
                    }
                  });
                  add("SET_HTTP_HOST", "afterBuild", function SET_HTTP_HOST(req) {
                    req.httpRequest.headers["Host"] = req.httpRequest.endpoint.host;
                  });
                  add("SET_TRACE_ID", "afterBuild", function SET_TRACE_ID(req) {
                    var traceIdHeaderName = "X-Amzn-Trace-Id";
                    if (AWS2.util.isNode() && !Object.hasOwnProperty.call(req.httpRequest.headers, traceIdHeaderName)) {
                      var ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
                      var ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
                      var functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
                      var traceId = process.env[ENV_TRACE_ID];
                      if (typeof functionName === "string" && functionName.length > 0 && typeof traceId === "string" && traceId.length > 0) {
                        req.httpRequest.headers[traceIdHeaderName] = traceId;
                      }
                    }
                  });
                  add("RESTART", "restart", function RESTART() {
                    var err = this.response.error;
                    if (!err || !err.retryable)
                      return;
                    this.httpRequest = new AWS2.HttpRequest(
                      this.service.endpoint,
                      this.service.region
                    );
                    if (this.response.retryCount < this.service.config.maxRetries) {
                      this.response.retryCount++;
                    } else {
                      this.response.error = null;
                    }
                  });
                  var addToHead = true;
                  addAsync("DISCOVER_ENDPOINT", "sign", DISCOVER_ENDPOINT, addToHead);
                  addAsync("SIGN", "sign", function SIGN(req, done) {
                    var service = req.service;
                    var identityType = getIdentityType(req);
                    if (!identityType || identityType.length === 0)
                      return done();
                    if (identityType === "bearer") {
                      service.config.getToken(function(err, token) {
                        if (err) {
                          req.response.error = err;
                          return done();
                        }
                        try {
                          var SignerClass = service.getSignerClass(req);
                          var signer = new SignerClass(req.httpRequest);
                          signer.addAuthorization(token);
                        } catch (e) {
                          req.response.error = e;
                        }
                        done();
                      });
                    } else {
                      service.config.getCredentials(function(err, credentials) {
                        if (err) {
                          req.response.error = err;
                          return done();
                        }
                        try {
                          var date = service.getSkewCorrectedDate();
                          var SignerClass = service.getSignerClass(req);
                          var operations = req.service.api.operations || {};
                          var operation = operations[req.operation];
                          var signer = new SignerClass(
                            req.httpRequest,
                            service.getSigningName(req),
                            {
                              signatureCache: service.config.signatureCache,
                              operation,
                              signatureVersion: service.api.signatureVersion
                            }
                          );
                          signer.setServiceClientId(service._clientId);
                          delete req.httpRequest.headers["Authorization"];
                          delete req.httpRequest.headers["Date"];
                          delete req.httpRequest.headers["X-Amz-Date"];
                          signer.addAuthorization(credentials, date);
                          req.signedAt = date;
                        } catch (e) {
                          req.response.error = e;
                        }
                        done();
                      });
                    }
                  });
                  add("VALIDATE_RESPONSE", "validateResponse", function VALIDATE_RESPONSE(resp) {
                    if (this.service.successfulResponse(resp, this)) {
                      resp.data = {};
                      resp.error = null;
                    } else {
                      resp.data = null;
                      resp.error = AWS2.util.error(
                        new Error(),
                        { code: "UnknownError", message: "An unknown error occurred." }
                      );
                    }
                  });
                  add("ERROR", "error", function ERROR(err, resp) {
                    var awsQueryCompatible = resp.request.service.api.awsQueryCompatible;
                    if (awsQueryCompatible) {
                      var headers = resp.httpResponse.headers;
                      var queryErrorCode = headers ? headers["x-amzn-query-error"] : void 0;
                      if (queryErrorCode && queryErrorCode.includes(";")) {
                        resp.error.code = queryErrorCode.split(";")[0];
                      }
                    }
                  }, true);
                  addAsync("SEND", "send", function SEND(resp, done) {
                    resp.httpResponse._abortCallback = done;
                    resp.error = null;
                    resp.data = null;
                    function callback(httpResp) {
                      resp.httpResponse.stream = httpResp;
                      var stream = resp.request.httpRequest.stream;
                      var service = resp.request.service;
                      var api = service.api;
                      var operationName = resp.request.operation;
                      var operation = api.operations[operationName] || {};
                      httpResp.on("headers", function onHeaders(statusCode, headers, statusMessage) {
                        resp.request.emit(
                          "httpHeaders",
                          [statusCode, headers, resp, statusMessage]
                        );
                        if (!resp.httpResponse.streaming) {
                          if (AWS2.HttpClient.streamsApiVersion === 2) {
                            if (operation.hasEventOutput && service.successfulResponse(resp)) {
                              resp.request.emit("httpDone");
                              done();
                              return;
                            }
                            httpResp.on("readable", function onReadable() {
                              var data = httpResp.read();
                              if (data !== null) {
                                resp.request.emit("httpData", [data, resp]);
                              }
                            });
                          } else {
                            httpResp.on("data", function onData(data) {
                              resp.request.emit("httpData", [data, resp]);
                            });
                          }
                        }
                      });
                      httpResp.on("end", function onEnd() {
                        if (!stream || !stream.didCallback) {
                          if (AWS2.HttpClient.streamsApiVersion === 2 && (operation.hasEventOutput && service.successfulResponse(resp))) {
                            return;
                          }
                          resp.request.emit("httpDone");
                          done();
                        }
                      });
                    }
                    function progress(httpResp) {
                      httpResp.on("sendProgress", function onSendProgress(value) {
                        resp.request.emit("httpUploadProgress", [value, resp]);
                      });
                      httpResp.on("receiveProgress", function onReceiveProgress(value) {
                        resp.request.emit("httpDownloadProgress", [value, resp]);
                      });
                    }
                    function error(err) {
                      if (err.code !== "RequestAbortedError") {
                        var errCode = err.code === "TimeoutError" ? err.code : "NetworkingError";
                        err = AWS2.util.error(err, {
                          code: errCode,
                          region: resp.request.httpRequest.region,
                          hostname: resp.request.httpRequest.endpoint.hostname,
                          retryable: true
                        });
                      }
                      resp.error = err;
                      resp.request.emit("httpError", [resp.error, resp], function() {
                        done();
                      });
                    }
                    function executeSend() {
                      var http = AWS2.HttpClient.getInstance();
                      var httpOptions = resp.request.service.config.httpOptions || {};
                      try {
                        var stream = http.handleRequest(
                          resp.request.httpRequest,
                          httpOptions,
                          callback,
                          error
                        );
                        progress(stream);
                      } catch (err) {
                        error(err);
                      }
                    }
                    var timeDiff = (resp.request.service.getSkewCorrectedDate() - this.signedAt) / 1e3;
                    if (timeDiff >= 60 * 10) {
                      this.emit("sign", [this], function(err) {
                        if (err)
                          done(err);
                        else
                          executeSend();
                      });
                    } else {
                      executeSend();
                    }
                  });
                  add(
                    "HTTP_HEADERS",
                    "httpHeaders",
                    function HTTP_HEADERS(statusCode, headers, resp, statusMessage) {
                      resp.httpResponse.statusCode = statusCode;
                      resp.httpResponse.statusMessage = statusMessage;
                      resp.httpResponse.headers = headers;
                      resp.httpResponse.body = AWS2.util.buffer.toBuffer("");
                      resp.httpResponse.buffers = [];
                      resp.httpResponse.numBytes = 0;
                      var dateHeader = headers.date || headers.Date;
                      var service = resp.request.service;
                      if (dateHeader) {
                        var serverTime = Date.parse(dateHeader);
                        if (service.config.correctClockSkew && service.isClockSkewed(serverTime)) {
                          service.applyClockOffset(serverTime);
                        }
                      }
                    }
                  );
                  add("HTTP_DATA", "httpData", function HTTP_DATA(chunk, resp) {
                    if (chunk) {
                      if (AWS2.util.isNode()) {
                        resp.httpResponse.numBytes += chunk.length;
                        var total = resp.httpResponse.headers["content-length"];
                        var progress = { loaded: resp.httpResponse.numBytes, total };
                        resp.request.emit("httpDownloadProgress", [progress, resp]);
                      }
                      resp.httpResponse.buffers.push(AWS2.util.buffer.toBuffer(chunk));
                    }
                  });
                  add("HTTP_DONE", "httpDone", function HTTP_DONE(resp) {
                    if (resp.httpResponse.buffers && resp.httpResponse.buffers.length > 0) {
                      var body = AWS2.util.buffer.concat(resp.httpResponse.buffers);
                      resp.httpResponse.body = body;
                    }
                    delete resp.httpResponse.numBytes;
                    delete resp.httpResponse.buffers;
                  });
                  add("FINALIZE_ERROR", "retry", function FINALIZE_ERROR(resp) {
                    if (resp.httpResponse.statusCode) {
                      resp.error.statusCode = resp.httpResponse.statusCode;
                      if (resp.error.retryable === void 0) {
                        resp.error.retryable = this.service.retryableError(resp.error, this);
                      }
                    }
                  });
                  add("INVALIDATE_CREDENTIALS", "retry", function INVALIDATE_CREDENTIALS(resp) {
                    if (!resp.error)
                      return;
                    switch (resp.error.code) {
                      case "RequestExpired":
                      case "ExpiredTokenException":
                      case "ExpiredToken":
                        resp.error.retryable = true;
                        resp.request.service.config.credentials.expired = true;
                    }
                  });
                  add("EXPIRED_SIGNATURE", "retry", function EXPIRED_SIGNATURE(resp) {
                    var err = resp.error;
                    if (!err)
                      return;
                    if (typeof err.code === "string" && typeof err.message === "string") {
                      if (err.code.match(/Signature/) && err.message.match(/expired/)) {
                        resp.error.retryable = true;
                      }
                    }
                  });
                  add("CLOCK_SKEWED", "retry", function CLOCK_SKEWED(resp) {
                    if (!resp.error)
                      return;
                    if (this.service.clockSkewError(resp.error) && this.service.config.correctClockSkew) {
                      resp.error.retryable = true;
                    }
                  });
                  add("REDIRECT", "retry", function REDIRECT(resp) {
                    if (resp.error && resp.error.statusCode >= 300 && resp.error.statusCode < 400 && resp.httpResponse.headers["location"]) {
                      this.httpRequest.endpoint = new AWS2.Endpoint(resp.httpResponse.headers["location"]);
                      this.httpRequest.headers["Host"] = this.httpRequest.endpoint.host;
                      resp.error.redirect = true;
                      resp.error.retryable = true;
                    }
                  });
                  add("RETRY_CHECK", "retry", function RETRY_CHECK(resp) {
                    if (resp.error) {
                      if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
                        resp.error.retryDelay = 0;
                      } else if (resp.retryCount < resp.maxRetries) {
                        resp.error.retryDelay = this.service.retryDelays(resp.retryCount, resp.error) || 0;
                      }
                    }
                  });
                  addAsync("RESET_RETRY_STATE", "afterRetry", function RESET_RETRY_STATE(resp, done) {
                    var delay, willRetry = false;
                    if (resp.error) {
                      delay = resp.error.retryDelay || 0;
                      if (resp.error.retryable && resp.retryCount < resp.maxRetries) {
                        resp.retryCount++;
                        willRetry = true;
                      } else if (resp.error.redirect && resp.redirectCount < resp.maxRedirects) {
                        resp.redirectCount++;
                        willRetry = true;
                      }
                    }
                    if (willRetry && delay >= 0) {
                      resp.error = null;
                      setTimeout(done, delay);
                    } else {
                      done();
                    }
                  });
                }),
                CorePost: new SequentialExecutor().addNamedListeners(function(add) {
                  add("EXTRACT_REQUEST_ID", "extractData", AWS2.util.extractRequestId);
                  add("EXTRACT_REQUEST_ID", "extractError", AWS2.util.extractRequestId);
                  add("ENOTFOUND_ERROR", "httpError", function ENOTFOUND_ERROR(err) {
                    function isDNSError(err2) {
                      return err2.errno === "ENOTFOUND" || typeof err2.errno === "number" && typeof AWS2.util.getSystemErrorName === "function" && ["EAI_NONAME", "EAI_NODATA"].indexOf(AWS2.util.getSystemErrorName(err2.errno) >= 0);
                    }
                    if (err.code === "NetworkingError" && isDNSError(err)) {
                      var message = "Inaccessible host: `" + err.hostname + "' at port `" + err.port + "'. This service may not be available in the `" + err.region + "' region.";
                      this.response.error = AWS2.util.error(new Error(message), {
                        code: "UnknownEndpoint",
                        region: err.region,
                        hostname: err.hostname,
                        retryable: true,
                        originalError: err
                      });
                    }
                  });
                }),
                Logger: new SequentialExecutor().addNamedListeners(function(add) {
                  add("LOG_REQUEST", "complete", function LOG_REQUEST(resp) {
                    var req = resp.request;
                    var logger = req.service.config.logger;
                    if (!logger)
                      return;
                    function filterSensitiveLog(inputShape, shape) {
                      if (!shape) {
                        return shape;
                      }
                      if (inputShape.isSensitive) {
                        return "***SensitiveInformation***";
                      }
                      switch (inputShape.type) {
                        case "structure":
                          var struct = {};
                          AWS2.util.each(shape, function(subShapeName, subShape) {
                            if (Object.prototype.hasOwnProperty.call(inputShape.members, subShapeName)) {
                              struct[subShapeName] = filterSensitiveLog(inputShape.members[subShapeName], subShape);
                            } else {
                              struct[subShapeName] = subShape;
                            }
                          });
                          return struct;
                        case "list":
                          var list = [];
                          AWS2.util.arrayEach(shape, function(subShape, index) {
                            list.push(filterSensitiveLog(inputShape.member, subShape));
                          });
                          return list;
                        case "map":
                          var map = {};
                          AWS2.util.each(shape, function(key, value) {
                            map[key] = filterSensitiveLog(inputShape.value, value);
                          });
                          return map;
                        default:
                          return shape;
                      }
                    }
                    function buildMessage() {
                      var time = resp.request.service.getSkewCorrectedDate().getTime();
                      var delta = (time - req.startTime.getTime()) / 1e3;
                      var ansi = logger.isTTY ? true : false;
                      var status = resp.httpResponse.statusCode;
                      var censoredParams = req.params;
                      if (req.service.api.operations && req.service.api.operations[req.operation] && req.service.api.operations[req.operation].input) {
                        var inputShape = req.service.api.operations[req.operation].input;
                        censoredParams = filterSensitiveLog(inputShape, req.params);
                      }
                      var params = require2("util").inspect(censoredParams, true, null);
                      var message = "";
                      if (ansi)
                        message += "\x1B[33m";
                      message += "[AWS " + req.service.serviceIdentifier + " " + status;
                      message += " " + delta.toString() + "s " + resp.retryCount + " retries]";
                      if (ansi)
                        message += "\x1B[0;1m";
                      message += " " + AWS2.util.string.lowerFirst(req.operation);
                      message += "(" + params + ")";
                      if (ansi)
                        message += "\x1B[0m";
                      return message;
                    }
                    var line = buildMessage();
                    if (typeof logger.log === "function") {
                      logger.log(line);
                    } else if (typeof logger.write === "function") {
                      logger.write(line + "\n");
                    }
                  });
                }),
                Json: new SequentialExecutor().addNamedListeners(function(add) {
                  var svc = require2("./protocol/json");
                  add("BUILD", "build", svc.buildRequest);
                  add("EXTRACT_DATA", "extractData", svc.extractData);
                  add("EXTRACT_ERROR", "extractError", svc.extractError);
                }),
                Rest: new SequentialExecutor().addNamedListeners(function(add) {
                  var svc = require2("./protocol/rest");
                  add("BUILD", "build", svc.buildRequest);
                  add("EXTRACT_DATA", "extractData", svc.extractData);
                  add("EXTRACT_ERROR", "extractError", svc.extractError);
                }),
                RestJson: new SequentialExecutor().addNamedListeners(function(add) {
                  var svc = require2("./protocol/rest_json");
                  add("BUILD", "build", svc.buildRequest);
                  add("EXTRACT_DATA", "extractData", svc.extractData);
                  add("EXTRACT_ERROR", "extractError", svc.extractError);
                  add("UNSET_CONTENT_LENGTH", "afterBuild", svc.unsetContentLength);
                }),
                RestXml: new SequentialExecutor().addNamedListeners(function(add) {
                  var svc = require2("./protocol/rest_xml");
                  add("BUILD", "build", svc.buildRequest);
                  add("EXTRACT_DATA", "extractData", svc.extractData);
                  add("EXTRACT_ERROR", "extractError", svc.extractError);
                }),
                Query: new SequentialExecutor().addNamedListeners(function(add) {
                  var svc = require2("./protocol/query");
                  add("BUILD", "build", svc.buildRequest);
                  add("EXTRACT_DATA", "extractData", svc.extractData);
                  add("EXTRACT_ERROR", "extractError", svc.extractError);
                })
              };
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./core": 19, "./discover_endpoint": 27, "./protocol/json": 48, "./protocol/query": 49, "./protocol/rest": 50, "./protocol/rest_json": 51, "./protocol/rest_xml": 52, "./sequential_executor": 61, "_process": 91, "util": 85 }], 35: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          var inherit = AWS2.util.inherit;
          AWS2.Endpoint = inherit({
            /**
             * @overload Endpoint(endpoint)
             *   Constructs a new endpoint given an endpoint URL. If the
             *   URL omits a protocol (http or https), the default protocol
             *   set in the global {AWS.config} will be used.
             *   @param endpoint [String] the URL to construct an endpoint from
             */
            constructor: function Endpoint(endpoint, config) {
              AWS2.util.hideProperties(this, ["slashes", "auth", "hash", "search", "query"]);
              if (typeof endpoint === "undefined" || endpoint === null) {
                throw new Error("Invalid endpoint: " + endpoint);
              } else if (typeof endpoint !== "string") {
                return AWS2.util.copy(endpoint);
              }
              if (!endpoint.match(/^http/)) {
                var useSSL = config && config.sslEnabled !== void 0 ? config.sslEnabled : AWS2.config.sslEnabled;
                endpoint = (useSSL ? "https" : "http") + "://" + endpoint;
              }
              AWS2.util.update(this, AWS2.util.urlParse(endpoint));
              if (this.port) {
                this.port = parseInt(this.port, 10);
              } else {
                this.port = this.protocol === "https:" ? 443 : 80;
              }
            }
          });
          AWS2.HttpRequest = inherit({
            /**
             * @api private
             */
            constructor: function HttpRequest(endpoint, region) {
              endpoint = new AWS2.Endpoint(endpoint);
              this.method = "POST";
              this.path = endpoint.path || "/";
              this.headers = {};
              this.body = "";
              this.endpoint = endpoint;
              this.region = region;
              this._userAgent = "";
              this.setUserAgent();
            },
            /**
             * @api private
             */
            setUserAgent: function setUserAgent() {
              this._userAgent = this.headers[this.getUserAgentHeaderName()] = AWS2.util.userAgent();
            },
            getUserAgentHeaderName: function getUserAgentHeaderName() {
              var prefix = AWS2.util.isBrowser() ? "X-Amz-" : "";
              return prefix + "User-Agent";
            },
            /**
             * @api private
             */
            appendToUserAgent: function appendToUserAgent(agentPartial) {
              if (typeof agentPartial === "string" && agentPartial) {
                this._userAgent += " " + agentPartial;
              }
              this.headers[this.getUserAgentHeaderName()] = this._userAgent;
            },
            /**
             * @api private
             */
            getUserAgent: function getUserAgent() {
              return this._userAgent;
            },
            /**
             * @return [String] the part of the {path} excluding the
             *   query string
             */
            pathname: function pathname() {
              return this.path.split("?", 1)[0];
            },
            /**
             * @return [String] the query string portion of the {path}
             */
            search: function search() {
              var query = this.path.split("?", 2)[1];
              if (query) {
                query = AWS2.util.queryStringParse(query);
                return AWS2.util.queryParamsToString(query);
              }
              return "";
            },
            /**
             * @api private
             * update httpRequest endpoint with endpoint string
             */
            updateEndpoint: function updateEndpoint(endpointStr) {
              var newEndpoint = new AWS2.Endpoint(endpointStr);
              this.endpoint = newEndpoint;
              this.path = newEndpoint.path || "/";
              if (this.headers["Host"]) {
                this.headers["Host"] = newEndpoint.host;
              }
            }
          });
          AWS2.HttpResponse = inherit({
            /**
             * @api private
             */
            constructor: function HttpResponse() {
              this.statusCode = void 0;
              this.headers = {};
              this.body = void 0;
              this.streaming = false;
              this.stream = null;
            },
            /**
             * Disables buffering on the HTTP response and returns the stream for reading.
             * @return [Stream, XMLHttpRequest, null] the underlying stream object.
             *   Use this object to directly read data off of the stream.
             * @note This object is only available after the {AWS.Request~httpHeaders}
             *   event has fired. This method must be called prior to
             *   {AWS.Request~httpData}.
             * @example Taking control of a stream
             *   request.on('httpHeaders', function(statusCode, headers) {
             *     if (statusCode < 300) {
             *       if (headers.etag === 'xyz') {
             *         // pipe the stream, disabling buffering
             *         var stream = this.response.httpResponse.createUnbufferedStream();
             *         stream.pipe(process.stdout);
             *       } else { // abort this request and set a better error message
             *         this.abort();
             *         this.response.error = new Error('Invalid ETag');
             *       }
             *     }
             *   }).send(console.log);
             */
            createUnbufferedStream: function createUnbufferedStream() {
              this.streaming = true;
              return this.stream;
            }
          });
          AWS2.HttpClient = inherit({});
          AWS2.HttpClient.getInstance = function getInstance() {
            if (this.singleton === void 0) {
              this.singleton = new this();
            }
            return this.singleton;
          };
        }, { "./core": 19 }], 36: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var EventEmitter = require2("events").EventEmitter;
          require2("../http");
          AWS2.XHRClient = AWS2.util.inherit({
            handleRequest: function handleRequest(httpRequest, httpOptions, callback, errCallback) {
              var self2 = this;
              var endpoint = httpRequest.endpoint;
              var emitter = new EventEmitter();
              var href = endpoint.protocol + "//" + endpoint.hostname;
              if (endpoint.port !== 80 && endpoint.port !== 443) {
                href += ":" + endpoint.port;
              }
              href += httpRequest.path;
              var xhr = new XMLHttpRequest(), headersEmitted = false;
              httpRequest.stream = xhr;
              xhr.addEventListener("readystatechange", function() {
                try {
                  if (xhr.status === 0)
                    return;
                } catch (e) {
                  return;
                }
                if (this.readyState >= this.HEADERS_RECEIVED && !headersEmitted) {
                  emitter.statusCode = xhr.status;
                  emitter.headers = self2.parseHeaders(xhr.getAllResponseHeaders());
                  emitter.emit(
                    "headers",
                    emitter.statusCode,
                    emitter.headers,
                    xhr.statusText
                  );
                  headersEmitted = true;
                }
                if (this.readyState === this.DONE) {
                  self2.finishRequest(xhr, emitter);
                }
              }, false);
              xhr.upload.addEventListener("progress", function(evt) {
                emitter.emit("sendProgress", evt);
              });
              xhr.addEventListener("progress", function(evt) {
                emitter.emit("receiveProgress", evt);
              }, false);
              xhr.addEventListener("timeout", function() {
                errCallback(AWS2.util.error(new Error("Timeout"), { code: "TimeoutError" }));
              }, false);
              xhr.addEventListener("error", function() {
                errCallback(AWS2.util.error(new Error("Network Failure"), {
                  code: "NetworkingError"
                }));
              }, false);
              xhr.addEventListener("abort", function() {
                errCallback(AWS2.util.error(new Error("Request aborted"), {
                  code: "RequestAbortedError"
                }));
              }, false);
              callback(emitter);
              xhr.open(httpRequest.method, href, httpOptions.xhrAsync !== false);
              AWS2.util.each(httpRequest.headers, function(key, value) {
                if (key !== "Content-Length" && key !== "User-Agent" && key !== "Host") {
                  xhr.setRequestHeader(key, value);
                }
              });
              if (httpOptions.timeout && httpOptions.xhrAsync !== false) {
                xhr.timeout = httpOptions.timeout;
              }
              if (httpOptions.xhrWithCredentials) {
                xhr.withCredentials = true;
              }
              try {
                xhr.responseType = "arraybuffer";
              } catch (e) {
              }
              try {
                if (httpRequest.body) {
                  xhr.send(httpRequest.body);
                } else {
                  xhr.send();
                }
              } catch (err) {
                if (httpRequest.body && typeof httpRequest.body.buffer === "object") {
                  xhr.send(httpRequest.body.buffer);
                } else {
                  throw err;
                }
              }
              return emitter;
            },
            parseHeaders: function parseHeaders(rawHeaders) {
              var headers = {};
              AWS2.util.arrayEach(rawHeaders.split(/\r?\n/), function(line) {
                var key = line.split(":", 1)[0];
                var value = line.substring(key.length + 2);
                if (key.length > 0)
                  headers[key.toLowerCase()] = value;
              });
              return headers;
            },
            finishRequest: function finishRequest(xhr, emitter) {
              var buffer;
              if (xhr.responseType === "arraybuffer" && xhr.response) {
                var ab = xhr.response;
                buffer = new AWS2.util.Buffer(ab.byteLength);
                var view = new Uint8Array(ab);
                for (var i = 0; i < buffer.length; ++i) {
                  buffer[i] = view[i];
                }
              }
              try {
                if (!buffer && typeof xhr.responseText === "string") {
                  buffer = new AWS2.util.Buffer(xhr.responseText);
                }
              } catch (e) {
              }
              if (buffer)
                emitter.emit("data", buffer);
              emitter.emit("end");
            }
          });
          AWS2.HttpClient.prototype = AWS2.XHRClient.prototype;
          AWS2.HttpClient.streamsApiVersion = 1;
        }, { "../core": 19, "../http": 35, "events": 87 }], 37: [function(require2, module2, exports2) {
          var util = require2("../util");
          function JsonBuilder() {
          }
          JsonBuilder.prototype.build = function(value, shape) {
            return JSON.stringify(translate(value, shape));
          };
          function translate(value, shape) {
            if (!shape || value === void 0 || value === null)
              return void 0;
            switch (shape.type) {
              case "structure":
                return translateStructure(value, shape);
              case "map":
                return translateMap(value, shape);
              case "list":
                return translateList(value, shape);
              default:
                return translateScalar(value, shape);
            }
          }
          function translateStructure(structure, shape) {
            if (shape.isDocument) {
              return structure;
            }
            var struct = {};
            util.each(structure, function(name, value) {
              var memberShape = shape.members[name];
              if (memberShape) {
                if (memberShape.location !== "body")
                  return;
                var locationName = memberShape.isLocationName ? memberShape.name : name;
                var result = translate(value, memberShape);
                if (result !== void 0)
                  struct[locationName] = result;
              }
            });
            return struct;
          }
          function translateList(list, shape) {
            var out = [];
            util.arrayEach(list, function(value) {
              var result = translate(value, shape.member);
              if (result !== void 0)
                out.push(result);
            });
            return out;
          }
          function translateMap(map, shape) {
            var out = {};
            util.each(map, function(key, value) {
              var result = translate(value, shape.value);
              if (result !== void 0)
                out[key] = result;
            });
            return out;
          }
          function translateScalar(value, shape) {
            return shape.toWireFormat(value);
          }
          module2.exports = JsonBuilder;
        }, { "../util": 74 }], 38: [function(require2, module2, exports2) {
          var util = require2("../util");
          function JsonParser() {
          }
          JsonParser.prototype.parse = function(value, shape) {
            return translate(JSON.parse(value), shape);
          };
          function translate(value, shape) {
            if (!shape || value === void 0)
              return void 0;
            switch (shape.type) {
              case "structure":
                return translateStructure(value, shape);
              case "map":
                return translateMap(value, shape);
              case "list":
                return translateList(value, shape);
              default:
                return translateScalar(value, shape);
            }
          }
          function translateStructure(structure, shape) {
            if (structure == null)
              return void 0;
            if (shape.isDocument)
              return structure;
            var struct = {};
            var shapeMembers = shape.members;
            util.each(shapeMembers, function(name, memberShape) {
              var locationName = memberShape.isLocationName ? memberShape.name : name;
              if (Object.prototype.hasOwnProperty.call(structure, locationName)) {
                var value = structure[locationName];
                var result = translate(value, memberShape);
                if (result !== void 0)
                  struct[name] = result;
              }
            });
            return struct;
          }
          function translateList(list, shape) {
            if (list == null)
              return void 0;
            var out = [];
            util.arrayEach(list, function(value) {
              var result = translate(value, shape.member);
              if (result === void 0)
                out.push(null);
              else
                out.push(result);
            });
            return out;
          }
          function translateMap(map, shape) {
            if (map == null)
              return void 0;
            var out = {};
            util.each(map, function(key, value) {
              var result = translate(value, shape.value);
              if (result === void 0)
                out[key] = null;
              else
                out[key] = result;
            });
            return out;
          }
          function translateScalar(value, shape) {
            return shape.toType(value);
          }
          module2.exports = JsonParser;
        }, { "../util": 74 }], 39: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var warning = [
                "We are formalizing our plans to enter AWS SDK for JavaScript (v2) into maintenance mode in 2023.\n",
                "Please migrate your code to use AWS SDK for JavaScript (v3).",
                "For more information, check the migration guide at https://a.co/7PzMCcy"
              ].join("\n");
              module2.exports = {
                suppress: false
              };
              function emitWarning() {
                if (typeof process === "undefined")
                  return;
                if (typeof process.env === "object" && typeof process.env.AWS_EXECUTION_ENV !== "undefined" && process.env.AWS_EXECUTION_ENV.indexOf("AWS_Lambda_") === 0) {
                  return;
                }
                if (typeof process.env === "object" && typeof process.env.AWS_SDK_JS_SUPPRESS_MAINTENANCE_MODE_MESSAGE !== "undefined") {
                  return;
                }
                if (typeof process.emitWarning === "function") {
                  process.emitWarning(warning, {
                    type: "NOTE"
                  });
                }
              }
              setTimeout(function() {
                if (!module2.exports.suppress) {
                  emitWarning();
                }
              }, 0);
            }).call(this);
          }).call(this, require2("_process"));
        }, { "_process": 91 }], 40: [function(require2, module2, exports2) {
          var Collection = require2("./collection");
          var Operation = require2("./operation");
          var Shape = require2("./shape");
          var Paginator = require2("./paginator");
          var ResourceWaiter = require2("./resource_waiter");
          var metadata = require2("../../apis/metadata.json");
          var util = require2("../util");
          var property = util.property;
          var memoizedProperty = util.memoizedProperty;
          function Api(api, options) {
            var self2 = this;
            api = api || {};
            options = options || {};
            options.api = this;
            api.metadata = api.metadata || {};
            var serviceIdentifier = options.serviceIdentifier;
            delete options.serviceIdentifier;
            property(this, "isApi", true, false);
            property(this, "apiVersion", api.metadata.apiVersion);
            property(this, "endpointPrefix", api.metadata.endpointPrefix);
            property(this, "signingName", api.metadata.signingName);
            property(this, "globalEndpoint", api.metadata.globalEndpoint);
            property(this, "signatureVersion", api.metadata.signatureVersion);
            property(this, "jsonVersion", api.metadata.jsonVersion);
            property(this, "targetPrefix", api.metadata.targetPrefix);
            property(this, "protocol", api.metadata.protocol);
            property(this, "timestampFormat", api.metadata.timestampFormat);
            property(this, "xmlNamespaceUri", api.metadata.xmlNamespace);
            property(this, "abbreviation", api.metadata.serviceAbbreviation);
            property(this, "fullName", api.metadata.serviceFullName);
            property(this, "serviceId", api.metadata.serviceId);
            if (serviceIdentifier && metadata[serviceIdentifier]) {
              property(this, "xmlNoDefaultLists", metadata[serviceIdentifier].xmlNoDefaultLists, false);
            }
            memoizedProperty(this, "className", function() {
              var name = api.metadata.serviceAbbreviation || api.metadata.serviceFullName;
              if (!name)
                return null;
              name = name.replace(/^Amazon|AWS\s*|\(.*|\s+|\W+/g, "");
              if (name === "ElasticLoadBalancing")
                name = "ELB";
              return name;
            });
            function addEndpointOperation(name, operation) {
              if (operation.endpointoperation === true) {
                property(self2, "endpointOperation", util.string.lowerFirst(name));
              }
              if (operation.endpointdiscovery && !self2.hasRequiredEndpointDiscovery) {
                property(
                  self2,
                  "hasRequiredEndpointDiscovery",
                  operation.endpointdiscovery.required === true
                );
              }
            }
            property(this, "operations", new Collection(api.operations, options, function(name, operation) {
              return new Operation(name, operation, options);
            }, util.string.lowerFirst, addEndpointOperation));
            property(this, "shapes", new Collection(api.shapes, options, function(name, shape) {
              return Shape.create(shape, options);
            }));
            property(this, "paginators", new Collection(api.paginators, options, function(name, paginator) {
              return new Paginator(name, paginator, options);
            }));
            property(this, "waiters", new Collection(api.waiters, options, function(name, waiter) {
              return new ResourceWaiter(name, waiter, options);
            }, util.string.lowerFirst));
            if (options.documentation) {
              property(this, "documentation", api.documentation);
              property(this, "documentationUrl", api.documentationUrl);
            }
            property(this, "awsQueryCompatible", api.metadata.awsQueryCompatible);
          }
          module2.exports = Api;
        }, { "../../apis/metadata.json": 4, "../util": 74, "./collection": 41, "./operation": 42, "./paginator": 43, "./resource_waiter": 44, "./shape": 45 }], 41: [function(require2, module2, exports2) {
          var memoizedProperty = require2("../util").memoizedProperty;
          function memoize(name, value, factory, nameTr) {
            memoizedProperty(this, nameTr(name), function() {
              return factory(name, value);
            });
          }
          function Collection(iterable, options, factory, nameTr, callback) {
            nameTr = nameTr || String;
            var self2 = this;
            for (var id in iterable) {
              if (Object.prototype.hasOwnProperty.call(iterable, id)) {
                memoize.call(self2, id, iterable[id], factory, nameTr);
                if (callback)
                  callback(id, iterable[id]);
              }
            }
          }
          module2.exports = Collection;
        }, { "../util": 74 }], 42: [function(require2, module2, exports2) {
          var Shape = require2("./shape");
          var util = require2("../util");
          var property = util.property;
          var memoizedProperty = util.memoizedProperty;
          function Operation(name, operation, options) {
            var self2 = this;
            options = options || {};
            property(this, "name", operation.name || name);
            property(this, "api", options.api, false);
            operation.http = operation.http || {};
            property(this, "endpoint", operation.endpoint);
            property(this, "httpMethod", operation.http.method || "POST");
            property(this, "httpPath", operation.http.requestUri || "/");
            property(this, "authtype", operation.authtype || "");
            property(
              this,
              "endpointDiscoveryRequired",
              operation.endpointdiscovery ? operation.endpointdiscovery.required ? "REQUIRED" : "OPTIONAL" : "NULL"
            );
            var httpChecksumRequired = operation.httpChecksumRequired || operation.httpChecksum && operation.httpChecksum.requestChecksumRequired;
            property(this, "httpChecksumRequired", httpChecksumRequired, false);
            memoizedProperty(this, "input", function() {
              if (!operation.input) {
                return new Shape.create({ type: "structure" }, options);
              }
              return Shape.create(operation.input, options);
            });
            memoizedProperty(this, "output", function() {
              if (!operation.output) {
                return new Shape.create({ type: "structure" }, options);
              }
              return Shape.create(operation.output, options);
            });
            memoizedProperty(this, "errors", function() {
              var list = [];
              if (!operation.errors)
                return null;
              for (var i = 0; i < operation.errors.length; i++) {
                list.push(Shape.create(operation.errors[i], options));
              }
              return list;
            });
            memoizedProperty(this, "paginator", function() {
              return options.api.paginators[name];
            });
            if (options.documentation) {
              property(this, "documentation", operation.documentation);
              property(this, "documentationUrl", operation.documentationUrl);
            }
            memoizedProperty(this, "idempotentMembers", function() {
              var idempotentMembers = [];
              var input = self2.input;
              var members = input.members;
              if (!input.members) {
                return idempotentMembers;
              }
              for (var name2 in members) {
                if (!members.hasOwnProperty(name2)) {
                  continue;
                }
                if (members[name2].isIdempotent === true) {
                  idempotentMembers.push(name2);
                }
              }
              return idempotentMembers;
            });
            memoizedProperty(this, "hasEventOutput", function() {
              var output = self2.output;
              return hasEventStream(output);
            });
          }
          function hasEventStream(topLevelShape) {
            var members = topLevelShape.members;
            var payload2 = topLevelShape.payload;
            if (!topLevelShape.members) {
              return false;
            }
            if (payload2) {
              var payloadMember = members[payload2];
              return payloadMember.isEventStream;
            }
            for (var name in members) {
              if (!members.hasOwnProperty(name)) {
                if (members[name].isEventStream === true) {
                  return true;
                }
              }
            }
            return false;
          }
          module2.exports = Operation;
        }, { "../util": 74, "./shape": 45 }], 43: [function(require2, module2, exports2) {
          var property = require2("../util").property;
          function Paginator(name, paginator) {
            property(this, "inputToken", paginator.input_token);
            property(this, "limitKey", paginator.limit_key);
            property(this, "moreResults", paginator.more_results);
            property(this, "outputToken", paginator.output_token);
            property(this, "resultKey", paginator.result_key);
          }
          module2.exports = Paginator;
        }, { "../util": 74 }], 44: [function(require2, module2, exports2) {
          var util = require2("../util");
          var property = util.property;
          function ResourceWaiter(name, waiter, options) {
            options = options || {};
            property(this, "name", name);
            property(this, "api", options.api, false);
            if (waiter.operation) {
              property(this, "operation", util.string.lowerFirst(waiter.operation));
            }
            var self2 = this;
            var keys = [
              "type",
              "description",
              "delay",
              "maxAttempts",
              "acceptors"
            ];
            keys.forEach(function(key) {
              var value = waiter[key];
              if (value) {
                property(self2, key, value);
              }
            });
          }
          module2.exports = ResourceWaiter;
        }, { "../util": 74 }], 45: [function(require2, module2, exports2) {
          var Collection = require2("./collection");
          var util = require2("../util");
          function property(obj, name, value) {
            if (value !== null && value !== void 0) {
              util.property.apply(this, arguments);
            }
          }
          function memoizedProperty(obj, name) {
            if (!obj.constructor.prototype[name]) {
              util.memoizedProperty.apply(this, arguments);
            }
          }
          function Shape(shape, options, memberName) {
            options = options || {};
            property(this, "shape", shape.shape);
            property(this, "api", options.api, false);
            property(this, "type", shape.type);
            property(this, "enum", shape.enum);
            property(this, "min", shape.min);
            property(this, "max", shape.max);
            property(this, "pattern", shape.pattern);
            property(this, "location", shape.location || this.location || "body");
            property(this, "name", this.name || shape.xmlName || shape.queryName || shape.locationName || memberName);
            property(this, "isStreaming", shape.streaming || this.isStreaming || false);
            property(this, "requiresLength", shape.requiresLength, false);
            property(this, "isComposite", shape.isComposite || false);
            property(this, "isShape", true, false);
            property(this, "isQueryName", Boolean(shape.queryName), false);
            property(this, "isLocationName", Boolean(shape.locationName), false);
            property(this, "isIdempotent", shape.idempotencyToken === true);
            property(this, "isJsonValue", shape.jsonvalue === true);
            property(this, "isSensitive", shape.sensitive === true || shape.prototype && shape.prototype.sensitive === true);
            property(this, "isEventStream", Boolean(shape.eventstream), false);
            property(this, "isEvent", Boolean(shape.event), false);
            property(this, "isEventPayload", Boolean(shape.eventpayload), false);
            property(this, "isEventHeader", Boolean(shape.eventheader), false);
            property(this, "isTimestampFormatSet", Boolean(shape.timestampFormat) || shape.prototype && shape.prototype.isTimestampFormatSet === true, false);
            property(this, "endpointDiscoveryId", Boolean(shape.endpointdiscoveryid), false);
            property(this, "hostLabel", Boolean(shape.hostLabel), false);
            if (options.documentation) {
              property(this, "documentation", shape.documentation);
              property(this, "documentationUrl", shape.documentationUrl);
            }
            if (shape.xmlAttribute) {
              property(this, "isXmlAttribute", shape.xmlAttribute || false);
            }
            property(this, "defaultValue", null);
            this.toWireFormat = function(value) {
              if (value === null || value === void 0)
                return "";
              return value;
            };
            this.toType = function(value) {
              return value;
            };
          }
          Shape.normalizedTypes = {
            character: "string",
            double: "float",
            long: "integer",
            short: "integer",
            biginteger: "integer",
            bigdecimal: "float",
            blob: "binary"
          };
          Shape.types = {
            "structure": StructureShape,
            "list": ListShape,
            "map": MapShape,
            "boolean": BooleanShape,
            "timestamp": TimestampShape,
            "float": FloatShape,
            "integer": IntegerShape,
            "string": StringShape,
            "base64": Base64Shape,
            "binary": BinaryShape
          };
          Shape.resolve = function resolve(shape, options) {
            if (shape.shape) {
              var refShape = options.api.shapes[shape.shape];
              if (!refShape) {
                throw new Error("Cannot find shape reference: " + shape.shape);
              }
              return refShape;
            } else {
              return null;
            }
          };
          Shape.create = function create(shape, options, memberName) {
            if (shape.isShape)
              return shape;
            var refShape = Shape.resolve(shape, options);
            if (refShape) {
              var filteredKeys = Object.keys(shape);
              if (!options.documentation) {
                filteredKeys = filteredKeys.filter(function(name) {
                  return !name.match(/documentation/);
                });
              }
              var InlineShape = function() {
                refShape.constructor.call(this, shape, options, memberName);
              };
              InlineShape.prototype = refShape;
              return new InlineShape();
            } else {
              if (!shape.type) {
                if (shape.members)
                  shape.type = "structure";
                else if (shape.member)
                  shape.type = "list";
                else if (shape.key)
                  shape.type = "map";
                else
                  shape.type = "string";
              }
              var origType = shape.type;
              if (Shape.normalizedTypes[shape.type]) {
                shape.type = Shape.normalizedTypes[shape.type];
              }
              if (Shape.types[shape.type]) {
                return new Shape.types[shape.type](shape, options, memberName);
              } else {
                throw new Error("Unrecognized shape type: " + origType);
              }
            }
          };
          function CompositeShape(shape) {
            Shape.apply(this, arguments);
            property(this, "isComposite", true);
            if (shape.flattened) {
              property(this, "flattened", shape.flattened || false);
            }
          }
          function StructureShape(shape, options) {
            var self2 = this;
            var requiredMap = null, firstInit = !this.isShape;
            CompositeShape.apply(this, arguments);
            if (firstInit) {
              property(this, "defaultValue", function() {
                return {};
              });
              property(this, "members", {});
              property(this, "memberNames", []);
              property(this, "required", []);
              property(this, "isRequired", function() {
                return false;
              });
              property(this, "isDocument", Boolean(shape.document));
            }
            if (shape.members) {
              property(this, "members", new Collection(shape.members, options, function(name, member) {
                return Shape.create(member, options, name);
              }));
              memoizedProperty(this, "memberNames", function() {
                return shape.xmlOrder || Object.keys(shape.members);
              });
              if (shape.event) {
                memoizedProperty(this, "eventPayloadMemberName", function() {
                  var members = self2.members;
                  var memberNames = self2.memberNames;
                  for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
                    if (members[memberNames[i]].isEventPayload) {
                      return memberNames[i];
                    }
                  }
                });
                memoizedProperty(this, "eventHeaderMemberNames", function() {
                  var members = self2.members;
                  var memberNames = self2.memberNames;
                  var eventHeaderMemberNames = [];
                  for (var i = 0, iLen = memberNames.length; i < iLen; i++) {
                    if (members[memberNames[i]].isEventHeader) {
                      eventHeaderMemberNames.push(memberNames[i]);
                    }
                  }
                  return eventHeaderMemberNames;
                });
              }
            }
            if (shape.required) {
              property(this, "required", shape.required);
              property(this, "isRequired", function(name) {
                if (!requiredMap) {
                  requiredMap = {};
                  for (var i = 0; i < shape.required.length; i++) {
                    requiredMap[shape.required[i]] = true;
                  }
                }
                return requiredMap[name];
              }, false, true);
            }
            property(this, "resultWrapper", shape.resultWrapper || null);
            if (shape.payload) {
              property(this, "payload", shape.payload);
            }
            if (typeof shape.xmlNamespace === "string") {
              property(this, "xmlNamespaceUri", shape.xmlNamespace);
            } else if (typeof shape.xmlNamespace === "object") {
              property(this, "xmlNamespacePrefix", shape.xmlNamespace.prefix);
              property(this, "xmlNamespaceUri", shape.xmlNamespace.uri);
            }
          }
          function ListShape(shape, options) {
            var self2 = this, firstInit = !this.isShape;
            CompositeShape.apply(this, arguments);
            if (firstInit) {
              property(this, "defaultValue", function() {
                return [];
              });
            }
            if (shape.member) {
              memoizedProperty(this, "member", function() {
                return Shape.create(shape.member, options);
              });
            }
            if (this.flattened) {
              var oldName = this.name;
              memoizedProperty(this, "name", function() {
                return self2.member.name || oldName;
              });
            }
          }
          function MapShape(shape, options) {
            var firstInit = !this.isShape;
            CompositeShape.apply(this, arguments);
            if (firstInit) {
              property(this, "defaultValue", function() {
                return {};
              });
              property(this, "key", Shape.create({ type: "string" }, options));
              property(this, "value", Shape.create({ type: "string" }, options));
            }
            if (shape.key) {
              memoizedProperty(this, "key", function() {
                return Shape.create(shape.key, options);
              });
            }
            if (shape.value) {
              memoizedProperty(this, "value", function() {
                return Shape.create(shape.value, options);
              });
            }
          }
          function TimestampShape(shape) {
            var self2 = this;
            Shape.apply(this, arguments);
            if (shape.timestampFormat) {
              property(this, "timestampFormat", shape.timestampFormat);
            } else if (self2.isTimestampFormatSet && this.timestampFormat) {
              property(this, "timestampFormat", this.timestampFormat);
            } else if (this.location === "header") {
              property(this, "timestampFormat", "rfc822");
            } else if (this.location === "querystring") {
              property(this, "timestampFormat", "iso8601");
            } else if (this.api) {
              switch (this.api.protocol) {
                case "json":
                case "rest-json":
                  property(this, "timestampFormat", "unixTimestamp");
                  break;
                case "rest-xml":
                case "query":
                case "ec2":
                  property(this, "timestampFormat", "iso8601");
                  break;
              }
            }
            this.toType = function(value) {
              if (value === null || value === void 0)
                return null;
              if (typeof value.toUTCString === "function")
                return value;
              return typeof value === "string" || typeof value === "number" ? util.date.parseTimestamp(value) : null;
            };
            this.toWireFormat = function(value) {
              return util.date.format(value, self2.timestampFormat);
            };
          }
          function StringShape() {
            Shape.apply(this, arguments);
            var nullLessProtocols = ["rest-xml", "query", "ec2"];
            this.toType = function(value) {
              value = this.api && nullLessProtocols.indexOf(this.api.protocol) > -1 ? value || "" : value;
              if (this.isJsonValue) {
                return JSON.parse(value);
              }
              return value && typeof value.toString === "function" ? value.toString() : value;
            };
            this.toWireFormat = function(value) {
              return this.isJsonValue ? JSON.stringify(value) : value;
            };
          }
          function FloatShape() {
            Shape.apply(this, arguments);
            this.toType = function(value) {
              if (value === null || value === void 0)
                return null;
              return parseFloat(value);
            };
            this.toWireFormat = this.toType;
          }
          function IntegerShape() {
            Shape.apply(this, arguments);
            this.toType = function(value) {
              if (value === null || value === void 0)
                return null;
              return parseInt(value, 10);
            };
            this.toWireFormat = this.toType;
          }
          function BinaryShape() {
            Shape.apply(this, arguments);
            this.toType = function(value) {
              var buf = util.base64.decode(value);
              if (this.isSensitive && util.isNode() && typeof util.Buffer.alloc === "function") {
                var secureBuf = util.Buffer.alloc(buf.length, buf);
                buf.fill(0);
                buf = secureBuf;
              }
              return buf;
            };
            this.toWireFormat = util.base64.encode;
          }
          function Base64Shape() {
            BinaryShape.apply(this, arguments);
          }
          function BooleanShape() {
            Shape.apply(this, arguments);
            this.toType = function(value) {
              if (typeof value === "boolean")
                return value;
              if (value === null || value === void 0)
                return null;
              return value === "true";
            };
          }
          Shape.shapes = {
            StructureShape,
            ListShape,
            MapShape,
            StringShape,
            BooleanShape,
            Base64Shape
          };
          module2.exports = Shape;
        }, { "../util": 74, "./collection": 41 }], 46: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          AWS2.ParamValidator = AWS2.util.inherit({
            /**
             * Create a new validator object.
             *
             * @param validation [Boolean|map] whether input parameters should be
             *     validated against the operation description before sending the
             *     request. Pass a map to enable any of the following specific
             *     validation features:
             *
             *     * **min** [Boolean] &mdash; Validates that a value meets the min
             *       constraint. This is enabled by default when paramValidation is set
             *       to `true`.
             *     * **max** [Boolean] &mdash; Validates that a value meets the max
             *       constraint.
             *     * **pattern** [Boolean] &mdash; Validates that a string value matches a
             *       regular expression.
             *     * **enum** [Boolean] &mdash; Validates that a string value matches one
             *       of the allowable enum values.
             */
            constructor: function ParamValidator(validation) {
              if (validation === true || validation === void 0) {
                validation = { "min": true };
              }
              this.validation = validation;
            },
            validate: function validate(shape, params, context) {
              this.errors = [];
              this.validateMember(shape, params || {}, context || "params");
              if (this.errors.length > 1) {
                var msg = this.errors.join("\n* ");
                msg = "There were " + this.errors.length + " validation errors:\n* " + msg;
                throw AWS2.util.error(
                  new Error(msg),
                  { code: "MultipleValidationErrors", errors: this.errors }
                );
              } else if (this.errors.length === 1) {
                throw this.errors[0];
              } else {
                return true;
              }
            },
            fail: function fail(code, message) {
              this.errors.push(AWS2.util.error(new Error(message), { code }));
            },
            validateStructure: function validateStructure(shape, params, context) {
              if (shape.isDocument)
                return true;
              this.validateType(params, context, ["object"], "structure");
              var paramName;
              for (var i = 0; shape.required && i < shape.required.length; i++) {
                paramName = shape.required[i];
                var value = params[paramName];
                if (value === void 0 || value === null) {
                  this.fail(
                    "MissingRequiredParameter",
                    "Missing required key '" + paramName + "' in " + context
                  );
                }
              }
              for (paramName in params) {
                if (!Object.prototype.hasOwnProperty.call(params, paramName))
                  continue;
                var paramValue = params[paramName], memberShape = shape.members[paramName];
                if (memberShape !== void 0) {
                  var memberContext = [context, paramName].join(".");
                  this.validateMember(memberShape, paramValue, memberContext);
                } else if (paramValue !== void 0 && paramValue !== null) {
                  this.fail(
                    "UnexpectedParameter",
                    "Unexpected key '" + paramName + "' found in " + context
                  );
                }
              }
              return true;
            },
            validateMember: function validateMember(shape, param, context) {
              switch (shape.type) {
                case "structure":
                  return this.validateStructure(shape, param, context);
                case "list":
                  return this.validateList(shape, param, context);
                case "map":
                  return this.validateMap(shape, param, context);
                default:
                  return this.validateScalar(shape, param, context);
              }
            },
            validateList: function validateList(shape, params, context) {
              if (this.validateType(params, context, [Array])) {
                this.validateRange(shape, params.length, context, "list member count");
                for (var i = 0; i < params.length; i++) {
                  this.validateMember(shape.member, params[i], context + "[" + i + "]");
                }
              }
            },
            validateMap: function validateMap(shape, params, context) {
              if (this.validateType(params, context, ["object"], "map")) {
                var mapCount = 0;
                for (var param in params) {
                  if (!Object.prototype.hasOwnProperty.call(params, param))
                    continue;
                  this.validateMember(
                    shape.key,
                    param,
                    context + "[key='" + param + "']"
                  );
                  this.validateMember(
                    shape.value,
                    params[param],
                    context + "['" + param + "']"
                  );
                  mapCount++;
                }
                this.validateRange(shape, mapCount, context, "map member count");
              }
            },
            validateScalar: function validateScalar(shape, value, context) {
              switch (shape.type) {
                case null:
                case void 0:
                case "string":
                  return this.validateString(shape, value, context);
                case "base64":
                case "binary":
                  return this.validatePayload(value, context);
                case "integer":
                case "float":
                  return this.validateNumber(shape, value, context);
                case "boolean":
                  return this.validateType(value, context, ["boolean"]);
                case "timestamp":
                  return this.validateType(
                    value,
                    context,
                    [
                      Date,
                      /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d+)?Z$/,
                      "number"
                    ],
                    "Date object, ISO-8601 string, or a UNIX timestamp"
                  );
                default:
                  return this.fail("UnkownType", "Unhandled type " + shape.type + " for " + context);
              }
            },
            validateString: function validateString(shape, value, context) {
              var validTypes = ["string"];
              if (shape.isJsonValue) {
                validTypes = validTypes.concat(["number", "object", "boolean"]);
              }
              if (value !== null && this.validateType(value, context, validTypes)) {
                this.validateEnum(shape, value, context);
                this.validateRange(shape, value.length, context, "string length");
                this.validatePattern(shape, value, context);
                this.validateUri(shape, value, context);
              }
            },
            validateUri: function validateUri(shape, value, context) {
              if (shape["location"] === "uri") {
                if (value.length === 0) {
                  this.fail("UriParameterError", 'Expected uri parameter to have length >= 1, but found "' + value + '" for ' + context);
                }
              }
            },
            validatePattern: function validatePattern(shape, value, context) {
              if (this.validation["pattern"] && shape["pattern"] !== void 0) {
                if (!new RegExp(shape["pattern"]).test(value)) {
                  this.fail("PatternMatchError", 'Provided value "' + value + '" does not match regex pattern /' + shape["pattern"] + "/ for " + context);
                }
              }
            },
            validateRange: function validateRange(shape, value, context, descriptor) {
              if (this.validation["min"]) {
                if (shape["min"] !== void 0 && value < shape["min"]) {
                  this.fail("MinRangeError", "Expected " + descriptor + " >= " + shape["min"] + ", but found " + value + " for " + context);
                }
              }
              if (this.validation["max"]) {
                if (shape["max"] !== void 0 && value > shape["max"]) {
                  this.fail("MaxRangeError", "Expected " + descriptor + " <= " + shape["max"] + ", but found " + value + " for " + context);
                }
              }
            },
            validateEnum: function validateRange(shape, value, context) {
              if (this.validation["enum"] && shape["enum"] !== void 0) {
                if (shape["enum"].indexOf(value) === -1) {
                  this.fail("EnumError", "Found string value of " + value + ", but expected " + shape["enum"].join("|") + " for " + context);
                }
              }
            },
            validateType: function validateType(value, context, acceptedTypes, type) {
              if (value === null || value === void 0)
                return false;
              var foundInvalidType = false;
              for (var i = 0; i < acceptedTypes.length; i++) {
                if (typeof acceptedTypes[i] === "string") {
                  if (typeof value === acceptedTypes[i])
                    return true;
                } else if (acceptedTypes[i] instanceof RegExp) {
                  if ((value || "").toString().match(acceptedTypes[i]))
                    return true;
                } else {
                  if (value instanceof acceptedTypes[i])
                    return true;
                  if (AWS2.util.isType(value, acceptedTypes[i]))
                    return true;
                  if (!type && !foundInvalidType)
                    acceptedTypes = acceptedTypes.slice();
                  acceptedTypes[i] = AWS2.util.typeName(acceptedTypes[i]);
                }
                foundInvalidType = true;
              }
              var acceptedType = type;
              if (!acceptedType) {
                acceptedType = acceptedTypes.join(", ").replace(/,([^,]+)$/, ", or$1");
              }
              var vowel = acceptedType.match(/^[aeiou]/i) ? "n" : "";
              this.fail("InvalidParameterType", "Expected " + context + " to be a" + vowel + " " + acceptedType);
              return false;
            },
            validateNumber: function validateNumber(shape, value, context) {
              if (value === null || value === void 0)
                return;
              if (typeof value === "string") {
                var castedValue = parseFloat(value);
                if (castedValue.toString() === value)
                  value = castedValue;
              }
              if (this.validateType(value, context, ["number"])) {
                this.validateRange(shape, value, context, "numeric value");
              }
            },
            validatePayload: function validatePayload(value, context) {
              if (value === null || value === void 0)
                return;
              if (typeof value === "string")
                return;
              if (value && typeof value.byteLength === "number")
                return;
              if (AWS2.util.isNode()) {
                var Stream = AWS2.util.stream.Stream;
                if (AWS2.util.Buffer.isBuffer(value) || value instanceof Stream)
                  return;
              } else {
                if (typeof Blob !== void 0 && value instanceof Blob)
                  return;
              }
              var types = ["Buffer", "Stream", "File", "Blob", "ArrayBuffer", "DataView"];
              if (value) {
                for (var i = 0; i < types.length; i++) {
                  if (AWS2.util.isType(value, types[i]))
                    return;
                  if (AWS2.util.typeName(value.constructor) === types[i])
                    return;
                }
              }
              this.fail("InvalidParameterType", "Expected " + context + " to be a string, Buffer, Stream, Blob, or typed array object");
            }
          });
        }, { "./core": 19 }], 47: [function(require2, module2, exports2) {
          var util = require2("../util");
          var AWS2 = require2("../core");
          function populateHostPrefix(request) {
            var enabled = request.service.config.hostPrefixEnabled;
            if (!enabled)
              return request;
            var operationModel = request.service.api.operations[request.operation];
            if (hasEndpointDiscover(request))
              return request;
            if (operationModel.endpoint && operationModel.endpoint.hostPrefix) {
              var hostPrefixNotation = operationModel.endpoint.hostPrefix;
              var hostPrefix = expandHostPrefix(hostPrefixNotation, request.params, operationModel.input);
              prependEndpointPrefix(request.httpRequest.endpoint, hostPrefix);
              validateHostname(request.httpRequest.endpoint.hostname);
            }
            return request;
          }
          function hasEndpointDiscover(request) {
            var api = request.service.api;
            var operationModel = api.operations[request.operation];
            var isEndpointOperation = api.endpointOperation && api.endpointOperation === util.string.lowerFirst(operationModel.name);
            return operationModel.endpointDiscoveryRequired !== "NULL" || isEndpointOperation === true;
          }
          function expandHostPrefix(hostPrefixNotation, params, shape) {
            util.each(shape.members, function(name, member) {
              if (member.hostLabel === true) {
                if (typeof params[name] !== "string" || params[name] === "") {
                  throw util.error(new Error(), {
                    message: "Parameter " + name + " should be a non-empty string.",
                    code: "InvalidParameter"
                  });
                }
                var regex = new RegExp("\\{" + name + "\\}", "g");
                hostPrefixNotation = hostPrefixNotation.replace(regex, params[name]);
              }
            });
            return hostPrefixNotation;
          }
          function prependEndpointPrefix(endpoint, prefix) {
            if (endpoint.host) {
              endpoint.host = prefix + endpoint.host;
            }
            if (endpoint.hostname) {
              endpoint.hostname = prefix + endpoint.hostname;
            }
          }
          function validateHostname(hostname) {
            var labels = hostname.split(".");
            var hostPattern = /^[a-zA-Z0-9]{1}$|^[a-zA-Z0-9][a-zA-Z0-9\-]*[a-zA-Z0-9]$/;
            util.arrayEach(labels, function(label) {
              if (!label.length || label.length < 1 || label.length > 63) {
                throw util.error(new Error(), {
                  code: "ValidationError",
                  message: "Hostname label length should be between 1 to 63 characters, inclusive."
                });
              }
              if (!hostPattern.test(label)) {
                throw AWS2.util.error(
                  new Error(),
                  { code: "ValidationError", message: label + " is not hostname compatible." }
                );
              }
            });
          }
          module2.exports = {
            populateHostPrefix
          };
        }, { "../core": 19, "../util": 74 }], 48: [function(require2, module2, exports2) {
          var util = require2("../util");
          var JsonBuilder = require2("../json/builder");
          var JsonParser = require2("../json/parser");
          var populateHostPrefix = require2("./helpers").populateHostPrefix;
          function buildRequest(req) {
            var httpRequest = req.httpRequest;
            var api = req.service.api;
            var target = api.targetPrefix + "." + api.operations[req.operation].name;
            var version = api.jsonVersion || "1.0";
            var input = api.operations[req.operation].input;
            var builder = new JsonBuilder();
            if (version === 1)
              version = "1.0";
            if (api.awsQueryCompatible) {
              if (!httpRequest.params) {
                httpRequest.params = {};
              }
              Object.assign(httpRequest.params, req.params);
            }
            httpRequest.body = builder.build(req.params || {}, input);
            httpRequest.headers["Content-Type"] = "application/x-amz-json-" + version;
            httpRequest.headers["X-Amz-Target"] = target;
            populateHostPrefix(req);
          }
          function extractError(resp) {
            var error = {};
            var httpResponse = resp.httpResponse;
            error.code = httpResponse.headers["x-amzn-errortype"] || "UnknownError";
            if (typeof error.code === "string") {
              error.code = error.code.split(":")[0];
            }
            if (httpResponse.body.length > 0) {
              try {
                var e = JSON.parse(httpResponse.body.toString());
                var code = e.__type || e.code || e.Code;
                if (code) {
                  error.code = code.split("#").pop();
                }
                if (error.code === "RequestEntityTooLarge") {
                  error.message = "Request body must be less than 1 MB";
                } else {
                  error.message = e.message || e.Message || null;
                }
                for (var key in e || {}) {
                  if (key === "code" || key === "message") {
                    continue;
                  }
                  error["[" + key + "]"] = "See error." + key + " for details.";
                  Object.defineProperty(error, key, {
                    value: e[key],
                    enumerable: false,
                    writable: true
                  });
                }
              } catch (e2) {
                error.statusCode = httpResponse.statusCode;
                error.message = httpResponse.statusMessage;
              }
            } else {
              error.statusCode = httpResponse.statusCode;
              error.message = httpResponse.statusCode.toString();
            }
            resp.error = util.error(new Error(), error);
          }
          function extractData(resp) {
            var body = resp.httpResponse.body.toString() || "{}";
            if (resp.request.service.config.convertResponseTypes === false) {
              resp.data = JSON.parse(body);
            } else {
              var operation = resp.request.service.api.operations[resp.request.operation];
              var shape = operation.output || {};
              var parser = new JsonParser();
              resp.data = parser.parse(body, shape);
            }
          }
          module2.exports = {
            buildRequest,
            extractError,
            extractData
          };
        }, { "../json/builder": 37, "../json/parser": 38, "../util": 74, "./helpers": 47 }], 49: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var util = require2("../util");
          var QueryParamSerializer = require2("../query/query_param_serializer");
          var Shape = require2("../model/shape");
          var populateHostPrefix = require2("./helpers").populateHostPrefix;
          function buildRequest(req) {
            var operation = req.service.api.operations[req.operation];
            var httpRequest = req.httpRequest;
            httpRequest.headers["Content-Type"] = "application/x-www-form-urlencoded; charset=utf-8";
            httpRequest.params = {
              Version: req.service.api.apiVersion,
              Action: operation.name
            };
            var builder = new QueryParamSerializer();
            builder.serialize(req.params, operation.input, function(name, value) {
              httpRequest.params[name] = value;
            });
            httpRequest.body = util.queryParamsToString(httpRequest.params);
            populateHostPrefix(req);
          }
          function extractError(resp) {
            var data, body = resp.httpResponse.body.toString();
            if (body.match("<UnknownOperationException")) {
              data = {
                Code: "UnknownOperation",
                Message: "Unknown operation " + resp.request.operation
              };
            } else {
              try {
                data = new AWS2.XML.Parser().parse(body);
              } catch (e) {
                data = {
                  Code: resp.httpResponse.statusCode,
                  Message: resp.httpResponse.statusMessage
                };
              }
            }
            if (data.requestId && !resp.requestId)
              resp.requestId = data.requestId;
            if (data.Errors)
              data = data.Errors;
            if (data.Error)
              data = data.Error;
            if (data.Code) {
              resp.error = util.error(new Error(), {
                code: data.Code,
                message: data.Message
              });
            } else {
              resp.error = util.error(new Error(), {
                code: resp.httpResponse.statusCode,
                message: null
              });
            }
          }
          function extractData(resp) {
            var req = resp.request;
            var operation = req.service.api.operations[req.operation];
            var shape = operation.output || {};
            var origRules = shape;
            if (origRules.resultWrapper) {
              var tmp = Shape.create({ type: "structure" });
              tmp.members[origRules.resultWrapper] = shape;
              tmp.memberNames = [origRules.resultWrapper];
              util.property(shape, "name", shape.resultWrapper);
              shape = tmp;
            }
            var parser = new AWS2.XML.Parser();
            if (shape && shape.members && !shape.members._XAMZRequestId) {
              var requestIdShape = Shape.create(
                { type: "string" },
                { api: { protocol: "query" } },
                "requestId"
              );
              shape.members._XAMZRequestId = requestIdShape;
            }
            var data = parser.parse(resp.httpResponse.body.toString(), shape);
            resp.requestId = data._XAMZRequestId || data.requestId;
            if (data._XAMZRequestId)
              delete data._XAMZRequestId;
            if (origRules.resultWrapper) {
              if (data[origRules.resultWrapper]) {
                util.update(data, data[origRules.resultWrapper]);
                delete data[origRules.resultWrapper];
              }
            }
            resp.data = data;
          }
          module2.exports = {
            buildRequest,
            extractError,
            extractData
          };
        }, { "../core": 19, "../model/shape": 45, "../query/query_param_serializer": 53, "../util": 74, "./helpers": 47 }], 50: [function(require2, module2, exports2) {
          var util = require2("../util");
          var populateHostPrefix = require2("./helpers").populateHostPrefix;
          function populateMethod(req) {
            req.httpRequest.method = req.service.api.operations[req.operation].httpMethod;
          }
          function generateURI(endpointPath, operationPath, input, params) {
            var uri = [endpointPath, operationPath].join("/");
            uri = uri.replace(/\/+/g, "/");
            var queryString = {}, queryStringSet = false;
            util.each(input.members, function(name, member) {
              var paramValue = params[name];
              if (paramValue === null || paramValue === void 0)
                return;
              if (member.location === "uri") {
                var regex = new RegExp("\\{" + member.name + "(\\+)?\\}");
                uri = uri.replace(regex, function(_, plus) {
                  var fn = plus ? util.uriEscapePath : util.uriEscape;
                  return fn(String(paramValue));
                });
              } else if (member.location === "querystring") {
                queryStringSet = true;
                if (member.type === "list") {
                  queryString[member.name] = paramValue.map(function(val) {
                    return util.uriEscape(member.member.toWireFormat(val).toString());
                  });
                } else if (member.type === "map") {
                  util.each(paramValue, function(key, value) {
                    if (Array.isArray(value)) {
                      queryString[key] = value.map(function(val) {
                        return util.uriEscape(String(val));
                      });
                    } else {
                      queryString[key] = util.uriEscape(String(value));
                    }
                  });
                } else {
                  queryString[member.name] = util.uriEscape(member.toWireFormat(paramValue).toString());
                }
              }
            });
            if (queryStringSet) {
              uri += uri.indexOf("?") >= 0 ? "&" : "?";
              var parts = [];
              util.arrayEach(Object.keys(queryString).sort(), function(key) {
                if (!Array.isArray(queryString[key])) {
                  queryString[key] = [queryString[key]];
                }
                for (var i = 0; i < queryString[key].length; i++) {
                  parts.push(util.uriEscape(String(key)) + "=" + queryString[key][i]);
                }
              });
              uri += parts.join("&");
            }
            return uri;
          }
          function populateURI(req) {
            var operation = req.service.api.operations[req.operation];
            var input = operation.input;
            var uri = generateURI(req.httpRequest.endpoint.path, operation.httpPath, input, req.params);
            req.httpRequest.path = uri;
          }
          function populateHeaders(req) {
            var operation = req.service.api.operations[req.operation];
            util.each(operation.input.members, function(name, member) {
              var value = req.params[name];
              if (value === null || value === void 0)
                return;
              if (member.location === "headers" && member.type === "map") {
                util.each(value, function(key, memberValue) {
                  req.httpRequest.headers[member.name + key] = memberValue;
                });
              } else if (member.location === "header") {
                value = member.toWireFormat(value).toString();
                if (member.isJsonValue) {
                  value = util.base64.encode(value);
                }
                req.httpRequest.headers[member.name] = value;
              }
            });
          }
          function buildRequest(req) {
            populateMethod(req);
            populateURI(req);
            populateHeaders(req);
            populateHostPrefix(req);
          }
          function extractError() {
          }
          function extractData(resp) {
            var req = resp.request;
            var data = {};
            var r = resp.httpResponse;
            var operation = req.service.api.operations[req.operation];
            var output = operation.output;
            var headers = {};
            util.each(r.headers, function(k, v) {
              headers[k.toLowerCase()] = v;
            });
            util.each(output.members, function(name, member) {
              var header = (member.name || name).toLowerCase();
              if (member.location === "headers" && member.type === "map") {
                data[name] = {};
                var location2 = member.isLocationName ? member.name : "";
                var pattern = new RegExp("^" + location2 + "(.+)", "i");
                util.each(r.headers, function(k, v) {
                  var result = k.match(pattern);
                  if (result !== null) {
                    data[name][result[1]] = v;
                  }
                });
              } else if (member.location === "header") {
                if (headers[header] !== void 0) {
                  var value = member.isJsonValue ? util.base64.decode(headers[header]) : headers[header];
                  data[name] = member.toType(value);
                }
              } else if (member.location === "statusCode") {
                data[name] = parseInt(r.statusCode, 10);
              }
            });
            resp.data = data;
          }
          module2.exports = {
            buildRequest,
            extractError,
            extractData,
            generateURI
          };
        }, { "../util": 74, "./helpers": 47 }], 51: [function(require2, module2, exports2) {
          var util = require2("../util");
          var Rest = require2("./rest");
          var Json = require2("./json");
          var JsonBuilder = require2("../json/builder");
          var JsonParser = require2("../json/parser");
          var METHODS_WITHOUT_BODY = ["GET", "HEAD", "DELETE"];
          function unsetContentLength(req) {
            var payloadMember = util.getRequestPayloadShape(req);
            if (payloadMember === void 0 && METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) >= 0) {
              delete req.httpRequest.headers["Content-Length"];
            }
          }
          function populateBody(req) {
            var builder = new JsonBuilder();
            var input = req.service.api.operations[req.operation].input;
            if (input.payload) {
              var params = {};
              var payloadShape = input.members[input.payload];
              params = req.params[input.payload];
              if (payloadShape.type === "structure") {
                req.httpRequest.body = builder.build(params || {}, payloadShape);
                applyContentTypeHeader(req);
              } else if (params !== void 0) {
                req.httpRequest.body = params;
                if (payloadShape.type === "binary" || payloadShape.isStreaming) {
                  applyContentTypeHeader(req, true);
                }
              }
            } else {
              req.httpRequest.body = builder.build(req.params, input);
              applyContentTypeHeader(req);
            }
          }
          function applyContentTypeHeader(req, isBinary) {
            if (!req.httpRequest.headers["Content-Type"]) {
              var type = isBinary ? "binary/octet-stream" : "application/json";
              req.httpRequest.headers["Content-Type"] = type;
            }
          }
          function buildRequest(req) {
            Rest.buildRequest(req);
            if (METHODS_WITHOUT_BODY.indexOf(req.httpRequest.method) < 0) {
              populateBody(req);
            }
          }
          function extractError(resp) {
            Json.extractError(resp);
          }
          function extractData(resp) {
            Rest.extractData(resp);
            var req = resp.request;
            var operation = req.service.api.operations[req.operation];
            var rules = req.service.api.operations[req.operation].output || {};
            var parser;
            var hasEventOutput = operation.hasEventOutput;
            if (rules.payload) {
              var payloadMember = rules.members[rules.payload];
              var body = resp.httpResponse.body;
              if (payloadMember.isEventStream) {
                parser = new JsonParser();
                resp.data[payload] = util.createEventStream(
                  AWS.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : body,
                  parser,
                  payloadMember
                );
              } else if (payloadMember.type === "structure" || payloadMember.type === "list") {
                var parser = new JsonParser();
                resp.data[rules.payload] = parser.parse(body, payloadMember);
              } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
                resp.data[rules.payload] = body;
              } else {
                resp.data[rules.payload] = payloadMember.toType(body);
              }
            } else {
              var data = resp.data;
              Json.extractData(resp);
              resp.data = util.merge(data, resp.data);
            }
          }
          module2.exports = {
            buildRequest,
            extractError,
            extractData,
            unsetContentLength
          };
        }, { "../json/builder": 37, "../json/parser": 38, "../util": 74, "./json": 48, "./rest": 50 }], 52: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var util = require2("../util");
          var Rest = require2("./rest");
          function populateBody(req) {
            var input = req.service.api.operations[req.operation].input;
            var builder = new AWS2.XML.Builder();
            var params = req.params;
            var payload2 = input.payload;
            if (payload2) {
              var payloadMember = input.members[payload2];
              params = params[payload2];
              if (params === void 0)
                return;
              if (payloadMember.type === "structure") {
                var rootElement = payloadMember.name;
                req.httpRequest.body = builder.toXML(params, payloadMember, rootElement, true);
              } else {
                req.httpRequest.body = params;
              }
            } else {
              req.httpRequest.body = builder.toXML(params, input, input.name || input.shape || util.string.upperFirst(req.operation) + "Request");
            }
          }
          function buildRequest(req) {
            Rest.buildRequest(req);
            if (["GET", "HEAD"].indexOf(req.httpRequest.method) < 0) {
              populateBody(req);
            }
          }
          function extractError(resp) {
            Rest.extractError(resp);
            var data;
            try {
              data = new AWS2.XML.Parser().parse(resp.httpResponse.body.toString());
            } catch (e) {
              data = {
                Code: resp.httpResponse.statusCode,
                Message: resp.httpResponse.statusMessage
              };
            }
            if (data.Errors)
              data = data.Errors;
            if (data.Error)
              data = data.Error;
            if (data.Code) {
              resp.error = util.error(new Error(), {
                code: data.Code,
                message: data.Message
              });
            } else {
              resp.error = util.error(new Error(), {
                code: resp.httpResponse.statusCode,
                message: null
              });
            }
          }
          function extractData(resp) {
            Rest.extractData(resp);
            var parser;
            var req = resp.request;
            var body = resp.httpResponse.body;
            var operation = req.service.api.operations[req.operation];
            var output = operation.output;
            var hasEventOutput = operation.hasEventOutput;
            var payload2 = output.payload;
            if (payload2) {
              var payloadMember = output.members[payload2];
              if (payloadMember.isEventStream) {
                parser = new AWS2.XML.Parser();
                resp.data[payload2] = util.createEventStream(
                  AWS2.HttpClient.streamsApiVersion === 2 ? resp.httpResponse.stream : resp.httpResponse.body,
                  parser,
                  payloadMember
                );
              } else if (payloadMember.type === "structure") {
                parser = new AWS2.XML.Parser();
                resp.data[payload2] = parser.parse(body.toString(), payloadMember);
              } else if (payloadMember.type === "binary" || payloadMember.isStreaming) {
                resp.data[payload2] = body;
              } else {
                resp.data[payload2] = payloadMember.toType(body);
              }
            } else if (body.length > 0) {
              parser = new AWS2.XML.Parser();
              var data = parser.parse(body.toString(), output);
              util.update(resp.data, data);
            }
          }
          module2.exports = {
            buildRequest,
            extractError,
            extractData
          };
        }, { "../core": 19, "../util": 74, "./rest": 50 }], 53: [function(require2, module2, exports2) {
          var util = require2("../util");
          function QueryParamSerializer() {
          }
          QueryParamSerializer.prototype.serialize = function(params, shape, fn) {
            serializeStructure("", params, shape, fn);
          };
          function ucfirst(shape) {
            if (shape.isQueryName || shape.api.protocol !== "ec2") {
              return shape.name;
            } else {
              return shape.name[0].toUpperCase() + shape.name.substr(1);
            }
          }
          function serializeStructure(prefix, struct, rules, fn) {
            util.each(rules.members, function(name, member) {
              var value = struct[name];
              if (value === null || value === void 0)
                return;
              var memberName = ucfirst(member);
              memberName = prefix ? prefix + "." + memberName : memberName;
              serializeMember(memberName, value, member, fn);
            });
          }
          function serializeMap(name, map, rules, fn) {
            var i = 1;
            util.each(map, function(key, value) {
              var prefix = rules.flattened ? "." : ".entry.";
              var position = prefix + i++ + ".";
              var keyName = position + (rules.key.name || "key");
              var valueName = position + (rules.value.name || "value");
              serializeMember(name + keyName, key, rules.key, fn);
              serializeMember(name + valueName, value, rules.value, fn);
            });
          }
          function serializeList(name, list, rules, fn) {
            var memberRules = rules.member || {};
            if (list.length === 0) {
              fn.call(this, name, null);
              return;
            }
            util.arrayEach(list, function(v, n) {
              var suffix = "." + (n + 1);
              if (rules.api.protocol === "ec2") {
                suffix = suffix + "";
              } else if (rules.flattened) {
                if (memberRules.name) {
                  var parts = name.split(".");
                  parts.pop();
                  parts.push(ucfirst(memberRules));
                  name = parts.join(".");
                }
              } else {
                suffix = "." + (memberRules.name ? memberRules.name : "member") + suffix;
              }
              serializeMember(name + suffix, v, memberRules, fn);
            });
          }
          function serializeMember(name, value, rules, fn) {
            if (value === null || value === void 0)
              return;
            if (rules.type === "structure") {
              serializeStructure(name, value, rules, fn);
            } else if (rules.type === "list") {
              serializeList(name, value, rules, fn);
            } else if (rules.type === "map") {
              serializeMap(name, value, rules, fn);
            } else {
              fn(name, rules.toWireFormat(value).toString());
            }
          }
          module2.exports = QueryParamSerializer;
        }, { "../util": 74 }], 54: [function(require2, module2, exports2) {
          module2.exports = {
            //provide realtime clock for performance measurement
            now: function now() {
              if (typeof performance !== "undefined" && typeof performance.now === "function") {
                return performance.now();
              }
              return Date.now();
            }
          };
        }, {}], 55: [function(require2, module2, exports2) {
          function isFipsRegion(region) {
            return typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
          }
          function isGlobalRegion(region) {
            return typeof region === "string" && ["aws-global", "aws-us-gov-global"].includes(region);
          }
          function getRealRegion(region) {
            return ["fips-aws-global", "aws-fips", "aws-global"].includes(region) ? "us-east-1" : ["fips-aws-us-gov-global", "aws-us-gov-global"].includes(region) ? "us-gov-west-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "");
          }
          module2.exports = {
            isFipsRegion,
            isGlobalRegion,
            getRealRegion
          };
        }, {}], 56: [function(require2, module2, exports2) {
          var util = require2("./util");
          var regionConfig = require2("./region_config_data.json");
          function generateRegionPrefix(region) {
            if (!region)
              return null;
            var parts = region.split("-");
            if (parts.length < 3)
              return null;
            return parts.slice(0, parts.length - 2).join("-") + "-*";
          }
          function derivedKeys(service) {
            var region = service.config.region;
            var regionPrefix = generateRegionPrefix(region);
            var endpointPrefix = service.api.endpointPrefix;
            return [
              [region, endpointPrefix],
              [regionPrefix, endpointPrefix],
              [region, "*"],
              [regionPrefix, "*"],
              ["*", endpointPrefix],
              [region, "internal-*"],
              ["*", "*"]
            ].map(function(item) {
              return item[0] && item[1] ? item.join("/") : null;
            });
          }
          function applyConfig(service, config) {
            util.each(config, function(key, value) {
              if (key === "globalEndpoint")
                return;
              if (service.config[key] === void 0 || service.config[key] === null) {
                service.config[key] = value;
              }
            });
          }
          function configureEndpoint(service) {
            var keys = derivedKeys(service);
            var useFipsEndpoint = service.config.useFipsEndpoint;
            var useDualstackEndpoint = service.config.useDualstackEndpoint;
            for (var i = 0; i < keys.length; i++) {
              var key = keys[i];
              if (!key)
                continue;
              var rules = useFipsEndpoint ? useDualstackEndpoint ? regionConfig.dualstackFipsRules : regionConfig.fipsRules : useDualstackEndpoint ? regionConfig.dualstackRules : regionConfig.rules;
              if (Object.prototype.hasOwnProperty.call(rules, key)) {
                var config = rules[key];
                if (typeof config === "string") {
                  config = regionConfig.patterns[config];
                }
                service.isGlobalEndpoint = !!config.globalEndpoint;
                if (config.signingRegion) {
                  service.signingRegion = config.signingRegion;
                }
                if (!config.signatureVersion) {
                  config.signatureVersion = "v4";
                }
                var useBearer = (service.api && service.api.signatureVersion) === "bearer";
                applyConfig(service, Object.assign(
                  {},
                  config,
                  { signatureVersion: useBearer ? "bearer" : config.signatureVersion }
                ));
                return;
              }
            }
          }
          function getEndpointSuffix(region) {
            var regionRegexes = {
              "^(us|eu|ap|sa|ca|me)\\-\\w+\\-\\d+$": "amazonaws.com",
              "^cn\\-\\w+\\-\\d+$": "amazonaws.com.cn",
              "^us\\-gov\\-\\w+\\-\\d+$": "amazonaws.com",
              "^us\\-iso\\-\\w+\\-\\d+$": "c2s.ic.gov",
              "^us\\-isob\\-\\w+\\-\\d+$": "sc2s.sgov.gov"
            };
            var defaultSuffix = "amazonaws.com";
            var regexes = Object.keys(regionRegexes);
            for (var i = 0; i < regexes.length; i++) {
              var regionPattern = RegExp(regexes[i]);
              var dnsSuffix = regionRegexes[regexes[i]];
              if (regionPattern.test(region))
                return dnsSuffix;
            }
            return defaultSuffix;
          }
          module2.exports = {
            configureEndpoint,
            getEndpointSuffix
          };
        }, { "./region_config_data.json": 57, "./util": 74 }], 57: [function(require2, module2, exports2) {
          module2.exports = {
            "rules": {
              "*/*": {
                "endpoint": "{service}.{region}.amazonaws.com"
              },
              "cn-*/*": {
                "endpoint": "{service}.{region}.amazonaws.com.cn"
              },
              "us-iso-*/*": "usIso",
              "us-isob-*/*": "usIsob",
              "*/budgets": "globalSSL",
              "*/cloudfront": "globalSSL",
              "*/sts": "globalSSL",
              "*/importexport": {
                "endpoint": "{service}.amazonaws.com",
                "signatureVersion": "v2",
                "globalEndpoint": true
              },
              "*/route53": "globalSSL",
              "cn-*/route53": {
                "endpoint": "{service}.amazonaws.com.cn",
                "globalEndpoint": true,
                "signingRegion": "cn-northwest-1"
              },
              "us-gov-*/route53": "globalGovCloud",
              "us-iso-*/route53": {
                "endpoint": "{service}.c2s.ic.gov",
                "globalEndpoint": true,
                "signingRegion": "us-iso-east-1"
              },
              "us-isob-*/route53": {
                "endpoint": "{service}.sc2s.sgov.gov",
                "globalEndpoint": true,
                "signingRegion": "us-isob-east-1"
              },
              "*/waf": "globalSSL",
              "*/iam": "globalSSL",
              "cn-*/iam": {
                "endpoint": "{service}.cn-north-1.amazonaws.com.cn",
                "globalEndpoint": true,
                "signingRegion": "cn-north-1"
              },
              "us-iso-*/iam": {
                "endpoint": "{service}.us-iso-east-1.c2s.ic.gov",
                "globalEndpoint": true,
                "signingRegion": "us-iso-east-1"
              },
              "us-gov-*/iam": "globalGovCloud",
              "*/ce": {
                "endpoint": "{service}.us-east-1.amazonaws.com",
                "globalEndpoint": true,
                "signingRegion": "us-east-1"
              },
              "cn-*/ce": {
                "endpoint": "{service}.cn-northwest-1.amazonaws.com.cn",
                "globalEndpoint": true,
                "signingRegion": "cn-northwest-1"
              },
              "us-gov-*/sts": {
                "endpoint": "{service}.{region}.amazonaws.com"
              },
              "us-gov-west-1/s3": "s3signature",
              "us-west-1/s3": "s3signature",
              "us-west-2/s3": "s3signature",
              "eu-west-1/s3": "s3signature",
              "ap-southeast-1/s3": "s3signature",
              "ap-southeast-2/s3": "s3signature",
              "ap-northeast-1/s3": "s3signature",
              "sa-east-1/s3": "s3signature",
              "us-east-1/s3": {
                "endpoint": "{service}.amazonaws.com",
                "signatureVersion": "s3"
              },
              "us-east-1/sdb": {
                "endpoint": "{service}.amazonaws.com",
                "signatureVersion": "v2"
              },
              "*/sdb": {
                "endpoint": "{service}.{region}.amazonaws.com",
                "signatureVersion": "v2"
              },
              "*/resource-explorer-2": "dualstackByDefault",
              "*/kendra-ranking": "dualstackByDefault",
              "*/internetmonitor": "dualstackByDefault",
              "*/codecatalyst": "globalDualstackByDefault"
            },
            "fipsRules": {
              "*/*": "fipsStandard",
              "us-gov-*/*": "fipsStandard",
              "us-iso-*/*": {
                "endpoint": "{service}-fips.{region}.c2s.ic.gov"
              },
              "us-iso-*/dms": "usIso",
              "us-isob-*/*": {
                "endpoint": "{service}-fips.{region}.sc2s.sgov.gov"
              },
              "us-isob-*/dms": "usIsob",
              "cn-*/*": {
                "endpoint": "{service}-fips.{region}.amazonaws.com.cn"
              },
              "*/api.ecr": "fips.api.ecr",
              "*/api.sagemaker": "fips.api.sagemaker",
              "*/batch": "fipsDotPrefix",
              "*/eks": "fipsDotPrefix",
              "*/models.lex": "fips.models.lex",
              "*/runtime.lex": "fips.runtime.lex",
              "*/runtime.sagemaker": {
                "endpoint": "runtime-fips.sagemaker.{region}.amazonaws.com"
              },
              "*/iam": "fipsWithoutRegion",
              "*/route53": "fipsWithoutRegion",
              "*/transcribe": "fipsDotPrefix",
              "*/waf": "fipsWithoutRegion",
              "us-gov-*/transcribe": "fipsDotPrefix",
              "us-gov-*/api.ecr": "fips.api.ecr",
              "us-gov-*/api.sagemaker": "fips.api.sagemaker",
              "us-gov-*/models.lex": "fips.models.lex",
              "us-gov-*/runtime.lex": "fips.runtime.lex",
              "us-gov-*/acm-pca": "fipsWithServiceOnly",
              "us-gov-*/batch": "fipsWithServiceOnly",
              "us-gov-*/cloudformation": "fipsWithServiceOnly",
              "us-gov-*/config": "fipsWithServiceOnly",
              "us-gov-*/eks": "fipsWithServiceOnly",
              "us-gov-*/elasticmapreduce": "fipsWithServiceOnly",
              "us-gov-*/identitystore": "fipsWithServiceOnly",
              "us-gov-*/dynamodb": "fipsWithServiceOnly",
              "us-gov-*/elasticloadbalancing": "fipsWithServiceOnly",
              "us-gov-*/guardduty": "fipsWithServiceOnly",
              "us-gov-*/monitoring": "fipsWithServiceOnly",
              "us-gov-*/resource-groups": "fipsWithServiceOnly",
              "us-gov-*/runtime.sagemaker": "fipsWithServiceOnly",
              "us-gov-*/servicecatalog-appregistry": "fipsWithServiceOnly",
              "us-gov-*/servicequotas": "fipsWithServiceOnly",
              "us-gov-*/ssm": "fipsWithServiceOnly",
              "us-gov-*/sts": "fipsWithServiceOnly",
              "us-gov-*/support": "fipsWithServiceOnly",
              "us-gov-west-1/states": "fipsWithServiceOnly",
              "us-iso-east-1/elasticfilesystem": {
                "endpoint": "elasticfilesystem-fips.{region}.c2s.ic.gov"
              },
              "us-gov-west-1/organizations": "fipsWithServiceOnly",
              "us-gov-west-1/route53": {
                "endpoint": "route53.us-gov.amazonaws.com"
              },
              "*/resource-explorer-2": "fipsDualstackByDefault",
              "*/kendra-ranking": "dualstackByDefault",
              "*/internetmonitor": "dualstackByDefault",
              "*/codecatalyst": "fipsGlobalDualstackByDefault"
            },
            "dualstackRules": {
              "*/*": {
                "endpoint": "{service}.{region}.api.aws"
              },
              "cn-*/*": {
                "endpoint": "{service}.{region}.api.amazonwebservices.com.cn"
              },
              "*/s3": "dualstackLegacy",
              "cn-*/s3": "dualstackLegacyCn",
              "*/s3-control": "dualstackLegacy",
              "cn-*/s3-control": "dualstackLegacyCn",
              "ap-south-1/ec2": "dualstackLegacyEc2",
              "eu-west-1/ec2": "dualstackLegacyEc2",
              "sa-east-1/ec2": "dualstackLegacyEc2",
              "us-east-1/ec2": "dualstackLegacyEc2",
              "us-east-2/ec2": "dualstackLegacyEc2",
              "us-west-2/ec2": "dualstackLegacyEc2"
            },
            "dualstackFipsRules": {
              "*/*": {
                "endpoint": "{service}-fips.{region}.api.aws"
              },
              "cn-*/*": {
                "endpoint": "{service}-fips.{region}.api.amazonwebservices.com.cn"
              },
              "*/s3": "dualstackFipsLegacy",
              "cn-*/s3": "dualstackFipsLegacyCn",
              "*/s3-control": "dualstackFipsLegacy",
              "cn-*/s3-control": "dualstackFipsLegacyCn"
            },
            "patterns": {
              "globalSSL": {
                "endpoint": "https://{service}.amazonaws.com",
                "globalEndpoint": true,
                "signingRegion": "us-east-1"
              },
              "globalGovCloud": {
                "endpoint": "{service}.us-gov.amazonaws.com",
                "globalEndpoint": true,
                "signingRegion": "us-gov-west-1"
              },
              "s3signature": {
                "endpoint": "{service}.{region}.amazonaws.com",
                "signatureVersion": "s3"
              },
              "usIso": {
                "endpoint": "{service}.{region}.c2s.ic.gov"
              },
              "usIsob": {
                "endpoint": "{service}.{region}.sc2s.sgov.gov"
              },
              "fipsStandard": {
                "endpoint": "{service}-fips.{region}.amazonaws.com"
              },
              "fipsDotPrefix": {
                "endpoint": "fips.{service}.{region}.amazonaws.com"
              },
              "fipsWithoutRegion": {
                "endpoint": "{service}-fips.amazonaws.com"
              },
              "fips.api.ecr": {
                "endpoint": "ecr-fips.{region}.amazonaws.com"
              },
              "fips.api.sagemaker": {
                "endpoint": "api-fips.sagemaker.{region}.amazonaws.com"
              },
              "fips.models.lex": {
                "endpoint": "models-fips.lex.{region}.amazonaws.com"
              },
              "fips.runtime.lex": {
                "endpoint": "runtime-fips.lex.{region}.amazonaws.com"
              },
              "fipsWithServiceOnly": {
                "endpoint": "{service}.{region}.amazonaws.com"
              },
              "dualstackLegacy": {
                "endpoint": "{service}.dualstack.{region}.amazonaws.com"
              },
              "dualstackLegacyCn": {
                "endpoint": "{service}.dualstack.{region}.amazonaws.com.cn"
              },
              "dualstackFipsLegacy": {
                "endpoint": "{service}-fips.dualstack.{region}.amazonaws.com"
              },
              "dualstackFipsLegacyCn": {
                "endpoint": "{service}-fips.dualstack.{region}.amazonaws.com.cn"
              },
              "dualstackLegacyEc2": {
                "endpoint": "api.ec2.{region}.aws"
              },
              "dualstackByDefault": {
                "endpoint": "{service}.{region}.api.aws"
              },
              "fipsDualstackByDefault": {
                "endpoint": "{service}-fips.{region}.api.aws"
              },
              "globalDualstackByDefault": {
                "endpoint": "{service}.global.api.aws"
              },
              "fipsGlobalDualstackByDefault": {
                "endpoint": "{service}-fips.global.api.aws"
              }
            }
          };
        }, {}], 58: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var AWS2 = require2("./core");
              var AcceptorStateMachine = require2("./state_machine");
              var inherit = AWS2.util.inherit;
              var domain = AWS2.util.domain;
              var jmespath = require2("jmespath");
              var hardErrorStates = { success: 1, error: 1, complete: 1 };
              function isTerminalState(machine) {
                return Object.prototype.hasOwnProperty.call(hardErrorStates, machine._asm.currentState);
              }
              var fsm = new AcceptorStateMachine();
              fsm.setupStates = function() {
                var transition = function(_, done) {
                  var self2 = this;
                  self2._haltHandlersOnError = false;
                  self2.emit(self2._asm.currentState, function(err) {
                    if (err) {
                      if (isTerminalState(self2)) {
                        if (domain && self2.domain instanceof domain.Domain) {
                          err.domainEmitter = self2;
                          err.domain = self2.domain;
                          err.domainThrown = false;
                          self2.domain.emit("error", err);
                        } else {
                          throw err;
                        }
                      } else {
                        self2.response.error = err;
                        done(err);
                      }
                    } else {
                      done(self2.response.error);
                    }
                  });
                };
                this.addState("validate", "build", "error", transition);
                this.addState("build", "afterBuild", "restart", transition);
                this.addState("afterBuild", "sign", "restart", transition);
                this.addState("sign", "send", "retry", transition);
                this.addState("retry", "afterRetry", "afterRetry", transition);
                this.addState("afterRetry", "sign", "error", transition);
                this.addState("send", "validateResponse", "retry", transition);
                this.addState("validateResponse", "extractData", "extractError", transition);
                this.addState("extractError", "extractData", "retry", transition);
                this.addState("extractData", "success", "retry", transition);
                this.addState("restart", "build", "error", transition);
                this.addState("success", "complete", "complete", transition);
                this.addState("error", "complete", "complete", transition);
                this.addState("complete", null, null, transition);
              };
              fsm.setupStates();
              AWS2.Request = inherit({
                /**
                 * Creates a request for an operation on a given service with
                 * a set of input parameters.
                 *
                 * @param service [AWS.Service] the service to perform the operation on
                 * @param operation [String] the operation to perform on the service
                 * @param params [Object] parameters to send to the operation.
                 *   See the operation's documentation for the format of the
                 *   parameters.
                 */
                constructor: function Request(service, operation, params) {
                  var endpoint = service.endpoint;
                  var region = service.config.region;
                  var customUserAgent = service.config.customUserAgent;
                  if (service.signingRegion) {
                    region = service.signingRegion;
                  } else if (service.isGlobalEndpoint) {
                    region = "us-east-1";
                  }
                  this.domain = domain && domain.active;
                  this.service = service;
                  this.operation = operation;
                  this.params = params || {};
                  this.httpRequest = new AWS2.HttpRequest(endpoint, region);
                  this.httpRequest.appendToUserAgent(customUserAgent);
                  this.startTime = service.getSkewCorrectedDate();
                  this.response = new AWS2.Response(this);
                  this._asm = new AcceptorStateMachine(fsm.states, "validate");
                  this._haltHandlersOnError = false;
                  AWS2.SequentialExecutor.call(this);
                  this.emit = this.emitEvent;
                },
                /**
                 * @!group Sending a Request
                 */
                /**
                 * @overload send(callback = null)
                 *   Sends the request object.
                 *
                 *   @callback callback function(err, data)
                 *     If a callback is supplied, it is called when a response is returned
                 *     from the service.
                 *     @context [AWS.Request] the request object being sent.
                 *     @param err [Error] the error object returned from the request.
                 *       Set to `null` if the request is successful.
                 *     @param data [Object] the de-serialized data returned from
                 *       the request. Set to `null` if a request error occurs.
                 *   @example Sending a request with a callback
                 *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
                 *     request.send(function(err, data) { console.log(err, data); });
                 *   @example Sending a request with no callback (using event handlers)
                 *     request = s3.putObject({Bucket: 'bucket', Key: 'key'});
                 *     request.on('complete', function(response) { ... }); // register a callback
                 *     request.send();
                 */
                send: function send(callback) {
                  if (callback) {
                    this.httpRequest.appendToUserAgent("callback");
                    this.on("complete", function(resp) {
                      callback.call(resp, resp.error, resp.data);
                    });
                  }
                  this.runTo();
                  return this.response;
                },
                /**
                 * @!method  promise()
                 *   Sends the request and returns a 'thenable' promise.
                 *
                 *   Two callbacks can be provided to the `then` method on the returned promise.
                 *   The first callback will be called if the promise is fulfilled, and the second
                 *   callback will be called if the promise is rejected.
                 *   @callback fulfilledCallback function(data)
                 *     Called if the promise is fulfilled.
                 *     @param data [Object] the de-serialized data returned from the request.
                 *   @callback rejectedCallback function(error)
                 *     Called if the promise is rejected.
                 *     @param error [Error] the error object returned from the request.
                 *   @return [Promise] A promise that represents the state of the request.
                 *   @example Sending a request using promises.
                 *     var request = s3.putObject({Bucket: 'bucket', Key: 'key'});
                 *     var result = request.promise();
                 *     result.then(function(data) { ... }, function(error) { ... });
                 */
                /**
                 * @api private
                 */
                build: function build(callback) {
                  return this.runTo("send", callback);
                },
                /**
                 * @api private
                 */
                runTo: function runTo(state, done) {
                  this._asm.runTo(state, done, this);
                  return this;
                },
                /**
                 * Aborts a request, emitting the error and complete events.
                 *
                 * @!macro nobrowser
                 * @example Aborting a request after sending
                 *   var params = {
                 *     Bucket: 'bucket', Key: 'key',
                 *     Body: Buffer.alloc(1024 * 1024 * 5) // 5MB payload
                 *   };
                 *   var request = s3.putObject(params);
                 *   request.send(function (err, data) {
                 *     if (err) console.log("Error:", err.code, err.message);
                 *     else console.log(data);
                 *   });
                 *
                 *   // abort request in 1 second
                 *   setTimeout(request.abort.bind(request), 1000);
                 *
                 *   // prints "Error: RequestAbortedError Request aborted by user"
                 * @return [AWS.Request] the same request object, for chaining.
                 * @since v1.4.0
                 */
                abort: function abort() {
                  this.removeAllListeners("validateResponse");
                  this.removeAllListeners("extractError");
                  this.on("validateResponse", function addAbortedError(resp) {
                    resp.error = AWS2.util.error(new Error("Request aborted by user"), {
                      code: "RequestAbortedError",
                      retryable: false
                    });
                  });
                  if (this.httpRequest.stream && !this.httpRequest.stream.didCallback) {
                    this.httpRequest.stream.abort();
                    if (this.httpRequest._abortCallback) {
                      this.httpRequest._abortCallback();
                    } else {
                      this.removeAllListeners("send");
                    }
                  }
                  return this;
                },
                /**
                 * Iterates over each page of results given a pageable request, calling
                 * the provided callback with each page of data. After all pages have been
                 * retrieved, the callback is called with `null` data.
                 *
                 * @note This operation can generate multiple requests to a service.
                 * @example Iterating over multiple pages of objects in an S3 bucket
                 *   var pages = 1;
                 *   s3.listObjects().eachPage(function(err, data) {
                 *     if (err) return;
                 *     console.log("Page", pages++);
                 *     console.log(data);
                 *   });
                 * @example Iterating over multiple pages with an asynchronous callback
                 *   s3.listObjects(params).eachPage(function(err, data, done) {
                 *     doSomethingAsyncAndOrExpensive(function() {
                 *       // The next page of results isn't fetched until done is called
                 *       done();
                 *     });
                 *   });
                 * @callback callback function(err, data, [doneCallback])
                 *   Called with each page of resulting data from the request. If the
                 *   optional `doneCallback` is provided in the function, it must be called
                 *   when the callback is complete.
                 *
                 *   @param err [Error] an error object, if an error occurred.
                 *   @param data [Object] a single page of response data. If there is no
                 *     more data, this object will be `null`.
                 *   @param doneCallback [Function] an optional done callback. If this
                 *     argument is defined in the function declaration, it should be called
                 *     when the next page is ready to be retrieved. This is useful for
                 *     controlling serial pagination across asynchronous operations.
                 *   @return [Boolean] if the callback returns `false`, pagination will
                 *     stop.
                 *
                 * @see AWS.Request.eachItem
                 * @see AWS.Response.nextPage
                 * @since v1.4.0
                 */
                eachPage: function eachPage(callback) {
                  callback = AWS2.util.fn.makeAsync(callback, 3);
                  function wrappedCallback(response) {
                    callback.call(response, response.error, response.data, function(result) {
                      if (result === false)
                        return;
                      if (response.hasNextPage()) {
                        response.nextPage().on("complete", wrappedCallback).send();
                      } else {
                        callback.call(response, null, null, AWS2.util.fn.noop);
                      }
                    });
                  }
                  this.on("complete", wrappedCallback).send();
                },
                /**
                 * Enumerates over individual items of a request, paging the responses if
                 * necessary.
                 *
                 * @api experimental
                 * @since v1.4.0
                 */
                eachItem: function eachItem(callback) {
                  var self2 = this;
                  function wrappedCallback(err, data) {
                    if (err)
                      return callback(err, null);
                    if (data === null)
                      return callback(null, null);
                    var config = self2.service.paginationConfig(self2.operation);
                    var resultKey = config.resultKey;
                    if (Array.isArray(resultKey))
                      resultKey = resultKey[0];
                    var items = jmespath.search(data, resultKey);
                    var continueIteration = true;
                    AWS2.util.arrayEach(items, function(item) {
                      continueIteration = callback(null, item);
                      if (continueIteration === false) {
                        return AWS2.util.abort;
                      }
                    });
                    return continueIteration;
                  }
                  this.eachPage(wrappedCallback);
                },
                /**
                 * @return [Boolean] whether the operation can return multiple pages of
                 *   response data.
                 * @see AWS.Response.eachPage
                 * @since v1.4.0
                 */
                isPageable: function isPageable() {
                  return this.service.paginationConfig(this.operation) ? true : false;
                },
                /**
                 * Sends the request and converts the request object into a readable stream
                 * that can be read from or piped into a writable stream.
                 *
                 * @note The data read from a readable stream contains only
                 *   the raw HTTP body contents.
                 * @example Manually reading from a stream
                 *   request.createReadStream().on('data', function(data) {
                 *     console.log("Got data:", data.toString());
                 *   });
                 * @example Piping a request body into a file
                 *   var out = fs.createWriteStream('/path/to/outfile.jpg');
                 *   s3.service.getObject(params).createReadStream().pipe(out);
                 * @return [Stream] the readable stream object that can be piped
                 *   or read from (by registering 'data' event listeners).
                 * @!macro nobrowser
                 */
                createReadStream: function createReadStream() {
                  var streams = AWS2.util.stream;
                  var req = this;
                  var stream = null;
                  if (AWS2.HttpClient.streamsApiVersion === 2) {
                    stream = new streams.PassThrough();
                    process.nextTick(function() {
                      req.send();
                    });
                  } else {
                    stream = new streams.Stream();
                    stream.readable = true;
                    stream.sent = false;
                    stream.on("newListener", function(event) {
                      if (!stream.sent && event === "data") {
                        stream.sent = true;
                        process.nextTick(function() {
                          req.send();
                        });
                      }
                    });
                  }
                  this.on("error", function(err) {
                    stream.emit("error", err);
                  });
                  this.on("httpHeaders", function streamHeaders(statusCode, headers, resp) {
                    if (statusCode < 300) {
                      req.removeListener("httpData", AWS2.EventListeners.Core.HTTP_DATA);
                      req.removeListener("httpError", AWS2.EventListeners.Core.HTTP_ERROR);
                      req.on("httpError", function streamHttpError(error) {
                        resp.error = error;
                        resp.error.retryable = false;
                      });
                      var shouldCheckContentLength = false;
                      var expectedLen;
                      if (req.httpRequest.method !== "HEAD") {
                        expectedLen = parseInt(headers["content-length"], 10);
                      }
                      if (expectedLen !== void 0 && !isNaN(expectedLen) && expectedLen >= 0) {
                        shouldCheckContentLength = true;
                        var receivedLen = 0;
                      }
                      var checkContentLengthAndEmit = function checkContentLengthAndEmit2() {
                        if (shouldCheckContentLength && receivedLen !== expectedLen) {
                          stream.emit("error", AWS2.util.error(
                            new Error("Stream content length mismatch. Received " + receivedLen + " of " + expectedLen + " bytes."),
                            { code: "StreamContentLengthMismatch" }
                          ));
                        } else if (AWS2.HttpClient.streamsApiVersion === 2) {
                          stream.end();
                        } else {
                          stream.emit("end");
                        }
                      };
                      var httpStream = resp.httpResponse.createUnbufferedStream();
                      if (AWS2.HttpClient.streamsApiVersion === 2) {
                        if (shouldCheckContentLength) {
                          var lengthAccumulator = new streams.PassThrough();
                          lengthAccumulator._write = function(chunk) {
                            if (chunk && chunk.length) {
                              receivedLen += chunk.length;
                            }
                            return streams.PassThrough.prototype._write.apply(this, arguments);
                          };
                          lengthAccumulator.on("end", checkContentLengthAndEmit);
                          stream.on("error", function(err) {
                            shouldCheckContentLength = false;
                            httpStream.unpipe(lengthAccumulator);
                            lengthAccumulator.emit("end");
                            lengthAccumulator.end();
                          });
                          httpStream.pipe(lengthAccumulator).pipe(stream, { end: false });
                        } else {
                          httpStream.pipe(stream);
                        }
                      } else {
                        if (shouldCheckContentLength) {
                          httpStream.on("data", function(arg) {
                            if (arg && arg.length) {
                              receivedLen += arg.length;
                            }
                          });
                        }
                        httpStream.on("data", function(arg) {
                          stream.emit("data", arg);
                        });
                        httpStream.on("end", checkContentLengthAndEmit);
                      }
                      httpStream.on("error", function(err) {
                        shouldCheckContentLength = false;
                        stream.emit("error", err);
                      });
                    }
                  });
                  return stream;
                },
                /**
                 * @param [Array,Response] args This should be the response object,
                 *   or an array of args to send to the event.
                 * @api private
                 */
                emitEvent: function emit(eventName, args, done) {
                  if (typeof args === "function") {
                    done = args;
                    args = null;
                  }
                  if (!done)
                    done = function() {
                    };
                  if (!args)
                    args = this.eventParameters(eventName, this.response);
                  var origEmit = AWS2.SequentialExecutor.prototype.emit;
                  origEmit.call(this, eventName, args, function(err) {
                    if (err)
                      this.response.error = err;
                    done.call(this, err);
                  });
                },
                /**
                 * @api private
                 */
                eventParameters: function eventParameters(eventName) {
                  switch (eventName) {
                    case "restart":
                    case "validate":
                    case "sign":
                    case "build":
                    case "afterValidate":
                    case "afterBuild":
                      return [this];
                    case "error":
                      return [this.response.error, this.response];
                    default:
                      return [this.response];
                  }
                },
                /**
                 * @api private
                 */
                presign: function presign(expires, callback) {
                  if (!callback && typeof expires === "function") {
                    callback = expires;
                    expires = null;
                  }
                  return new AWS2.Signers.Presign().sign(this.toGet(), expires, callback);
                },
                /**
                 * @api private
                 */
                isPresigned: function isPresigned() {
                  return Object.prototype.hasOwnProperty.call(this.httpRequest.headers, "presigned-expires");
                },
                /**
                 * @api private
                 */
                toUnauthenticated: function toUnauthenticated() {
                  this._unAuthenticated = true;
                  this.removeListener("validate", AWS2.EventListeners.Core.VALIDATE_CREDENTIALS);
                  this.removeListener("sign", AWS2.EventListeners.Core.SIGN);
                  return this;
                },
                /**
                 * @api private
                 */
                toGet: function toGet() {
                  if (this.service.api.protocol === "query" || this.service.api.protocol === "ec2") {
                    this.removeListener("build", this.buildAsGet);
                    this.addListener("build", this.buildAsGet);
                  }
                  return this;
                },
                /**
                 * @api private
                 */
                buildAsGet: function buildAsGet(request) {
                  request.httpRequest.method = "GET";
                  request.httpRequest.path = request.service.endpoint.path + "?" + request.httpRequest.body;
                  request.httpRequest.body = "";
                  delete request.httpRequest.headers["Content-Length"];
                  delete request.httpRequest.headers["Content-Type"];
                },
                /**
                 * @api private
                 */
                haltHandlersOnError: function haltHandlersOnError() {
                  this._haltHandlersOnError = true;
                }
              });
              AWS2.Request.addPromisesToClass = function addPromisesToClass(PromiseDependency) {
                this.prototype.promise = function promise() {
                  var self2 = this;
                  this.httpRequest.appendToUserAgent("promise");
                  return new PromiseDependency(function(resolve, reject) {
                    self2.on("complete", function(resp) {
                      if (resp.error) {
                        reject(resp.error);
                      } else {
                        resolve(Object.defineProperty(
                          resp.data || {},
                          "$response",
                          { value: resp }
                        ));
                      }
                    });
                    self2.runTo();
                  });
                };
              };
              AWS2.Request.deletePromisesFromClass = function deletePromisesFromClass() {
                delete this.prototype.promise;
              };
              AWS2.util.addPromises(AWS2.Request);
              AWS2.util.mixin(AWS2.Request, AWS2.SequentialExecutor);
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./core": 19, "./state_machine": 73, "_process": 91, "jmespath": 90 }], 59: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          var inherit = AWS2.util.inherit;
          var jmespath = require2("jmespath");
          function CHECK_ACCEPTORS(resp) {
            var waiter = resp.request._waiter;
            var acceptors = waiter.config.acceptors;
            var acceptorMatched = false;
            var state = "retry";
            acceptors.forEach(function(acceptor) {
              if (!acceptorMatched) {
                var matcher = waiter.matchers[acceptor.matcher];
                if (matcher && matcher(resp, acceptor.expected, acceptor.argument)) {
                  acceptorMatched = true;
                  state = acceptor.state;
                }
              }
            });
            if (!acceptorMatched && resp.error)
              state = "failure";
            if (state === "success") {
              waiter.setSuccess(resp);
            } else {
              waiter.setError(resp, state === "retry");
            }
          }
          AWS2.ResourceWaiter = inherit({
            /**
             * Waits for a given state on a service object
             * @param service [Service] the service object to wait on
             * @param state [String] the state (defined in waiter configuration) to wait
             *   for.
             * @example Create a waiter for running EC2 instances
             *   var ec2 = new AWS.EC2;
             *   var waiter = new AWS.ResourceWaiter(ec2, 'instanceRunning');
             */
            constructor: function constructor(service, state) {
              this.service = service;
              this.state = state;
              this.loadWaiterConfig(this.state);
            },
            service: null,
            state: null,
            config: null,
            matchers: {
              path: function(resp, expected, argument) {
                try {
                  var result = jmespath.search(resp.data, argument);
                } catch (err) {
                  return false;
                }
                return jmespath.strictDeepEqual(result, expected);
              },
              pathAll: function(resp, expected, argument) {
                try {
                  var results = jmespath.search(resp.data, argument);
                } catch (err) {
                  return false;
                }
                if (!Array.isArray(results))
                  results = [results];
                var numResults = results.length;
                if (!numResults)
                  return false;
                for (var ind = 0; ind < numResults; ind++) {
                  if (!jmespath.strictDeepEqual(results[ind], expected)) {
                    return false;
                  }
                }
                return true;
              },
              pathAny: function(resp, expected, argument) {
                try {
                  var results = jmespath.search(resp.data, argument);
                } catch (err) {
                  return false;
                }
                if (!Array.isArray(results))
                  results = [results];
                var numResults = results.length;
                for (var ind = 0; ind < numResults; ind++) {
                  if (jmespath.strictDeepEqual(results[ind], expected)) {
                    return true;
                  }
                }
                return false;
              },
              status: function(resp, expected) {
                var statusCode = resp.httpResponse.statusCode;
                return typeof statusCode === "number" && statusCode === expected;
              },
              error: function(resp, expected) {
                if (typeof expected === "string" && resp.error) {
                  return expected === resp.error.code;
                }
                return expected === !!resp.error;
              }
            },
            listeners: new AWS2.SequentialExecutor().addNamedListeners(function(add) {
              add("RETRY_CHECK", "retry", function(resp) {
                var waiter = resp.request._waiter;
                if (resp.error && resp.error.code === "ResourceNotReady") {
                  resp.error.retryDelay = (waiter.config.delay || 0) * 1e3;
                }
              });
              add("CHECK_OUTPUT", "extractData", CHECK_ACCEPTORS);
              add("CHECK_ERROR", "extractError", CHECK_ACCEPTORS);
            }),
            /**
             * @return [AWS.Request]
             */
            wait: function wait(params, callback) {
              if (typeof params === "function") {
                callback = params;
                params = void 0;
              }
              if (params && params.$waiter) {
                params = AWS2.util.copy(params);
                if (typeof params.$waiter.delay === "number") {
                  this.config.delay = params.$waiter.delay;
                }
                if (typeof params.$waiter.maxAttempts === "number") {
                  this.config.maxAttempts = params.$waiter.maxAttempts;
                }
                delete params.$waiter;
              }
              var request = this.service.makeRequest(this.config.operation, params);
              request._waiter = this;
              request.response.maxRetries = this.config.maxAttempts;
              request.addListeners(this.listeners);
              if (callback)
                request.send(callback);
              return request;
            },
            setSuccess: function setSuccess(resp) {
              resp.error = null;
              resp.data = resp.data || {};
              resp.request.removeAllListeners("extractData");
            },
            setError: function setError(resp, retryable) {
              resp.data = null;
              resp.error = AWS2.util.error(resp.error || new Error(), {
                code: "ResourceNotReady",
                message: "Resource is not in the state " + this.state,
                retryable
              });
            },
            /**
             * Loads waiter configuration from API configuration
             *
             * @api private
             */
            loadWaiterConfig: function loadWaiterConfig(state) {
              if (!this.service.api.waiters[state]) {
                throw new AWS2.util.error(new Error(), {
                  code: "StateNotFoundError",
                  message: "State " + state + " not found."
                });
              }
              this.config = AWS2.util.copy(this.service.api.waiters[state]);
            }
          });
        }, { "./core": 19, "jmespath": 90 }], 60: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          var inherit = AWS2.util.inherit;
          var jmespath = require2("jmespath");
          AWS2.Response = inherit({
            /**
             * @api private
             */
            constructor: function Response(request) {
              this.request = request;
              this.data = null;
              this.error = null;
              this.retryCount = 0;
              this.redirectCount = 0;
              this.httpResponse = new AWS2.HttpResponse();
              if (request) {
                this.maxRetries = request.service.numRetries();
                this.maxRedirects = request.service.config.maxRedirects;
              }
            },
            /**
             * Creates a new request for the next page of response data, calling the
             * callback with the page data if a callback is provided.
             *
             * @callback callback function(err, data)
             *   Called when a page of data is returned from the next request.
             *
             *   @param err [Error] an error object, if an error occurred in the request
             *   @param data [Object] the next page of data, or null, if there are no
             *     more pages left.
             * @return [AWS.Request] the request object for the next page of data
             * @return [null] if no callback is provided and there are no pages left
             *   to retrieve.
             * @since v1.4.0
             */
            nextPage: function nextPage(callback) {
              var config;
              var service = this.request.service;
              var operation = this.request.operation;
              try {
                config = service.paginationConfig(operation, true);
              } catch (e) {
                this.error = e;
              }
              if (!this.hasNextPage()) {
                if (callback)
                  callback(this.error, null);
                else if (this.error)
                  throw this.error;
                return null;
              }
              var params = AWS2.util.copy(this.request.params);
              if (!this.nextPageTokens) {
                return callback ? callback(null, null) : null;
              } else {
                var inputTokens = config.inputToken;
                if (typeof inputTokens === "string")
                  inputTokens = [inputTokens];
                for (var i = 0; i < inputTokens.length; i++) {
                  params[inputTokens[i]] = this.nextPageTokens[i];
                }
                return service.makeRequest(this.request.operation, params, callback);
              }
            },
            /**
             * @return [Boolean] whether more pages of data can be returned by further
             *   requests
             * @since v1.4.0
             */
            hasNextPage: function hasNextPage() {
              this.cacheNextPageTokens();
              if (this.nextPageTokens)
                return true;
              if (this.nextPageTokens === void 0)
                return void 0;
              else
                return false;
            },
            /**
             * @api private
             */
            cacheNextPageTokens: function cacheNextPageTokens() {
              if (Object.prototype.hasOwnProperty.call(this, "nextPageTokens"))
                return this.nextPageTokens;
              this.nextPageTokens = void 0;
              var config = this.request.service.paginationConfig(this.request.operation);
              if (!config)
                return this.nextPageTokens;
              this.nextPageTokens = null;
              if (config.moreResults) {
                if (!jmespath.search(this.data, config.moreResults)) {
                  return this.nextPageTokens;
                }
              }
              var exprs = config.outputToken;
              if (typeof exprs === "string")
                exprs = [exprs];
              AWS2.util.arrayEach.call(this, exprs, function(expr) {
                var output = jmespath.search(this.data, expr);
                if (output) {
                  this.nextPageTokens = this.nextPageTokens || [];
                  this.nextPageTokens.push(output);
                }
              });
              return this.nextPageTokens;
            }
          });
        }, { "./core": 19, "jmespath": 90 }], 61: [function(require2, module2, exports2) {
          var AWS2 = require2("./core");
          AWS2.SequentialExecutor = AWS2.util.inherit({
            constructor: function SequentialExecutor() {
              this._events = {};
            },
            /**
             * @api private
             */
            listeners: function listeners(eventName) {
              return this._events[eventName] ? this._events[eventName].slice(0) : [];
            },
            on: function on(eventName, listener, toHead) {
              if (this._events[eventName]) {
                toHead ? this._events[eventName].unshift(listener) : this._events[eventName].push(listener);
              } else {
                this._events[eventName] = [listener];
              }
              return this;
            },
            onAsync: function onAsync(eventName, listener, toHead) {
              listener._isAsync = true;
              return this.on(eventName, listener, toHead);
            },
            removeListener: function removeListener(eventName, listener) {
              var listeners = this._events[eventName];
              if (listeners) {
                var length = listeners.length;
                var position = -1;
                for (var i = 0; i < length; ++i) {
                  if (listeners[i] === listener) {
                    position = i;
                  }
                }
                if (position > -1) {
                  listeners.splice(position, 1);
                }
              }
              return this;
            },
            removeAllListeners: function removeAllListeners(eventName) {
              if (eventName) {
                delete this._events[eventName];
              } else {
                this._events = {};
              }
              return this;
            },
            /**
             * @api private
             */
            emit: function emit(eventName, eventArgs, doneCallback) {
              if (!doneCallback)
                doneCallback = function() {
                };
              var listeners = this.listeners(eventName);
              var count = listeners.length;
              this.callListeners(listeners, eventArgs, doneCallback);
              return count > 0;
            },
            /**
             * @api private
             */
            callListeners: function callListeners(listeners, args, doneCallback, prevError) {
              var self2 = this;
              var error = prevError || null;
              function callNextListener(err) {
                if (err) {
                  error = AWS2.util.error(error || new Error(), err);
                  if (self2._haltHandlersOnError) {
                    return doneCallback.call(self2, error);
                  }
                }
                self2.callListeners(listeners, args, doneCallback, error);
              }
              while (listeners.length > 0) {
                var listener = listeners.shift();
                if (listener._isAsync) {
                  listener.apply(self2, args.concat([callNextListener]));
                  return;
                } else {
                  try {
                    listener.apply(self2, args);
                  } catch (err) {
                    error = AWS2.util.error(error || new Error(), err);
                  }
                  if (error && self2._haltHandlersOnError) {
                    doneCallback.call(self2, error);
                    return;
                  }
                }
              }
              doneCallback.call(self2, error);
            },
            /**
             * Adds or copies a set of listeners from another list of
             * listeners or SequentialExecutor object.
             *
             * @param listeners [map<String,Array<Function>>, AWS.SequentialExecutor]
             *   a list of events and callbacks, or an event emitter object
             *   containing listeners to add to this emitter object.
             * @return [AWS.SequentialExecutor] the emitter object, for chaining.
             * @example Adding listeners from a map of listeners
             *   emitter.addListeners({
             *     event1: [function() { ... }, function() { ... }],
             *     event2: [function() { ... }]
             *   });
             *   emitter.emit('event1'); // emitter has event1
             *   emitter.emit('event2'); // emitter has event2
             * @example Adding listeners from another emitter object
             *   var emitter1 = new AWS.SequentialExecutor();
             *   emitter1.on('event1', function() { ... });
             *   emitter1.on('event2', function() { ... });
             *   var emitter2 = new AWS.SequentialExecutor();
             *   emitter2.addListeners(emitter1);
             *   emitter2.emit('event1'); // emitter2 has event1
             *   emitter2.emit('event2'); // emitter2 has event2
             */
            addListeners: function addListeners(listeners) {
              var self2 = this;
              if (listeners._events)
                listeners = listeners._events;
              AWS2.util.each(listeners, function(event, callbacks) {
                if (typeof callbacks === "function")
                  callbacks = [callbacks];
                AWS2.util.arrayEach(callbacks, function(callback) {
                  self2.on(event, callback);
                });
              });
              return self2;
            },
            /**
             * Registers an event with {on} and saves the callback handle function
             * as a property on the emitter object using a given `name`.
             *
             * @param name [String] the property name to set on this object containing
             *   the callback function handle so that the listener can be removed in
             *   the future.
             * @param (see on)
             * @return (see on)
             * @example Adding a named listener DATA_CALLBACK
             *   var listener = function() { doSomething(); };
             *   emitter.addNamedListener('DATA_CALLBACK', 'data', listener);
             *
             *   // the following prints: true
             *   console.log(emitter.DATA_CALLBACK == listener);
             */
            addNamedListener: function addNamedListener(name, eventName, callback, toHead) {
              this[name] = callback;
              this.addListener(eventName, callback, toHead);
              return this;
            },
            /**
             * @api private
             */
            addNamedAsyncListener: function addNamedAsyncListener(name, eventName, callback, toHead) {
              callback._isAsync = true;
              return this.addNamedListener(name, eventName, callback, toHead);
            },
            /**
             * Helper method to add a set of named listeners using
             * {addNamedListener}. The callback contains a parameter
             * with a handle to the `addNamedListener` method.
             *
             * @callback callback function(add)
             *   The callback function is called immediately in order to provide
             *   the `add` function to the block. This simplifies the addition of
             *   a large group of named listeners.
             *   @param add [Function] the {addNamedListener} function to call
             *     when registering listeners.
             * @example Adding a set of named listeners
             *   emitter.addNamedListeners(function(add) {
             *     add('DATA_CALLBACK', 'data', function() { ... });
             *     add('OTHER', 'otherEvent', function() { ... });
             *     add('LAST', 'lastEvent', function() { ... });
             *   });
             *
             *   // these properties are now set:
             *   emitter.DATA_CALLBACK;
             *   emitter.OTHER;
             *   emitter.LAST;
             */
            addNamedListeners: function addNamedListeners(callback) {
              var self2 = this;
              callback(
                function() {
                  self2.addNamedListener.apply(self2, arguments);
                },
                function() {
                  self2.addNamedAsyncListener.apply(self2, arguments);
                }
              );
              return this;
            }
          });
          AWS2.SequentialExecutor.prototype.addListener = AWS2.SequentialExecutor.prototype.on;
          module2.exports = AWS2.SequentialExecutor;
        }, { "./core": 19 }], 62: [function(require2, module2, exports2) {
          (function(process) {
            (function() {
              var AWS2 = require2("./core");
              var Api = require2("./model/api");
              var regionConfig = require2("./region_config");
              var inherit = AWS2.util.inherit;
              var clientCount = 0;
              var region_utils = require2("./region/utils");
              AWS2.Service = inherit({
                /**
                 * Create a new service object with a configuration object
                 *
                 * @param config [map] a map of configuration options
                 */
                constructor: function Service(config) {
                  if (!this.loadServiceClass) {
                    throw AWS2.util.error(
                      new Error(),
                      "Service must be constructed with `new' operator"
                    );
                  }
                  if (config) {
                    if (config.region) {
                      var region = config.region;
                      if (region_utils.isFipsRegion(region)) {
                        config.region = region_utils.getRealRegion(region);
                        config.useFipsEndpoint = true;
                      }
                      if (region_utils.isGlobalRegion(region)) {
                        config.region = region_utils.getRealRegion(region);
                      }
                    }
                    if (typeof config.useDualstack === "boolean" && typeof config.useDualstackEndpoint !== "boolean") {
                      config.useDualstackEndpoint = config.useDualstack;
                    }
                  }
                  var ServiceClass = this.loadServiceClass(config || {});
                  if (ServiceClass) {
                    var originalConfig = AWS2.util.copy(config);
                    var svc = new ServiceClass(config);
                    Object.defineProperty(svc, "_originalConfig", {
                      get: function() {
                        return originalConfig;
                      },
                      enumerable: false,
                      configurable: true
                    });
                    svc._clientId = ++clientCount;
                    return svc;
                  }
                  this.initialize(config);
                },
                /**
                 * @api private
                 */
                initialize: function initialize(config) {
                  var svcConfig = AWS2.config[this.serviceIdentifier];
                  this.config = new AWS2.Config(AWS2.config);
                  if (svcConfig)
                    this.config.update(svcConfig, true);
                  if (config)
                    this.config.update(config, true);
                  this.validateService();
                  if (!this.config.endpoint)
                    regionConfig.configureEndpoint(this);
                  this.config.endpoint = this.endpointFromTemplate(this.config.endpoint);
                  this.setEndpoint(this.config.endpoint);
                  AWS2.SequentialExecutor.call(this);
                  AWS2.Service.addDefaultMonitoringListeners(this);
                  if ((this.config.clientSideMonitoring || AWS2.Service._clientSideMonitoring) && this.publisher) {
                    var publisher = this.publisher;
                    this.addNamedListener("PUBLISH_API_CALL", "apiCall", function PUBLISH_API_CALL(event) {
                      process.nextTick(function() {
                        publisher.eventHandler(event);
                      });
                    });
                    this.addNamedListener("PUBLISH_API_ATTEMPT", "apiCallAttempt", function PUBLISH_API_ATTEMPT(event) {
                      process.nextTick(function() {
                        publisher.eventHandler(event);
                      });
                    });
                  }
                },
                /**
                 * @api private
                 */
                validateService: function validateService() {
                },
                /**
                 * @api private
                 */
                loadServiceClass: function loadServiceClass(serviceConfig) {
                  var config = serviceConfig;
                  if (!AWS2.util.isEmpty(this.api)) {
                    return null;
                  } else if (config.apiConfig) {
                    return AWS2.Service.defineServiceApi(this.constructor, config.apiConfig);
                  } else if (!this.constructor.services) {
                    return null;
                  } else {
                    config = new AWS2.Config(AWS2.config);
                    config.update(serviceConfig, true);
                    var version = config.apiVersions[this.constructor.serviceIdentifier];
                    version = version || config.apiVersion;
                    return this.getLatestServiceClass(version);
                  }
                },
                /**
                 * @api private
                 */
                getLatestServiceClass: function getLatestServiceClass(version) {
                  version = this.getLatestServiceVersion(version);
                  if (this.constructor.services[version] === null) {
                    AWS2.Service.defineServiceApi(this.constructor, version);
                  }
                  return this.constructor.services[version];
                },
                /**
                 * @api private
                 */
                getLatestServiceVersion: function getLatestServiceVersion(version) {
                  if (!this.constructor.services || this.constructor.services.length === 0) {
                    throw new Error("No services defined on " + this.constructor.serviceIdentifier);
                  }
                  if (!version) {
                    version = "latest";
                  } else if (AWS2.util.isType(version, Date)) {
                    version = AWS2.util.date.iso8601(version).split("T")[0];
                  }
                  if (Object.hasOwnProperty(this.constructor.services, version)) {
                    return version;
                  }
                  var keys = Object.keys(this.constructor.services).sort();
                  var selectedVersion = null;
                  for (var i = keys.length - 1; i >= 0; i--) {
                    if (keys[i][keys[i].length - 1] !== "*") {
                      selectedVersion = keys[i];
                    }
                    if (keys[i].substr(0, 10) <= version) {
                      return selectedVersion;
                    }
                  }
                  throw new Error("Could not find " + this.constructor.serviceIdentifier + " API to satisfy version constraint `" + version + "'");
                },
                /**
                 * @api private
                 */
                api: {},
                /**
                 * @api private
                 */
                defaultRetryCount: 3,
                /**
                 * @api private
                 */
                customizeRequests: function customizeRequests(callback) {
                  if (!callback) {
                    this.customRequestHandler = null;
                  } else if (typeof callback === "function") {
                    this.customRequestHandler = callback;
                  } else {
                    throw new Error("Invalid callback type '" + typeof callback + "' provided in customizeRequests");
                  }
                },
                /**
                 * Calls an operation on a service with the given input parameters.
                 *
                 * @param operation [String] the name of the operation to call on the service.
                 * @param params [map] a map of input options for the operation
                 * @callback callback function(err, data)
                 *   If a callback is supplied, it is called when a response is returned
                 *   from the service.
                 *   @param err [Error] the error object returned from the request.
                 *     Set to `null` if the request is successful.
                 *   @param data [Object] the de-serialized data returned from
                 *     the request. Set to `null` if a request error occurs.
                 */
                makeRequest: function makeRequest(operation, params, callback) {
                  if (typeof params === "function") {
                    callback = params;
                    params = null;
                  }
                  params = params || {};
                  if (this.config.params) {
                    var rules = this.api.operations[operation];
                    if (rules) {
                      params = AWS2.util.copy(params);
                      AWS2.util.each(this.config.params, function(key, value) {
                        if (rules.input.members[key]) {
                          if (params[key] === void 0 || params[key] === null) {
                            params[key] = value;
                          }
                        }
                      });
                    }
                  }
                  var request = new AWS2.Request(this, operation, params);
                  this.addAllRequestListeners(request);
                  this.attachMonitoringEmitter(request);
                  if (callback)
                    request.send(callback);
                  return request;
                },
                /**
                 * Calls an operation on a service with the given input parameters, without
                 * any authentication data. This method is useful for "public" API operations.
                 *
                 * @param operation [String] the name of the operation to call on the service.
                 * @param params [map] a map of input options for the operation
                 * @callback callback function(err, data)
                 *   If a callback is supplied, it is called when a response is returned
                 *   from the service.
                 *   @param err [Error] the error object returned from the request.
                 *     Set to `null` if the request is successful.
                 *   @param data [Object] the de-serialized data returned from
                 *     the request. Set to `null` if a request error occurs.
                 */
                makeUnauthenticatedRequest: function makeUnauthenticatedRequest(operation, params, callback) {
                  if (typeof params === "function") {
                    callback = params;
                    params = {};
                  }
                  var request = this.makeRequest(operation, params).toUnauthenticated();
                  return callback ? request.send(callback) : request;
                },
                /**
                 * Waits for a given state
                 *
                 * @param state [String] the state on the service to wait for
                 * @param params [map] a map of parameters to pass with each request
                 * @option params $waiter [map] a map of configuration options for the waiter
                 * @option params $waiter.delay [Number] The number of seconds to wait between
                 *                                       requests
                 * @option params $waiter.maxAttempts [Number] The maximum number of requests
                 *                                             to send while waiting
                 * @callback callback function(err, data)
                 *   If a callback is supplied, it is called when a response is returned
                 *   from the service.
                 *   @param err [Error] the error object returned from the request.
                 *     Set to `null` if the request is successful.
                 *   @param data [Object] the de-serialized data returned from
                 *     the request. Set to `null` if a request error occurs.
                 */
                waitFor: function waitFor(state, params, callback) {
                  var waiter = new AWS2.ResourceWaiter(this, state);
                  return waiter.wait(params, callback);
                },
                /**
                 * @api private
                 */
                addAllRequestListeners: function addAllRequestListeners(request) {
                  var list = [
                    AWS2.events,
                    AWS2.EventListeners.Core,
                    this.serviceInterface(),
                    AWS2.EventListeners.CorePost
                  ];
                  for (var i = 0; i < list.length; i++) {
                    if (list[i])
                      request.addListeners(list[i]);
                  }
                  if (!this.config.paramValidation) {
                    request.removeListener(
                      "validate",
                      AWS2.EventListeners.Core.VALIDATE_PARAMETERS
                    );
                  }
                  if (this.config.logger) {
                    request.addListeners(AWS2.EventListeners.Logger);
                  }
                  this.setupRequestListeners(request);
                  if (typeof this.constructor.prototype.customRequestHandler === "function") {
                    this.constructor.prototype.customRequestHandler(request);
                  }
                  if (Object.prototype.hasOwnProperty.call(this, "customRequestHandler") && typeof this.customRequestHandler === "function") {
                    this.customRequestHandler(request);
                  }
                },
                /**
                 * Event recording metrics for a whole API call.
                 * @returns {object} a subset of api call metrics
                 * @api private
                 */
                apiCallEvent: function apiCallEvent(request) {
                  var api = request.service.api.operations[request.operation];
                  var monitoringEvent = {
                    Type: "ApiCall",
                    Api: api ? api.name : request.operation,
                    Version: 1,
                    Service: request.service.api.serviceId || request.service.api.endpointPrefix,
                    Region: request.httpRequest.region,
                    MaxRetriesExceeded: 0,
                    UserAgent: request.httpRequest.getUserAgent()
                  };
                  var response = request.response;
                  if (response.httpResponse.statusCode) {
                    monitoringEvent.FinalHttpStatusCode = response.httpResponse.statusCode;
                  }
                  if (response.error) {
                    var error = response.error;
                    var statusCode = response.httpResponse.statusCode;
                    if (statusCode > 299) {
                      if (error.code)
                        monitoringEvent.FinalAwsException = error.code;
                      if (error.message)
                        monitoringEvent.FinalAwsExceptionMessage = error.message;
                    } else {
                      if (error.code || error.name)
                        monitoringEvent.FinalSdkException = error.code || error.name;
                      if (error.message)
                        monitoringEvent.FinalSdkExceptionMessage = error.message;
                    }
                  }
                  return monitoringEvent;
                },
                /**
                 * Event recording metrics for an API call attempt.
                 * @returns {object} a subset of api call attempt metrics
                 * @api private
                 */
                apiAttemptEvent: function apiAttemptEvent(request) {
                  var api = request.service.api.operations[request.operation];
                  var monitoringEvent = {
                    Type: "ApiCallAttempt",
                    Api: api ? api.name : request.operation,
                    Version: 1,
                    Service: request.service.api.serviceId || request.service.api.endpointPrefix,
                    Fqdn: request.httpRequest.endpoint.hostname,
                    UserAgent: request.httpRequest.getUserAgent()
                  };
                  var response = request.response;
                  if (response.httpResponse.statusCode) {
                    monitoringEvent.HttpStatusCode = response.httpResponse.statusCode;
                  }
                  if (!request._unAuthenticated && request.service.config.credentials && request.service.config.credentials.accessKeyId) {
                    monitoringEvent.AccessKey = request.service.config.credentials.accessKeyId;
                  }
                  if (!response.httpResponse.headers)
                    return monitoringEvent;
                  if (request.httpRequest.headers["x-amz-security-token"]) {
                    monitoringEvent.SessionToken = request.httpRequest.headers["x-amz-security-token"];
                  }
                  if (response.httpResponse.headers["x-amzn-requestid"]) {
                    monitoringEvent.XAmznRequestId = response.httpResponse.headers["x-amzn-requestid"];
                  }
                  if (response.httpResponse.headers["x-amz-request-id"]) {
                    monitoringEvent.XAmzRequestId = response.httpResponse.headers["x-amz-request-id"];
                  }
                  if (response.httpResponse.headers["x-amz-id-2"]) {
                    monitoringEvent.XAmzId2 = response.httpResponse.headers["x-amz-id-2"];
                  }
                  return monitoringEvent;
                },
                /**
                 * Add metrics of failed request.
                 * @api private
                 */
                attemptFailEvent: function attemptFailEvent(request) {
                  var monitoringEvent = this.apiAttemptEvent(request);
                  var response = request.response;
                  var error = response.error;
                  if (response.httpResponse.statusCode > 299) {
                    if (error.code)
                      monitoringEvent.AwsException = error.code;
                    if (error.message)
                      monitoringEvent.AwsExceptionMessage = error.message;
                  } else {
                    if (error.code || error.name)
                      monitoringEvent.SdkException = error.code || error.name;
                    if (error.message)
                      monitoringEvent.SdkExceptionMessage = error.message;
                  }
                  return monitoringEvent;
                },
                /**
                 * Attach listeners to request object to fetch metrics of each request
                 * and emit data object through \'ApiCall\' and \'ApiCallAttempt\' events.
                 * @api private
                 */
                attachMonitoringEmitter: function attachMonitoringEmitter(request) {
                  var attemptTimestamp;
                  var attemptStartRealTime;
                  var attemptLatency;
                  var callStartRealTime;
                  var attemptCount = 0;
                  var region;
                  var callTimestamp;
                  var self2 = this;
                  var addToHead = true;
                  request.on("validate", function() {
                    callStartRealTime = AWS2.util.realClock.now();
                    callTimestamp = Date.now();
                  }, addToHead);
                  request.on("sign", function() {
                    attemptStartRealTime = AWS2.util.realClock.now();
                    attemptTimestamp = Date.now();
                    region = request.httpRequest.region;
                    attemptCount++;
                  }, addToHead);
                  request.on("validateResponse", function() {
                    attemptLatency = Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
                  });
                  request.addNamedListener("API_CALL_ATTEMPT", "success", function API_CALL_ATTEMPT() {
                    var apiAttemptEvent = self2.apiAttemptEvent(request);
                    apiAttemptEvent.Timestamp = attemptTimestamp;
                    apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
                    apiAttemptEvent.Region = region;
                    self2.emit("apiCallAttempt", [apiAttemptEvent]);
                  });
                  request.addNamedListener("API_CALL_ATTEMPT_RETRY", "retry", function API_CALL_ATTEMPT_RETRY() {
                    var apiAttemptEvent = self2.attemptFailEvent(request);
                    apiAttemptEvent.Timestamp = attemptTimestamp;
                    attemptLatency = attemptLatency || Math.round(AWS2.util.realClock.now() - attemptStartRealTime);
                    apiAttemptEvent.AttemptLatency = attemptLatency >= 0 ? attemptLatency : 0;
                    apiAttemptEvent.Region = region;
                    self2.emit("apiCallAttempt", [apiAttemptEvent]);
                  });
                  request.addNamedListener("API_CALL", "complete", function API_CALL() {
                    var apiCallEvent = self2.apiCallEvent(request);
                    apiCallEvent.AttemptCount = attemptCount;
                    if (apiCallEvent.AttemptCount <= 0)
                      return;
                    apiCallEvent.Timestamp = callTimestamp;
                    var latency = Math.round(AWS2.util.realClock.now() - callStartRealTime);
                    apiCallEvent.Latency = latency >= 0 ? latency : 0;
                    var response = request.response;
                    if (response.error && response.error.retryable && typeof response.retryCount === "number" && typeof response.maxRetries === "number" && response.retryCount >= response.maxRetries) {
                      apiCallEvent.MaxRetriesExceeded = 1;
                    }
                    self2.emit("apiCall", [apiCallEvent]);
                  });
                },
                /**
                 * Override this method to setup any custom request listeners for each
                 * new request to the service.
                 *
                 * @method_abstract This is an abstract method.
                 */
                setupRequestListeners: function setupRequestListeners(request) {
                },
                /**
                 * Gets the signing name for a given request
                 * @api private
                 */
                getSigningName: function getSigningName() {
                  return this.api.signingName || this.api.endpointPrefix;
                },
                /**
                 * Gets the signer class for a given request
                 * @api private
                 */
                getSignerClass: function getSignerClass(request) {
                  var version;
                  var operation = null;
                  var authtype = "";
                  if (request) {
                    var operations = request.service.api.operations || {};
                    operation = operations[request.operation] || null;
                    authtype = operation ? operation.authtype : "";
                  }
                  if (this.config.signatureVersion) {
                    version = this.config.signatureVersion;
                  } else if (authtype === "v4" || authtype === "v4-unsigned-body") {
                    version = "v4";
                  } else if (authtype === "bearer") {
                    version = "bearer";
                  } else {
                    version = this.api.signatureVersion;
                  }
                  return AWS2.Signers.RequestSigner.getVersion(version);
                },
                /**
                 * @api private
                 */
                serviceInterface: function serviceInterface() {
                  switch (this.api.protocol) {
                    case "ec2":
                      return AWS2.EventListeners.Query;
                    case "query":
                      return AWS2.EventListeners.Query;
                    case "json":
                      return AWS2.EventListeners.Json;
                    case "rest-json":
                      return AWS2.EventListeners.RestJson;
                    case "rest-xml":
                      return AWS2.EventListeners.RestXml;
                  }
                  if (this.api.protocol) {
                    throw new Error("Invalid service `protocol' " + this.api.protocol + " in API config");
                  }
                },
                /**
                 * @api private
                 */
                successfulResponse: function successfulResponse(resp) {
                  return resp.httpResponse.statusCode < 300;
                },
                /**
                 * How many times a failed request should be retried before giving up.
                 * the defaultRetryCount can be overriden by service classes.
                 *
                 * @api private
                 */
                numRetries: function numRetries() {
                  if (this.config.maxRetries !== void 0) {
                    return this.config.maxRetries;
                  } else {
                    return this.defaultRetryCount;
                  }
                },
                /**
                 * @api private
                 */
                retryDelays: function retryDelays(retryCount, err) {
                  return AWS2.util.calculateRetryDelay(retryCount, this.config.retryDelayOptions, err);
                },
                /**
                 * @api private
                 */
                retryableError: function retryableError(error) {
                  if (this.timeoutError(error))
                    return true;
                  if (this.networkingError(error))
                    return true;
                  if (this.expiredCredentialsError(error))
                    return true;
                  if (this.throttledError(error))
                    return true;
                  if (error.statusCode >= 500)
                    return true;
                  return false;
                },
                /**
                 * @api private
                 */
                networkingError: function networkingError(error) {
                  return error.code === "NetworkingError";
                },
                /**
                 * @api private
                 */
                timeoutError: function timeoutError(error) {
                  return error.code === "TimeoutError";
                },
                /**
                 * @api private
                 */
                expiredCredentialsError: function expiredCredentialsError(error) {
                  return error.code === "ExpiredTokenException";
                },
                /**
                 * @api private
                 */
                clockSkewError: function clockSkewError(error) {
                  switch (error.code) {
                    case "RequestTimeTooSkewed":
                    case "RequestExpired":
                    case "InvalidSignatureException":
                    case "SignatureDoesNotMatch":
                    case "AuthFailure":
                    case "RequestInTheFuture":
                      return true;
                    default:
                      return false;
                  }
                },
                /**
                 * @api private
                 */
                getSkewCorrectedDate: function getSkewCorrectedDate() {
                  return new Date(Date.now() + this.config.systemClockOffset);
                },
                /**
                 * @api private
                 */
                applyClockOffset: function applyClockOffset(newServerTime) {
                  if (newServerTime) {
                    this.config.systemClockOffset = newServerTime - Date.now();
                  }
                },
                /**
                 * @api private
                 */
                isClockSkewed: function isClockSkewed(newServerTime) {
                  if (newServerTime) {
                    return Math.abs(this.getSkewCorrectedDate().getTime() - newServerTime) >= 3e5;
                  }
                },
                /**
                 * @api private
                 */
                throttledError: function throttledError(error) {
                  if (error.statusCode === 429)
                    return true;
                  switch (error.code) {
                    case "ProvisionedThroughputExceededException":
                    case "Throttling":
                    case "ThrottlingException":
                    case "RequestLimitExceeded":
                    case "RequestThrottled":
                    case "RequestThrottledException":
                    case "TooManyRequestsException":
                    case "TransactionInProgressException":
                    case "EC2ThrottledException":
                      return true;
                    default:
                      return false;
                  }
                },
                /**
                 * @api private
                 */
                endpointFromTemplate: function endpointFromTemplate(endpoint) {
                  if (typeof endpoint !== "string")
                    return endpoint;
                  var e = endpoint;
                  e = e.replace(/\{service\}/g, this.api.endpointPrefix);
                  e = e.replace(/\{region\}/g, this.config.region);
                  e = e.replace(/\{scheme\}/g, this.config.sslEnabled ? "https" : "http");
                  return e;
                },
                /**
                 * @api private
                 */
                setEndpoint: function setEndpoint(endpoint) {
                  this.endpoint = new AWS2.Endpoint(endpoint, this.config);
                },
                /**
                 * @api private
                 */
                paginationConfig: function paginationConfig(operation, throwException) {
                  var paginator = this.api.operations[operation].paginator;
                  if (!paginator) {
                    if (throwException) {
                      var e = new Error();
                      throw AWS2.util.error(e, "No pagination configuration for " + operation);
                    }
                    return null;
                  }
                  return paginator;
                }
              });
              AWS2.util.update(AWS2.Service, {
                /**
                 * Adds one method for each operation described in the api configuration
                 *
                 * @api private
                 */
                defineMethods: function defineMethods(svc) {
                  AWS2.util.each(svc.prototype.api.operations, function iterator(method) {
                    if (svc.prototype[method])
                      return;
                    var operation = svc.prototype.api.operations[method];
                    if (operation.authtype === "none") {
                      svc.prototype[method] = function(params, callback) {
                        return this.makeUnauthenticatedRequest(method, params, callback);
                      };
                    } else {
                      svc.prototype[method] = function(params, callback) {
                        return this.makeRequest(method, params, callback);
                      };
                    }
                  });
                },
                /**
                 * Defines a new Service class using a service identifier and list of versions
                 * including an optional set of features (functions) to apply to the class
                 * prototype.
                 *
                 * @param serviceIdentifier [String] the identifier for the service
                 * @param versions [Array<String>] a list of versions that work with this
                 *   service
                 * @param features [Object] an object to attach to the prototype
                 * @return [Class<Service>] the service class defined by this function.
                 */
                defineService: function defineService(serviceIdentifier, versions, features) {
                  AWS2.Service._serviceMap[serviceIdentifier] = true;
                  if (!Array.isArray(versions)) {
                    features = versions;
                    versions = [];
                  }
                  var svc = inherit(AWS2.Service, features || {});
                  if (typeof serviceIdentifier === "string") {
                    AWS2.Service.addVersions(svc, versions);
                    var identifier = svc.serviceIdentifier || serviceIdentifier;
                    svc.serviceIdentifier = identifier;
                  } else {
                    svc.prototype.api = serviceIdentifier;
                    AWS2.Service.defineMethods(svc);
                  }
                  AWS2.SequentialExecutor.call(this.prototype);
                  if (!this.prototype.publisher && AWS2.util.clientSideMonitoring) {
                    var Publisher = AWS2.util.clientSideMonitoring.Publisher;
                    var configProvider = AWS2.util.clientSideMonitoring.configProvider;
                    var publisherConfig = configProvider();
                    this.prototype.publisher = new Publisher(publisherConfig);
                    if (publisherConfig.enabled) {
                      AWS2.Service._clientSideMonitoring = true;
                    }
                  }
                  AWS2.SequentialExecutor.call(svc.prototype);
                  AWS2.Service.addDefaultMonitoringListeners(svc.prototype);
                  return svc;
                },
                /**
                 * @api private
                 */
                addVersions: function addVersions(svc, versions) {
                  if (!Array.isArray(versions))
                    versions = [versions];
                  svc.services = svc.services || {};
                  for (var i = 0; i < versions.length; i++) {
                    if (svc.services[versions[i]] === void 0) {
                      svc.services[versions[i]] = null;
                    }
                  }
                  svc.apiVersions = Object.keys(svc.services).sort();
                },
                /**
                 * @api private
                 */
                defineServiceApi: function defineServiceApi(superclass, version, apiConfig) {
                  var svc = inherit(superclass, {
                    serviceIdentifier: superclass.serviceIdentifier
                  });
                  function setApi(api) {
                    if (api.isApi) {
                      svc.prototype.api = api;
                    } else {
                      svc.prototype.api = new Api(api, {
                        serviceIdentifier: superclass.serviceIdentifier
                      });
                    }
                  }
                  if (typeof version === "string") {
                    if (apiConfig) {
                      setApi(apiConfig);
                    } else {
                      try {
                        setApi(AWS2.apiLoader(superclass.serviceIdentifier, version));
                      } catch (err) {
                        throw AWS2.util.error(err, {
                          message: "Could not find API configuration " + superclass.serviceIdentifier + "-" + version
                        });
                      }
                    }
                    if (!Object.prototype.hasOwnProperty.call(superclass.services, version)) {
                      superclass.apiVersions = superclass.apiVersions.concat(version).sort();
                    }
                    superclass.services[version] = svc;
                  } else {
                    setApi(version);
                  }
                  AWS2.Service.defineMethods(svc);
                  return svc;
                },
                /**
                 * @api private
                 */
                hasService: function(identifier) {
                  return Object.prototype.hasOwnProperty.call(AWS2.Service._serviceMap, identifier);
                },
                /**
                 * @param attachOn attach default monitoring listeners to object
                 *
                 * Each monitoring event should be emitted from service client to service constructor prototype and then
                 * to global service prototype like bubbling up. These default monitoring events listener will transfer
                 * the monitoring events to the upper layer.
                 * @api private
                 */
                addDefaultMonitoringListeners: function addDefaultMonitoringListeners(attachOn) {
                  attachOn.addNamedListener("MONITOR_EVENTS_BUBBLE", "apiCallAttempt", function EVENTS_BUBBLE(event) {
                    var baseClass = Object.getPrototypeOf(attachOn);
                    if (baseClass._events)
                      baseClass.emit("apiCallAttempt", [event]);
                  });
                  attachOn.addNamedListener("CALL_EVENTS_BUBBLE", "apiCall", function CALL_EVENTS_BUBBLE(event) {
                    var baseClass = Object.getPrototypeOf(attachOn);
                    if (baseClass._events)
                      baseClass.emit("apiCall", [event]);
                  });
                },
                /**
                 * @api private
                 */
                _serviceMap: {}
              });
              AWS2.util.mixin(AWS2.Service, AWS2.SequentialExecutor);
              module2.exports = AWS2.Service;
            }).call(this);
          }).call(this, require2("_process"));
        }, { "./core": 19, "./model/api": 40, "./region/utils": 55, "./region_config": 56, "_process": 91 }], 63: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var resolveRegionalEndpointsFlag = require2("../config_regional_endpoint");
          var ENV_REGIONAL_ENDPOINT_ENABLED = "AWS_STS_REGIONAL_ENDPOINTS";
          var CONFIG_REGIONAL_ENDPOINT_ENABLED = "sts_regional_endpoints";
          AWS2.util.update(AWS2.STS.prototype, {
            /**
             * @overload credentialsFrom(data, credentials = null)
             *   Creates a credentials object from STS response data containing
             *   credentials information. Useful for quickly setting AWS credentials.
             *
             *   @note This is a low-level utility function. If you want to load temporary
             *     credentials into your process for subsequent requests to AWS resources,
             *     you should use {AWS.TemporaryCredentials} instead.
             *   @param data [map] data retrieved from a call to {getFederatedToken},
             *     {getSessionToken}, {assumeRole}, or {assumeRoleWithWebIdentity}.
             *   @param credentials [AWS.Credentials] an optional credentials object to
             *     fill instead of creating a new object. Useful when modifying an
             *     existing credentials object from a refresh call.
             *   @return [AWS.TemporaryCredentials] the set of temporary credentials
             *     loaded from a raw STS operation response.
             *   @example Using credentialsFrom to load global AWS credentials
             *     var sts = new AWS.STS();
             *     sts.getSessionToken(function (err, data) {
             *       if (err) console.log("Error getting credentials");
             *       else {
             *         AWS.config.credentials = sts.credentialsFrom(data);
             *       }
             *     });
             *   @see AWS.TemporaryCredentials
             */
            credentialsFrom: function credentialsFrom(data, credentials) {
              if (!data)
                return null;
              if (!credentials)
                credentials = new AWS2.TemporaryCredentials();
              credentials.expired = false;
              credentials.accessKeyId = data.Credentials.AccessKeyId;
              credentials.secretAccessKey = data.Credentials.SecretAccessKey;
              credentials.sessionToken = data.Credentials.SessionToken;
              credentials.expireTime = data.Credentials.Expiration;
              return credentials;
            },
            assumeRoleWithWebIdentity: function assumeRoleWithWebIdentity(params, callback) {
              return this.makeUnauthenticatedRequest("assumeRoleWithWebIdentity", params, callback);
            },
            assumeRoleWithSAML: function assumeRoleWithSAML(params, callback) {
              return this.makeUnauthenticatedRequest("assumeRoleWithSAML", params, callback);
            },
            /**
             * @api private
             */
            setupRequestListeners: function setupRequestListeners(request) {
              request.addListener("validate", this.optInRegionalEndpoint, true);
            },
            /**
             * @api private
             */
            optInRegionalEndpoint: function optInRegionalEndpoint(req) {
              var service = req.service;
              var config = service.config;
              config.stsRegionalEndpoints = resolveRegionalEndpointsFlag(service._originalConfig, {
                env: ENV_REGIONAL_ENDPOINT_ENABLED,
                sharedConfig: CONFIG_REGIONAL_ENDPOINT_ENABLED,
                clientConfig: "stsRegionalEndpoints"
              });
              if (config.stsRegionalEndpoints === "regional" && service.isGlobalEndpoint) {
                if (!config.region) {
                  throw AWS2.util.error(
                    new Error(),
                    { code: "ConfigError", message: "Missing region in config" }
                  );
                }
                var insertPoint = config.endpoint.indexOf(".amazonaws.com");
                var regionalEndpoint = config.endpoint.substring(0, insertPoint) + "." + config.region + config.endpoint.substring(insertPoint);
                req.httpRequest.updateEndpoint(regionalEndpoint);
                req.httpRequest.region = config.region;
              }
            }
          });
        }, { "../config_regional_endpoint": 18, "../core": 19 }], 64: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          AWS2.Signers.Bearer = AWS2.util.inherit(AWS2.Signers.RequestSigner, {
            constructor: function Bearer(request) {
              AWS2.Signers.RequestSigner.call(this, request);
            },
            addAuthorization: function addAuthorization(token) {
              this.request.headers["Authorization"] = "Bearer " + token.token;
            }
          });
        }, { "../core": 19 }], 65: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          var expiresHeader = "presigned-expires";
          function signedUrlBuilder(request) {
            var expires = request.httpRequest.headers[expiresHeader];
            var signerClass = request.service.getSignerClass(request);
            delete request.httpRequest.headers["User-Agent"];
            delete request.httpRequest.headers["X-Amz-User-Agent"];
            if (signerClass === AWS2.Signers.V4) {
              if (expires > 604800) {
                var message = "Presigning does not support expiry time greater than a week with SigV4 signing.";
                throw AWS2.util.error(new Error(), {
                  code: "InvalidExpiryTime",
                  message,
                  retryable: false
                });
              }
              request.httpRequest.headers[expiresHeader] = expires;
            } else if (signerClass === AWS2.Signers.S3) {
              var now = request.service ? request.service.getSkewCorrectedDate() : AWS2.util.date.getDate();
              request.httpRequest.headers[expiresHeader] = parseInt(
                AWS2.util.date.unixTimestamp(now) + expires,
                10
              ).toString();
            } else {
              throw AWS2.util.error(new Error(), {
                message: "Presigning only supports S3 or SigV4 signing.",
                code: "UnsupportedSigner",
                retryable: false
              });
            }
          }
          function signedUrlSigner(request) {
            var endpoint = request.httpRequest.endpoint;
            var parsedUrl = AWS2.util.urlParse(request.httpRequest.path);
            var queryParams = {};
            if (parsedUrl.search) {
              queryParams = AWS2.util.queryStringParse(parsedUrl.search.substr(1));
            }
            var auth = request.httpRequest.headers["Authorization"].split(" ");
            if (auth[0] === "AWS") {
              auth = auth[1].split(":");
              queryParams["Signature"] = auth.pop();
              queryParams["AWSAccessKeyId"] = auth.join(":");
              AWS2.util.each(request.httpRequest.headers, function(key, value) {
                if (key === expiresHeader)
                  key = "Expires";
                if (key.indexOf("x-amz-meta-") === 0) {
                  delete queryParams[key];
                  key = key.toLowerCase();
                }
                queryParams[key] = value;
              });
              delete request.httpRequest.headers[expiresHeader];
              delete queryParams["Authorization"];
              delete queryParams["Host"];
            } else if (auth[0] === "AWS4-HMAC-SHA256") {
              auth.shift();
              var rest = auth.join(" ");
              var signature = rest.match(/Signature=(.*?)(?:,|\s|\r?\n|$)/)[1];
              queryParams["X-Amz-Signature"] = signature;
              delete queryParams["Expires"];
            }
            endpoint.pathname = parsedUrl.pathname;
            endpoint.search = AWS2.util.queryParamsToString(queryParams);
          }
          AWS2.Signers.Presign = inherit({
            /**
             * @api private
             */
            sign: function sign(request, expireTime, callback) {
              request.httpRequest.headers[expiresHeader] = expireTime || 3600;
              request.on("build", signedUrlBuilder);
              request.on("sign", signedUrlSigner);
              request.removeListener(
                "afterBuild",
                AWS2.EventListeners.Core.SET_CONTENT_LENGTH
              );
              request.removeListener(
                "afterBuild",
                AWS2.EventListeners.Core.COMPUTE_SHA256
              );
              request.emit("beforePresign", [request]);
              if (callback) {
                request.build(function() {
                  if (this.response.error)
                    callback(this.response.error);
                  else {
                    callback(null, AWS2.util.urlFormat(request.httpRequest.endpoint));
                  }
                });
              } else {
                request.build();
                if (request.response.error)
                  throw request.response.error;
                return AWS2.util.urlFormat(request.httpRequest.endpoint);
              }
            }
          });
          module2.exports = AWS2.Signers.Presign;
        }, { "../core": 19 }], 66: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          AWS2.Signers.RequestSigner = inherit({
            constructor: function RequestSigner(request) {
              this.request = request;
            },
            setServiceClientId: function setServiceClientId(id) {
              this.serviceClientId = id;
            },
            getServiceClientId: function getServiceClientId() {
              return this.serviceClientId;
            }
          });
          AWS2.Signers.RequestSigner.getVersion = function getVersion(version) {
            switch (version) {
              case "v2":
                return AWS2.Signers.V2;
              case "v3":
                return AWS2.Signers.V3;
              case "s3v4":
                return AWS2.Signers.V4;
              case "v4":
                return AWS2.Signers.V4;
              case "s3":
                return AWS2.Signers.S3;
              case "v3https":
                return AWS2.Signers.V3Https;
              case "bearer":
                return AWS2.Signers.Bearer;
            }
            throw new Error("Unknown signing version " + version);
          };
          require2("./v2");
          require2("./v3");
          require2("./v3https");
          require2("./v4");
          require2("./s3");
          require2("./presign");
          require2("./bearer");
        }, { "../core": 19, "./bearer": 64, "./presign": 65, "./s3": 67, "./v2": 68, "./v3": 69, "./v3https": 70, "./v4": 71 }], 67: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          AWS2.Signers.S3 = inherit(AWS2.Signers.RequestSigner, {
            /**
             * When building the stringToSign, these sub resource params should be
             * part of the canonical resource string with their NON-decoded values
             */
            subResources: {
              "acl": 1,
              "accelerate": 1,
              "analytics": 1,
              "cors": 1,
              "lifecycle": 1,
              "delete": 1,
              "inventory": 1,
              "location": 1,
              "logging": 1,
              "metrics": 1,
              "notification": 1,
              "partNumber": 1,
              "policy": 1,
              "requestPayment": 1,
              "replication": 1,
              "restore": 1,
              "tagging": 1,
              "torrent": 1,
              "uploadId": 1,
              "uploads": 1,
              "versionId": 1,
              "versioning": 1,
              "versions": 1,
              "website": 1
            },
            // when building the stringToSign, these querystring params should be
            // part of the canonical resource string with their NON-encoded values
            responseHeaders: {
              "response-content-type": 1,
              "response-content-language": 1,
              "response-expires": 1,
              "response-cache-control": 1,
              "response-content-disposition": 1,
              "response-content-encoding": 1
            },
            addAuthorization: function addAuthorization(credentials, date) {
              if (!this.request.headers["presigned-expires"]) {
                this.request.headers["X-Amz-Date"] = AWS2.util.date.rfc822(date);
              }
              if (credentials.sessionToken) {
                this.request.headers["x-amz-security-token"] = credentials.sessionToken;
              }
              var signature = this.sign(credentials.secretAccessKey, this.stringToSign());
              var auth = "AWS " + credentials.accessKeyId + ":" + signature;
              this.request.headers["Authorization"] = auth;
            },
            stringToSign: function stringToSign() {
              var r = this.request;
              var parts = [];
              parts.push(r.method);
              parts.push(r.headers["Content-MD5"] || "");
              parts.push(r.headers["Content-Type"] || "");
              parts.push(r.headers["presigned-expires"] || "");
              var headers = this.canonicalizedAmzHeaders();
              if (headers)
                parts.push(headers);
              parts.push(this.canonicalizedResource());
              return parts.join("\n");
            },
            canonicalizedAmzHeaders: function canonicalizedAmzHeaders() {
              var amzHeaders = [];
              AWS2.util.each(this.request.headers, function(name) {
                if (name.match(/^x-amz-/i))
                  amzHeaders.push(name);
              });
              amzHeaders.sort(function(a, b) {
                return a.toLowerCase() < b.toLowerCase() ? -1 : 1;
              });
              var parts = [];
              AWS2.util.arrayEach.call(this, amzHeaders, function(name) {
                parts.push(name.toLowerCase() + ":" + String(this.request.headers[name]));
              });
              return parts.join("\n");
            },
            canonicalizedResource: function canonicalizedResource() {
              var r = this.request;
              var parts = r.path.split("?");
              var path = parts[0];
              var querystring = parts[1];
              var resource = "";
              if (r.virtualHostedBucket)
                resource += "/" + r.virtualHostedBucket;
              resource += path;
              if (querystring) {
                var resources = [];
                AWS2.util.arrayEach.call(this, querystring.split("&"), function(param) {
                  var name = param.split("=")[0];
                  var value = param.split("=")[1];
                  if (this.subResources[name] || this.responseHeaders[name]) {
                    var subresource = { name };
                    if (value !== void 0) {
                      if (this.subResources[name]) {
                        subresource.value = value;
                      } else {
                        subresource.value = decodeURIComponent(value);
                      }
                    }
                    resources.push(subresource);
                  }
                });
                resources.sort(function(a, b) {
                  return a.name < b.name ? -1 : 1;
                });
                if (resources.length) {
                  querystring = [];
                  AWS2.util.arrayEach(resources, function(res) {
                    if (res.value === void 0) {
                      querystring.push(res.name);
                    } else {
                      querystring.push(res.name + "=" + res.value);
                    }
                  });
                  resource += "?" + querystring.join("&");
                }
              }
              return resource;
            },
            sign: function sign(secret, string) {
              return AWS2.util.crypto.hmac(secret, string, "base64", "sha1");
            }
          });
          module2.exports = AWS2.Signers.S3;
        }, { "../core": 19 }], 68: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          AWS2.Signers.V2 = inherit(AWS2.Signers.RequestSigner, {
            addAuthorization: function addAuthorization(credentials, date) {
              if (!date)
                date = AWS2.util.date.getDate();
              var r = this.request;
              r.params.Timestamp = AWS2.util.date.iso8601(date);
              r.params.SignatureVersion = "2";
              r.params.SignatureMethod = "HmacSHA256";
              r.params.AWSAccessKeyId = credentials.accessKeyId;
              if (credentials.sessionToken) {
                r.params.SecurityToken = credentials.sessionToken;
              }
              delete r.params.Signature;
              r.params.Signature = this.signature(credentials);
              r.body = AWS2.util.queryParamsToString(r.params);
              r.headers["Content-Length"] = r.body.length;
            },
            signature: function signature(credentials) {
              return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
            },
            stringToSign: function stringToSign() {
              var parts = [];
              parts.push(this.request.method);
              parts.push(this.request.endpoint.host.toLowerCase());
              parts.push(this.request.pathname());
              parts.push(AWS2.util.queryParamsToString(this.request.params));
              return parts.join("\n");
            }
          });
          module2.exports = AWS2.Signers.V2;
        }, { "../core": 19 }], 69: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          AWS2.Signers.V3 = inherit(AWS2.Signers.RequestSigner, {
            addAuthorization: function addAuthorization(credentials, date) {
              var datetime = AWS2.util.date.rfc822(date);
              this.request.headers["X-Amz-Date"] = datetime;
              if (credentials.sessionToken) {
                this.request.headers["x-amz-security-token"] = credentials.sessionToken;
              }
              this.request.headers["X-Amzn-Authorization"] = this.authorization(credentials, datetime);
            },
            authorization: function authorization(credentials) {
              return "AWS3 AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,SignedHeaders=" + this.signedHeaders() + ",Signature=" + this.signature(credentials);
            },
            signedHeaders: function signedHeaders() {
              var headers = [];
              AWS2.util.arrayEach(this.headersToSign(), function iterator(h) {
                headers.push(h.toLowerCase());
              });
              return headers.sort().join(";");
            },
            canonicalHeaders: function canonicalHeaders() {
              var headers = this.request.headers;
              var parts = [];
              AWS2.util.arrayEach(this.headersToSign(), function iterator(h) {
                parts.push(h.toLowerCase().trim() + ":" + String(headers[h]).trim());
              });
              return parts.sort().join("\n") + "\n";
            },
            headersToSign: function headersToSign() {
              var headers = [];
              AWS2.util.each(this.request.headers, function iterator(k) {
                if (k === "Host" || k === "Content-Encoding" || k.match(/^X-Amz/i)) {
                  headers.push(k);
                }
              });
              return headers;
            },
            signature: function signature(credentials) {
              return AWS2.util.crypto.hmac(credentials.secretAccessKey, this.stringToSign(), "base64");
            },
            stringToSign: function stringToSign() {
              var parts = [];
              parts.push(this.request.method);
              parts.push("/");
              parts.push("");
              parts.push(this.canonicalHeaders());
              parts.push(this.request.body);
              return AWS2.util.crypto.sha256(parts.join("\n"));
            }
          });
          module2.exports = AWS2.Signers.V3;
        }, { "../core": 19 }], 70: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var inherit = AWS2.util.inherit;
          require2("./v3");
          AWS2.Signers.V3Https = inherit(AWS2.Signers.V3, {
            authorization: function authorization(credentials) {
              return "AWS3-HTTPS AWSAccessKeyId=" + credentials.accessKeyId + ",Algorithm=HmacSHA256,Signature=" + this.signature(credentials);
            },
            stringToSign: function stringToSign() {
              return this.request.headers["X-Amz-Date"];
            }
          });
          module2.exports = AWS2.Signers.V3Https;
        }, { "../core": 19, "./v3": 69 }], 71: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var v4Credentials = require2("./v4_credentials");
          var inherit = AWS2.util.inherit;
          var expiresHeader = "presigned-expires";
          AWS2.Signers.V4 = inherit(AWS2.Signers.RequestSigner, {
            constructor: function V4(request, serviceName, options) {
              AWS2.Signers.RequestSigner.call(this, request);
              this.serviceName = serviceName;
              options = options || {};
              this.signatureCache = typeof options.signatureCache === "boolean" ? options.signatureCache : true;
              this.operation = options.operation;
              this.signatureVersion = options.signatureVersion;
            },
            algorithm: "AWS4-HMAC-SHA256",
            addAuthorization: function addAuthorization(credentials, date) {
              var datetime = AWS2.util.date.iso8601(date).replace(/[:\-]|\.\d{3}/g, "");
              if (this.isPresigned()) {
                this.updateForPresigned(credentials, datetime);
              } else {
                this.addHeaders(credentials, datetime);
              }
              this.request.headers["Authorization"] = this.authorization(credentials, datetime);
            },
            addHeaders: function addHeaders(credentials, datetime) {
              this.request.headers["X-Amz-Date"] = datetime;
              if (credentials.sessionToken) {
                this.request.headers["x-amz-security-token"] = credentials.sessionToken;
              }
            },
            updateForPresigned: function updateForPresigned(credentials, datetime) {
              var credString = this.credentialString(datetime);
              var qs = {
                "X-Amz-Date": datetime,
                "X-Amz-Algorithm": this.algorithm,
                "X-Amz-Credential": credentials.accessKeyId + "/" + credString,
                "X-Amz-Expires": this.request.headers[expiresHeader],
                "X-Amz-SignedHeaders": this.signedHeaders()
              };
              if (credentials.sessionToken) {
                qs["X-Amz-Security-Token"] = credentials.sessionToken;
              }
              if (this.request.headers["Content-Type"]) {
                qs["Content-Type"] = this.request.headers["Content-Type"];
              }
              if (this.request.headers["Content-MD5"]) {
                qs["Content-MD5"] = this.request.headers["Content-MD5"];
              }
              if (this.request.headers["Cache-Control"]) {
                qs["Cache-Control"] = this.request.headers["Cache-Control"];
              }
              AWS2.util.each.call(this, this.request.headers, function(key, value) {
                if (key === expiresHeader)
                  return;
                if (this.isSignableHeader(key)) {
                  var lowerKey = key.toLowerCase();
                  if (lowerKey.indexOf("x-amz-meta-") === 0) {
                    qs[lowerKey] = value;
                  } else if (lowerKey.indexOf("x-amz-") === 0) {
                    qs[key] = value;
                  }
                }
              });
              var sep = this.request.path.indexOf("?") >= 0 ? "&" : "?";
              this.request.path += sep + AWS2.util.queryParamsToString(qs);
            },
            authorization: function authorization(credentials, datetime) {
              var parts = [];
              var credString = this.credentialString(datetime);
              parts.push(this.algorithm + " Credential=" + credentials.accessKeyId + "/" + credString);
              parts.push("SignedHeaders=" + this.signedHeaders());
              parts.push("Signature=" + this.signature(credentials, datetime));
              return parts.join(", ");
            },
            signature: function signature(credentials, datetime) {
              var signingKey = v4Credentials.getSigningKey(
                credentials,
                datetime.substr(0, 8),
                this.request.region,
                this.serviceName,
                this.signatureCache
              );
              return AWS2.util.crypto.hmac(signingKey, this.stringToSign(datetime), "hex");
            },
            stringToSign: function stringToSign(datetime) {
              var parts = [];
              parts.push("AWS4-HMAC-SHA256");
              parts.push(datetime);
              parts.push(this.credentialString(datetime));
              parts.push(this.hexEncodedHash(this.canonicalString()));
              return parts.join("\n");
            },
            canonicalString: function canonicalString() {
              var parts = [], pathname = this.request.pathname();
              if (this.serviceName !== "s3" && this.signatureVersion !== "s3v4")
                pathname = AWS2.util.uriEscapePath(pathname);
              parts.push(this.request.method);
              parts.push(pathname);
              parts.push(this.request.search());
              parts.push(this.canonicalHeaders() + "\n");
              parts.push(this.signedHeaders());
              parts.push(this.hexEncodedBodyHash());
              return parts.join("\n");
            },
            canonicalHeaders: function canonicalHeaders() {
              var headers = [];
              AWS2.util.each.call(this, this.request.headers, function(key, item) {
                headers.push([key, item]);
              });
              headers.sort(function(a, b) {
                return a[0].toLowerCase() < b[0].toLowerCase() ? -1 : 1;
              });
              var parts = [];
              AWS2.util.arrayEach.call(this, headers, function(item) {
                var key = item[0].toLowerCase();
                if (this.isSignableHeader(key)) {
                  var value = item[1];
                  if (typeof value === "undefined" || value === null || typeof value.toString !== "function") {
                    throw AWS2.util.error(new Error("Header " + key + " contains invalid value"), {
                      code: "InvalidHeader"
                    });
                  }
                  parts.push(key + ":" + this.canonicalHeaderValues(value.toString()));
                }
              });
              return parts.join("\n");
            },
            canonicalHeaderValues: function canonicalHeaderValues(values) {
              return values.replace(/\s+/g, " ").replace(/^\s+|\s+$/g, "");
            },
            signedHeaders: function signedHeaders() {
              var keys = [];
              AWS2.util.each.call(this, this.request.headers, function(key) {
                key = key.toLowerCase();
                if (this.isSignableHeader(key))
                  keys.push(key);
              });
              return keys.sort().join(";");
            },
            credentialString: function credentialString(datetime) {
              return v4Credentials.createScope(
                datetime.substr(0, 8),
                this.request.region,
                this.serviceName
              );
            },
            hexEncodedHash: function hash(string) {
              return AWS2.util.crypto.sha256(string, "hex");
            },
            hexEncodedBodyHash: function hexEncodedBodyHash() {
              var request = this.request;
              if (this.isPresigned() && ["s3", "s3-object-lambda"].indexOf(this.serviceName) > -1 && !request.body) {
                return "UNSIGNED-PAYLOAD";
              } else if (request.headers["X-Amz-Content-Sha256"]) {
                return request.headers["X-Amz-Content-Sha256"];
              } else {
                return this.hexEncodedHash(this.request.body || "");
              }
            },
            unsignableHeaders: [
              "authorization",
              "content-type",
              "content-length",
              "user-agent",
              expiresHeader,
              "expect",
              "x-amzn-trace-id"
            ],
            isSignableHeader: function isSignableHeader(key) {
              if (key.toLowerCase().indexOf("x-amz-") === 0)
                return true;
              return this.unsignableHeaders.indexOf(key) < 0;
            },
            isPresigned: function isPresigned() {
              return this.request.headers[expiresHeader] ? true : false;
            }
          });
          module2.exports = AWS2.Signers.V4;
        }, { "../core": 19, "./v4_credentials": 72 }], 72: [function(require2, module2, exports2) {
          var AWS2 = require2("../core");
          var cachedSecret = {};
          var cacheQueue = [];
          var maxCacheEntries = 50;
          var v4Identifier = "aws4_request";
          module2.exports = {
            /**
             * @api private
             *
             * @param date [String]
             * @param region [String]
             * @param serviceName [String]
             * @return [String]
             */
            createScope: function createScope(date, region, serviceName) {
              return [
                date.substr(0, 8),
                region,
                serviceName,
                v4Identifier
              ].join("/");
            },
            /**
             * @api private
             *
             * @param credentials [Credentials]
             * @param date [String]
             * @param region [String]
             * @param service [String]
             * @param shouldCache [Boolean]
             * @return [String]
             */
            getSigningKey: function getSigningKey(credentials, date, region, service, shouldCache) {
              var credsIdentifier = AWS2.util.crypto.hmac(credentials.secretAccessKey, credentials.accessKeyId, "base64");
              var cacheKey = [credsIdentifier, date, region, service].join("_");
              shouldCache = shouldCache !== false;
              if (shouldCache && cacheKey in cachedSecret) {
                return cachedSecret[cacheKey];
              }
              var kDate = AWS2.util.crypto.hmac(
                "AWS4" + credentials.secretAccessKey,
                date,
                "buffer"
              );
              var kRegion = AWS2.util.crypto.hmac(kDate, region, "buffer");
              var kService = AWS2.util.crypto.hmac(kRegion, service, "buffer");
              var signingKey = AWS2.util.crypto.hmac(kService, v4Identifier, "buffer");
              if (shouldCache) {
                cachedSecret[cacheKey] = signingKey;
                cacheQueue.push(cacheKey);
                if (cacheQueue.length > maxCacheEntries) {
                  delete cachedSecret[cacheQueue.shift()];
                }
              }
              return signingKey;
            },
            /**
             * @api private
             *
             * Empties the derived signing key cache. Made available for testing purposes
             * only.
             */
            emptyCache: function emptyCache() {
              cachedSecret = {};
              cacheQueue = [];
            }
          };
        }, { "../core": 19 }], 73: [function(require2, module2, exports2) {
          function AcceptorStateMachine(states, state) {
            this.currentState = state || null;
            this.states = states || {};
          }
          AcceptorStateMachine.prototype.runTo = function runTo(finalState, done, bindObject, inputError) {
            if (typeof finalState === "function") {
              inputError = bindObject;
              bindObject = done;
              done = finalState;
              finalState = null;
            }
            var self2 = this;
            var state = self2.states[self2.currentState];
            state.fn.call(bindObject || self2, inputError, function(err) {
              if (err) {
                if (state.fail)
                  self2.currentState = state.fail;
                else
                  return done ? done.call(bindObject, err) : null;
              } else {
                if (state.accept)
                  self2.currentState = state.accept;
                else
                  return done ? done.call(bindObject) : null;
              }
              if (self2.currentState === finalState) {
                return done ? done.call(bindObject, err) : null;
              }
              self2.runTo(finalState, done, bindObject, err);
            });
          };
          AcceptorStateMachine.prototype.addState = function addState(name, acceptState, failState, fn) {
            if (typeof acceptState === "function") {
              fn = acceptState;
              acceptState = null;
              failState = null;
            } else if (typeof failState === "function") {
              fn = failState;
              failState = null;
            }
            if (!this.currentState)
              this.currentState = name;
            this.states[name] = { accept: acceptState, fail: failState, fn };
            return this;
          };
          module2.exports = AcceptorStateMachine;
        }, {}], 74: [function(require2, module2, exports2) {
          (function(process, setImmediate) {
            (function() {
              var AWS2;
              var util = {
                environment: "nodejs",
                engine: function engine() {
                  if (util.isBrowser() && typeof navigator !== "undefined") {
                    return navigator.userAgent;
                  } else {
                    var engine2 = process.platform + "/" + process.version;
                    if (process.env.AWS_EXECUTION_ENV) {
                      engine2 += " exec-env/" + process.env.AWS_EXECUTION_ENV;
                    }
                    return engine2;
                  }
                },
                userAgent: function userAgent() {
                  var name = util.environment;
                  var agent = "aws-sdk-" + name + "/" + require2("./core").VERSION;
                  if (name === "nodejs")
                    agent += " " + util.engine();
                  return agent;
                },
                uriEscape: function uriEscape(string) {
                  var output = encodeURIComponent(string);
                  output = output.replace(/[^A-Za-z0-9_.~\-%]+/g, escape);
                  output = output.replace(/[*]/g, function(ch) {
                    return "%" + ch.charCodeAt(0).toString(16).toUpperCase();
                  });
                  return output;
                },
                uriEscapePath: function uriEscapePath(string) {
                  var parts = [];
                  util.arrayEach(string.split("/"), function(part) {
                    parts.push(util.uriEscape(part));
                  });
                  return parts.join("/");
                },
                urlParse: function urlParse(url) {
                  return util.url.parse(url);
                },
                urlFormat: function urlFormat(url) {
                  return util.url.format(url);
                },
                queryStringParse: function queryStringParse(qs) {
                  return util.querystring.parse(qs);
                },
                queryParamsToString: function queryParamsToString(params) {
                  var items = [];
                  var escape2 = util.uriEscape;
                  var sortedKeys = Object.keys(params).sort();
                  util.arrayEach(sortedKeys, function(name) {
                    var value = params[name];
                    var ename = escape2(name);
                    var result = ename + "=";
                    if (Array.isArray(value)) {
                      var vals = [];
                      util.arrayEach(value, function(item) {
                        vals.push(escape2(item));
                      });
                      result = ename + "=" + vals.sort().join("&" + ename + "=");
                    } else if (value !== void 0 && value !== null) {
                      result = ename + "=" + escape2(value);
                    }
                    items.push(result);
                  });
                  return items.join("&");
                },
                readFileSync: function readFileSync(path) {
                  if (util.isBrowser())
                    return null;
                  return require2("fs").readFileSync(path, "utf-8");
                },
                base64: {
                  encode: function encode64(string) {
                    if (typeof string === "number") {
                      throw util.error(new Error("Cannot base64 encode number " + string));
                    }
                    if (string === null || typeof string === "undefined") {
                      return string;
                    }
                    var buf = util.buffer.toBuffer(string);
                    return buf.toString("base64");
                  },
                  decode: function decode64(string) {
                    if (typeof string === "number") {
                      throw util.error(new Error("Cannot base64 decode number " + string));
                    }
                    if (string === null || typeof string === "undefined") {
                      return string;
                    }
                    return util.buffer.toBuffer(string, "base64");
                  }
                },
                buffer: {
                  /**
                   * Buffer constructor for Node buffer and buffer pollyfill
                   */
                  toBuffer: function(data, encoding) {
                    return typeof util.Buffer.from === "function" && util.Buffer.from !== Uint8Array.from ? util.Buffer.from(data, encoding) : new util.Buffer(data, encoding);
                  },
                  alloc: function(size, fill, encoding) {
                    if (typeof size !== "number") {
                      throw new Error("size passed to alloc must be a number.");
                    }
                    if (typeof util.Buffer.alloc === "function") {
                      return util.Buffer.alloc(size, fill, encoding);
                    } else {
                      var buf = new util.Buffer(size);
                      if (fill !== void 0 && typeof buf.fill === "function") {
                        buf.fill(fill, void 0, void 0, encoding);
                      }
                      return buf;
                    }
                  },
                  toStream: function toStream(buffer) {
                    if (!util.Buffer.isBuffer(buffer))
                      buffer = util.buffer.toBuffer(buffer);
                    var readable = new util.stream.Readable();
                    var pos = 0;
                    readable._read = function(size) {
                      if (pos >= buffer.length)
                        return readable.push(null);
                      var end = pos + size;
                      if (end > buffer.length)
                        end = buffer.length;
                      readable.push(buffer.slice(pos, end));
                      pos = end;
                    };
                    return readable;
                  },
                  /**
                   * Concatenates a list of Buffer objects.
                   */
                  concat: function(buffers) {
                    var length = 0, offset = 0, buffer = null, i;
                    for (i = 0; i < buffers.length; i++) {
                      length += buffers[i].length;
                    }
                    buffer = util.buffer.alloc(length);
                    for (i = 0; i < buffers.length; i++) {
                      buffers[i].copy(buffer, offset);
                      offset += buffers[i].length;
                    }
                    return buffer;
                  }
                },
                string: {
                  byteLength: function byteLength(string) {
                    if (string === null || string === void 0)
                      return 0;
                    if (typeof string === "string")
                      string = util.buffer.toBuffer(string);
                    if (typeof string.byteLength === "number") {
                      return string.byteLength;
                    } else if (typeof string.length === "number") {
                      return string.length;
                    } else if (typeof string.size === "number") {
                      return string.size;
                    } else if (typeof string.path === "string") {
                      return require2("fs").lstatSync(string.path).size;
                    } else {
                      throw util.error(
                        new Error("Cannot determine length of " + string),
                        { object: string }
                      );
                    }
                  },
                  upperFirst: function upperFirst(string) {
                    return string[0].toUpperCase() + string.substr(1);
                  },
                  lowerFirst: function lowerFirst(string) {
                    return string[0].toLowerCase() + string.substr(1);
                  }
                },
                ini: {
                  parse: function string(ini) {
                    var currentSection, map = {};
                    util.arrayEach(ini.split(/\r?\n/), function(line) {
                      line = line.split(/(^|\s)[;#]/)[0].trim();
                      var isSection = line[0] === "[" && line[line.length - 1] === "]";
                      if (isSection) {
                        currentSection = line.substring(1, line.length - 1);
                        if (currentSection === "__proto__" || currentSection.split(/\s/)[1] === "__proto__") {
                          throw util.error(
                            new Error("Cannot load profile name '" + currentSection + "' from shared ini file.")
                          );
                        }
                      } else if (currentSection) {
                        var indexOfEqualsSign = line.indexOf("=");
                        var start = 0;
                        var end = line.length - 1;
                        var isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
                        if (isAssignment) {
                          var name = line.substring(0, indexOfEqualsSign).trim();
                          var value = line.substring(indexOfEqualsSign + 1).trim();
                          map[currentSection] = map[currentSection] || {};
                          map[currentSection][name] = value;
                        }
                      }
                    });
                    return map;
                  }
                },
                fn: {
                  noop: function() {
                  },
                  callback: function(err) {
                    if (err)
                      throw err;
                  },
                  /**
                   * Turn a synchronous function into as "async" function by making it call
                   * a callback. The underlying function is called with all but the last argument,
                   * which is treated as the callback. The callback is passed passed a first argument
                   * of null on success to mimick standard node callbacks.
                   */
                  makeAsync: function makeAsync(fn, expectedArgs) {
                    if (expectedArgs && expectedArgs <= fn.length) {
                      return fn;
                    }
                    return function() {
                      var args = Array.prototype.slice.call(arguments, 0);
                      var callback = args.pop();
                      var result = fn.apply(null, args);
                      callback(result);
                    };
                  }
                },
                /**
                 * Date and time utility functions.
                 */
                date: {
                  /**
                   * @return [Date] the current JavaScript date object. Since all
                   *   AWS services rely on this date object, you can override
                   *   this function to provide a special time value to AWS service
                   *   requests.
                   */
                  getDate: function getDate() {
                    if (!AWS2)
                      AWS2 = require2("./core");
                    if (AWS2.config.systemClockOffset) {
                      return new Date((/* @__PURE__ */ new Date()).getTime() + AWS2.config.systemClockOffset);
                    } else {
                      return /* @__PURE__ */ new Date();
                    }
                  },
                  /**
                   * @return [String] the date in ISO-8601 format
                   */
                  iso8601: function iso8601(date) {
                    if (date === void 0) {
                      date = util.date.getDate();
                    }
                    return date.toISOString().replace(/\.\d{3}Z$/, "Z");
                  },
                  /**
                   * @return [String] the date in RFC 822 format
                   */
                  rfc822: function rfc822(date) {
                    if (date === void 0) {
                      date = util.date.getDate();
                    }
                    return date.toUTCString();
                  },
                  /**
                   * @return [Integer] the UNIX timestamp value for the current time
                   */
                  unixTimestamp: function unixTimestamp(date) {
                    if (date === void 0) {
                      date = util.date.getDate();
                    }
                    return date.getTime() / 1e3;
                  },
                  /**
                   * @param [String,number,Date] date
                   * @return [Date]
                   */
                  from: function format(date) {
                    if (typeof date === "number") {
                      return new Date(date * 1e3);
                    } else {
                      return new Date(date);
                    }
                  },
                  /**
                   * Given a Date or date-like value, this function formats the
                   * date into a string of the requested value.
                   * @param [String,number,Date] date
                   * @param [String] formatter Valid formats are:
                   #   * 'iso8601'
                   #   * 'rfc822'
                   #   * 'unixTimestamp'
                   * @return [String]
                   */
                  format: function format(date, formatter) {
                    if (!formatter)
                      formatter = "iso8601";
                    return util.date[formatter](util.date.from(date));
                  },
                  parseTimestamp: function parseTimestamp(value) {
                    if (typeof value === "number") {
                      return new Date(value * 1e3);
                    } else if (value.match(/^\d+$/)) {
                      return new Date(value * 1e3);
                    } else if (value.match(/^\d{4}/)) {
                      return new Date(value);
                    } else if (value.match(/^\w{3},/)) {
                      return new Date(value);
                    } else {
                      throw util.error(
                        new Error("unhandled timestamp format: " + value),
                        { code: "TimestampParserError" }
                      );
                    }
                  }
                },
                crypto: {
                  crc32Table: [
                    0,
                    1996959894,
                    3993919788,
                    2567524794,
                    124634137,
                    1886057615,
                    3915621685,
                    2657392035,
                    249268274,
                    2044508324,
                    3772115230,
                    2547177864,
                    162941995,
                    2125561021,
                    3887607047,
                    2428444049,
                    498536548,
                    1789927666,
                    4089016648,
                    2227061214,
                    450548861,
                    1843258603,
                    4107580753,
                    2211677639,
                    325883990,
                    1684777152,
                    4251122042,
                    2321926636,
                    335633487,
                    1661365465,
                    4195302755,
                    2366115317,
                    997073096,
                    1281953886,
                    3579855332,
                    2724688242,
                    1006888145,
                    1258607687,
                    3524101629,
                    2768942443,
                    901097722,
                    1119000684,
                    3686517206,
                    2898065728,
                    853044451,
                    1172266101,
                    3705015759,
                    2882616665,
                    651767980,
                    1373503546,
                    3369554304,
                    3218104598,
                    565507253,
                    1454621731,
                    3485111705,
                    3099436303,
                    671266974,
                    1594198024,
                    3322730930,
                    2970347812,
                    795835527,
                    1483230225,
                    3244367275,
                    3060149565,
                    1994146192,
                    31158534,
                    2563907772,
                    4023717930,
                    1907459465,
                    112637215,
                    2680153253,
                    3904427059,
                    2013776290,
                    251722036,
                    2517215374,
                    3775830040,
                    2137656763,
                    141376813,
                    2439277719,
                    3865271297,
                    1802195444,
                    476864866,
                    2238001368,
                    4066508878,
                    1812370925,
                    453092731,
                    2181625025,
                    4111451223,
                    1706088902,
                    314042704,
                    2344532202,
                    4240017532,
                    1658658271,
                    366619977,
                    2362670323,
                    4224994405,
                    1303535960,
                    984961486,
                    2747007092,
                    3569037538,
                    1256170817,
                    1037604311,
                    2765210733,
                    3554079995,
                    1131014506,
                    879679996,
                    2909243462,
                    3663771856,
                    1141124467,
                    855842277,
                    2852801631,
                    3708648649,
                    1342533948,
                    654459306,
                    3188396048,
                    3373015174,
                    1466479909,
                    544179635,
                    3110523913,
                    3462522015,
                    1591671054,
                    702138776,
                    2966460450,
                    3352799412,
                    1504918807,
                    783551873,
                    3082640443,
                    3233442989,
                    3988292384,
                    2596254646,
                    62317068,
                    1957810842,
                    3939845945,
                    2647816111,
                    81470997,
                    1943803523,
                    3814918930,
                    2489596804,
                    225274430,
                    2053790376,
                    3826175755,
                    2466906013,
                    167816743,
                    2097651377,
                    4027552580,
                    2265490386,
                    503444072,
                    1762050814,
                    4150417245,
                    2154129355,
                    426522225,
                    1852507879,
                    4275313526,
                    2312317920,
                    282753626,
                    1742555852,
                    4189708143,
                    2394877945,
                    397917763,
                    1622183637,
                    3604390888,
                    2714866558,
                    953729732,
                    1340076626,
                    3518719985,
                    2797360999,
                    1068828381,
                    1219638859,
                    3624741850,
                    2936675148,
                    906185462,
                    1090812512,
                    3747672003,
                    2825379669,
                    829329135,
                    1181335161,
                    3412177804,
                    3160834842,
                    628085408,
                    1382605366,
                    3423369109,
                    3138078467,
                    570562233,
                    1426400815,
                    3317316542,
                    2998733608,
                    733239954,
                    1555261956,
                    3268935591,
                    3050360625,
                    752459403,
                    1541320221,
                    2607071920,
                    3965973030,
                    1969922972,
                    40735498,
                    2617837225,
                    3943577151,
                    1913087877,
                    83908371,
                    2512341634,
                    3803740692,
                    2075208622,
                    213261112,
                    2463272603,
                    3855990285,
                    2094854071,
                    198958881,
                    2262029012,
                    4057260610,
                    1759359992,
                    534414190,
                    2176718541,
                    4139329115,
                    1873836001,
                    414664567,
                    2282248934,
                    4279200368,
                    1711684554,
                    285281116,
                    2405801727,
                    4167216745,
                    1634467795,
                    376229701,
                    2685067896,
                    3608007406,
                    1308918612,
                    956543938,
                    2808555105,
                    3495958263,
                    1231636301,
                    1047427035,
                    2932959818,
                    3654703836,
                    1088359270,
                    936918e3,
                    2847714899,
                    3736837829,
                    1202900863,
                    817233897,
                    3183342108,
                    3401237130,
                    1404277552,
                    615818150,
                    3134207493,
                    3453421203,
                    1423857449,
                    601450431,
                    3009837614,
                    3294710456,
                    1567103746,
                    711928724,
                    3020668471,
                    3272380065,
                    1510334235,
                    755167117
                  ],
                  crc32: function crc32(data) {
                    var tbl = util.crypto.crc32Table;
                    var crc = 0 ^ -1;
                    if (typeof data === "string") {
                      data = util.buffer.toBuffer(data);
                    }
                    for (var i = 0; i < data.length; i++) {
                      var code = data.readUInt8(i);
                      crc = crc >>> 8 ^ tbl[(crc ^ code) & 255];
                    }
                    return (crc ^ -1) >>> 0;
                  },
                  hmac: function hmac(key, string, digest, fn) {
                    if (!digest)
                      digest = "binary";
                    if (digest === "buffer") {
                      digest = void 0;
                    }
                    if (!fn)
                      fn = "sha256";
                    if (typeof string === "string")
                      string = util.buffer.toBuffer(string);
                    return util.crypto.lib.createHmac(fn, key).update(string).digest(digest);
                  },
                  md5: function md52(data, digest, callback) {
                    return util.crypto.hash("md5", data, digest, callback);
                  },
                  sha256: function sha256(data, digest, callback) {
                    return util.crypto.hash("sha256", data, digest, callback);
                  },
                  hash: function(algorithm, data, digest, callback) {
                    var hash = util.crypto.createHash(algorithm);
                    if (!digest) {
                      digest = "binary";
                    }
                    if (digest === "buffer") {
                      digest = void 0;
                    }
                    if (typeof data === "string")
                      data = util.buffer.toBuffer(data);
                    var sliceFn = util.arraySliceFn(data);
                    var isBuffer = util.Buffer.isBuffer(data);
                    if (util.isBrowser() && typeof ArrayBuffer !== "undefined" && data && data.buffer instanceof ArrayBuffer)
                      isBuffer = true;
                    if (callback && typeof data === "object" && typeof data.on === "function" && !isBuffer) {
                      data.on("data", function(chunk) {
                        hash.update(chunk);
                      });
                      data.on("error", function(err) {
                        callback(err);
                      });
                      data.on("end", function() {
                        callback(null, hash.digest(digest));
                      });
                    } else if (callback && sliceFn && !isBuffer && typeof FileReader !== "undefined") {
                      var index = 0, size = 1024 * 512;
                      var reader = new FileReader();
                      reader.onerror = function() {
                        callback(new Error("Failed to read data."));
                      };
                      reader.onload = function() {
                        var buf = new util.Buffer(new Uint8Array(reader.result));
                        hash.update(buf);
                        index += buf.length;
                        reader._continueReading();
                      };
                      reader._continueReading = function() {
                        if (index >= data.size) {
                          callback(null, hash.digest(digest));
                          return;
                        }
                        var back = index + size;
                        if (back > data.size)
                          back = data.size;
                        reader.readAsArrayBuffer(sliceFn.call(data, index, back));
                      };
                      reader._continueReading();
                    } else {
                      if (util.isBrowser() && typeof data === "object" && !isBuffer) {
                        data = new util.Buffer(new Uint8Array(data));
                      }
                      var out = hash.update(data).digest(digest);
                      if (callback)
                        callback(null, out);
                      return out;
                    }
                  },
                  toHex: function toHex(data) {
                    var out = [];
                    for (var i = 0; i < data.length; i++) {
                      out.push(("0" + data.charCodeAt(i).toString(16)).substr(-2, 2));
                    }
                    return out.join("");
                  },
                  createHash: function createHash(algorithm) {
                    return util.crypto.lib.createHash(algorithm);
                  }
                },
                /** @!ignore */
                /* Abort constant */
                abort: {},
                each: function each(object, iterFunction) {
                  for (var key in object) {
                    if (Object.prototype.hasOwnProperty.call(object, key)) {
                      var ret = iterFunction.call(this, key, object[key]);
                      if (ret === util.abort)
                        break;
                    }
                  }
                },
                arrayEach: function arrayEach(array, iterFunction) {
                  for (var idx in array) {
                    if (Object.prototype.hasOwnProperty.call(array, idx)) {
                      var ret = iterFunction.call(this, array[idx], parseInt(idx, 10));
                      if (ret === util.abort)
                        break;
                    }
                  }
                },
                update: function update(obj1, obj2) {
                  util.each(obj2, function iterator(key, item) {
                    obj1[key] = item;
                  });
                  return obj1;
                },
                merge: function merge(obj1, obj2) {
                  return util.update(util.copy(obj1), obj2);
                },
                copy: function copy(object) {
                  if (object === null || object === void 0)
                    return object;
                  var dupe = {};
                  for (var key in object) {
                    dupe[key] = object[key];
                  }
                  return dupe;
                },
                isEmpty: function isEmpty(obj) {
                  for (var prop in obj) {
                    if (Object.prototype.hasOwnProperty.call(obj, prop)) {
                      return false;
                    }
                  }
                  return true;
                },
                arraySliceFn: function arraySliceFn(obj) {
                  var fn = obj.slice || obj.webkitSlice || obj.mozSlice;
                  return typeof fn === "function" ? fn : null;
                },
                isType: function isType(obj, type) {
                  if (typeof type === "function")
                    type = util.typeName(type);
                  return Object.prototype.toString.call(obj) === "[object " + type + "]";
                },
                typeName: function typeName(type) {
                  if (Object.prototype.hasOwnProperty.call(type, "name"))
                    return type.name;
                  var str = type.toString();
                  var match = str.match(/^\s*function (.+)\(/);
                  return match ? match[1] : str;
                },
                error: function error(err, options) {
                  var originalError = null;
                  if (typeof err.message === "string" && err.message !== "") {
                    if (typeof options === "string" || options && options.message) {
                      originalError = util.copy(err);
                      originalError.message = err.message;
                    }
                  }
                  err.message = err.message || null;
                  if (typeof options === "string") {
                    err.message = options;
                  } else if (typeof options === "object" && options !== null) {
                    util.update(err, options);
                    if (options.message)
                      err.message = options.message;
                    if (options.code || options.name)
                      err.code = options.code || options.name;
                    if (options.stack)
                      err.stack = options.stack;
                  }
                  if (typeof Object.defineProperty === "function") {
                    Object.defineProperty(err, "name", { writable: true, enumerable: false });
                    Object.defineProperty(err, "message", { enumerable: true });
                  }
                  err.name = String(options && options.name || err.name || err.code || "Error");
                  err.time = /* @__PURE__ */ new Date();
                  if (originalError) {
                    err.originalError = originalError;
                  }
                  for (var key in options || {}) {
                    if (key[0] === "[" && key[key.length - 1] === "]") {
                      key = key.slice(1, -1);
                      if (key === "code" || key === "message") {
                        continue;
                      }
                      err["[" + key + "]"] = "See error." + key + " for details.";
                      Object.defineProperty(err, key, {
                        value: err[key] || options && options[key] || originalError && originalError[key],
                        enumerable: false,
                        writable: true
                      });
                    }
                  }
                  return err;
                },
                /**
                 * @api private
                 */
                inherit: function inherit(klass, features) {
                  var newObject = null;
                  if (features === void 0) {
                    features = klass;
                    klass = Object;
                    newObject = {};
                  } else {
                    var ctor = function ConstructorWrapper() {
                    };
                    ctor.prototype = klass.prototype;
                    newObject = new ctor();
                  }
                  if (features.constructor === Object) {
                    features.constructor = function() {
                      if (klass !== Object) {
                        return klass.apply(this, arguments);
                      }
                    };
                  }
                  features.constructor.prototype = newObject;
                  util.update(features.constructor.prototype, features);
                  features.constructor.__super__ = klass;
                  return features.constructor;
                },
                /**
                 * @api private
                 */
                mixin: function mixin() {
                  var klass = arguments[0];
                  for (var i = 1; i < arguments.length; i++) {
                    for (var prop in arguments[i].prototype) {
                      var fn = arguments[i].prototype[prop];
                      if (prop !== "constructor") {
                        klass.prototype[prop] = fn;
                      }
                    }
                  }
                  return klass;
                },
                /**
                 * @api private
                 */
                hideProperties: function hideProperties(obj, props) {
                  if (typeof Object.defineProperty !== "function")
                    return;
                  util.arrayEach(props, function(key) {
                    Object.defineProperty(obj, key, {
                      enumerable: false,
                      writable: true,
                      configurable: true
                    });
                  });
                },
                /**
                 * @api private
                 */
                property: function property(obj, name, value, enumerable, isValue) {
                  var opts = {
                    configurable: true,
                    enumerable: enumerable !== void 0 ? enumerable : true
                  };
                  if (typeof value === "function" && !isValue) {
                    opts.get = value;
                  } else {
                    opts.value = value;
                    opts.writable = true;
                  }
                  Object.defineProperty(obj, name, opts);
                },
                /**
                 * @api private
                 */
                memoizedProperty: function memoizedProperty(obj, name, get, enumerable) {
                  var cachedValue = null;
                  util.property(obj, name, function() {
                    if (cachedValue === null) {
                      cachedValue = get();
                    }
                    return cachedValue;
                  }, enumerable);
                },
                /**
                 * TODO Remove in major version revision
                 * This backfill populates response data without the
                 * top-level payload name.
                 *
                 * @api private
                 */
                hoistPayloadMember: function hoistPayloadMember(resp) {
                  var req = resp.request;
                  var operationName = req.operation;
                  var operation = req.service.api.operations[operationName];
                  var output = operation.output;
                  if (output.payload && !operation.hasEventOutput) {
                    var payloadMember = output.members[output.payload];
                    var responsePayload = resp.data[output.payload];
                    if (payloadMember.type === "structure") {
                      util.each(responsePayload, function(key, value) {
                        util.property(resp.data, key, value, false);
                      });
                    }
                  }
                },
                /**
                 * Compute SHA-256 checksums of streams
                 *
                 * @api private
                 */
                computeSha256: function computeSha256(body, done) {
                  if (util.isNode()) {
                    var Stream = util.stream.Stream;
                    var fs = require2("fs");
                    if (typeof Stream === "function" && body instanceof Stream) {
                      if (typeof body.path === "string") {
                        var settings = {};
                        if (typeof body.start === "number") {
                          settings.start = body.start;
                        }
                        if (typeof body.end === "number") {
                          settings.end = body.end;
                        }
                        body = fs.createReadStream(body.path, settings);
                      } else {
                        return done(new Error("Non-file stream objects are not supported with SigV4"));
                      }
                    }
                  }
                  util.crypto.sha256(body, "hex", function(err, sha) {
                    if (err)
                      done(err);
                    else
                      done(null, sha);
                  });
                },
                /**
                 * @api private
                 */
                isClockSkewed: function isClockSkewed(serverTime) {
                  if (serverTime) {
                    util.property(
                      AWS2.config,
                      "isClockSkewed",
                      Math.abs((/* @__PURE__ */ new Date()).getTime() - serverTime) >= 3e5,
                      false
                    );
                    return AWS2.config.isClockSkewed;
                  }
                },
                applyClockOffset: function applyClockOffset(serverTime) {
                  if (serverTime)
                    AWS2.config.systemClockOffset = serverTime - (/* @__PURE__ */ new Date()).getTime();
                },
                /**
                 * @api private
                 */
                extractRequestId: function extractRequestId(resp) {
                  var requestId = resp.httpResponse.headers["x-amz-request-id"] || resp.httpResponse.headers["x-amzn-requestid"];
                  if (!requestId && resp.data && resp.data.ResponseMetadata) {
                    requestId = resp.data.ResponseMetadata.RequestId;
                  }
                  if (requestId) {
                    resp.requestId = requestId;
                  }
                  if (resp.error) {
                    resp.error.requestId = requestId;
                  }
                },
                /**
                 * @api private
                 */
                addPromises: function addPromises(constructors, PromiseDependency) {
                  var deletePromises = false;
                  if (PromiseDependency === void 0 && AWS2 && AWS2.config) {
                    PromiseDependency = AWS2.config.getPromisesDependency();
                  }
                  if (PromiseDependency === void 0 && typeof Promise !== "undefined") {
                    PromiseDependency = Promise;
                  }
                  if (typeof PromiseDependency !== "function")
                    deletePromises = true;
                  if (!Array.isArray(constructors))
                    constructors = [constructors];
                  for (var ind = 0; ind < constructors.length; ind++) {
                    var constructor = constructors[ind];
                    if (deletePromises) {
                      if (constructor.deletePromisesFromClass) {
                        constructor.deletePromisesFromClass();
                      }
                    } else if (constructor.addPromisesToClass) {
                      constructor.addPromisesToClass(PromiseDependency);
                    }
                  }
                },
                /**
                 * @api private
                 * Return a function that will return a promise whose fate is decided by the
                 * callback behavior of the given method with `methodName`. The method to be
                 * promisified should conform to node.js convention of accepting a callback as
                 * last argument and calling that callback with error as the first argument
                 * and success value on the second argument.
                 */
                promisifyMethod: function promisifyMethod(methodName, PromiseDependency) {
                  return function promise() {
                    var self2 = this;
                    var args = Array.prototype.slice.call(arguments);
                    return new PromiseDependency(function(resolve, reject) {
                      args.push(function(err, data) {
                        if (err) {
                          reject(err);
                        } else {
                          resolve(data);
                        }
                      });
                      self2[methodName].apply(self2, args);
                    });
                  };
                },
                /**
                 * @api private
                 */
                isDualstackAvailable: function isDualstackAvailable(service) {
                  if (!service)
                    return false;
                  var metadata = require2("../apis/metadata.json");
                  if (typeof service !== "string")
                    service = service.serviceIdentifier;
                  if (typeof service !== "string" || !metadata.hasOwnProperty(service))
                    return false;
                  return !!metadata[service].dualstackAvailable;
                },
                /**
                 * @api private
                 */
                calculateRetryDelay: function calculateRetryDelay(retryCount, retryDelayOptions, err) {
                  if (!retryDelayOptions)
                    retryDelayOptions = {};
                  var customBackoff = retryDelayOptions.customBackoff || null;
                  if (typeof customBackoff === "function") {
                    return customBackoff(retryCount, err);
                  }
                  var base = typeof retryDelayOptions.base === "number" ? retryDelayOptions.base : 100;
                  var delay = Math.random() * (Math.pow(2, retryCount) * base);
                  return delay;
                },
                /**
                 * @api private
                 */
                handleRequestWithRetries: function handleRequestWithRetries(httpRequest, options, cb) {
                  if (!options)
                    options = {};
                  var http = AWS2.HttpClient.getInstance();
                  var httpOptions = options.httpOptions || {};
                  var retryCount = 0;
                  var errCallback = function(err) {
                    var maxRetries = options.maxRetries || 0;
                    if (err && err.code === "TimeoutError")
                      err.retryable = true;
                    if (err && err.retryable && retryCount < maxRetries) {
                      var delay = util.calculateRetryDelay(retryCount, options.retryDelayOptions, err);
                      if (delay >= 0) {
                        retryCount++;
                        setTimeout(sendRequest, delay + (err.retryAfter || 0));
                        return;
                      }
                    }
                    cb(err);
                  };
                  var sendRequest = function() {
                    var data = "";
                    http.handleRequest(httpRequest, httpOptions, function(httpResponse) {
                      httpResponse.on("data", function(chunk) {
                        data += chunk.toString();
                      });
                      httpResponse.on("end", function() {
                        var statusCode = httpResponse.statusCode;
                        if (statusCode < 300) {
                          cb(null, data);
                        } else {
                          var retryAfter = parseInt(httpResponse.headers["retry-after"], 10) * 1e3 || 0;
                          var err = util.error(
                            new Error(),
                            {
                              statusCode,
                              retryable: statusCode >= 500 || statusCode === 429
                            }
                          );
                          if (retryAfter && err.retryable)
                            err.retryAfter = retryAfter;
                          errCallback(err);
                        }
                      });
                    }, errCallback);
                  };
                  AWS2.util.defer(sendRequest);
                },
                /**
                 * @api private
                 */
                uuid: {
                  v4: function uuidV4() {
                    return require2("uuid").v4();
                  }
                },
                /**
                 * @api private
                 */
                convertPayloadToString: function convertPayloadToString(resp) {
                  var req = resp.request;
                  var operation = req.operation;
                  var rules = req.service.api.operations[operation].output || {};
                  if (rules.payload && resp.data[rules.payload]) {
                    resp.data[rules.payload] = resp.data[rules.payload].toString();
                  }
                },
                /**
                 * @api private
                 */
                defer: function defer(callback) {
                  if (typeof process === "object" && typeof process.nextTick === "function") {
                    process.nextTick(callback);
                  } else if (typeof setImmediate === "function") {
                    setImmediate(callback);
                  } else {
                    setTimeout(callback, 0);
                  }
                },
                /**
                 * @api private
                 */
                getRequestPayloadShape: function getRequestPayloadShape(req) {
                  var operations = req.service.api.operations;
                  if (!operations)
                    return void 0;
                  var operation = (operations || {})[req.operation];
                  if (!operation || !operation.input || !operation.input.payload)
                    return void 0;
                  return operation.input.members[operation.input.payload];
                },
                getProfilesFromSharedConfig: function getProfilesFromSharedConfig(iniLoader, filename) {
                  var profiles = {};
                  var profilesFromConfig = {};
                  if (process.env[util.configOptInEnv]) {
                    var profilesFromConfig = iniLoader.loadFrom({
                      isConfig: true,
                      filename: process.env[util.sharedConfigFileEnv]
                    });
                  }
                  var profilesFromCreds = {};
                  try {
                    var profilesFromCreds = iniLoader.loadFrom({
                      filename: filename || process.env[util.configOptInEnv] && process.env[util.sharedCredentialsFileEnv]
                    });
                  } catch (error) {
                    if (!process.env[util.configOptInEnv])
                      throw error;
                  }
                  for (var i = 0, profileNames = Object.keys(profilesFromConfig); i < profileNames.length; i++) {
                    profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromConfig[profileNames[i]]);
                  }
                  for (var i = 0, profileNames = Object.keys(profilesFromCreds); i < profileNames.length; i++) {
                    profiles[profileNames[i]] = objectAssign(profiles[profileNames[i]] || {}, profilesFromCreds[profileNames[i]]);
                  }
                  return profiles;
                  function objectAssign(target, source) {
                    for (var i2 = 0, keys = Object.keys(source); i2 < keys.length; i2++) {
                      target[keys[i2]] = source[keys[i2]];
                    }
                    return target;
                  }
                },
                /**
                 * @api private
                 */
                ARN: {
                  validate: function validateARN(str) {
                    return str && str.indexOf("arn:") === 0 && str.split(":").length >= 6;
                  },
                  parse: function parseARN(arn) {
                    var matched = arn.split(":");
                    return {
                      partition: matched[1],
                      service: matched[2],
                      region: matched[3],
                      accountId: matched[4],
                      resource: matched.slice(5).join(":")
                    };
                  },
                  build: function buildARN(arnObject) {
                    if (arnObject.service === void 0 || arnObject.region === void 0 || arnObject.accountId === void 0 || arnObject.resource === void 0)
                      throw util.error(new Error("Input ARN object is invalid"));
                    return "arn:" + (arnObject.partition || "aws") + ":" + arnObject.service + ":" + arnObject.region + ":" + arnObject.accountId + ":" + arnObject.resource;
                  }
                },
                /**
                 * @api private
                 */
                defaultProfile: "default",
                /**
                 * @api private
                 */
                configOptInEnv: "AWS_SDK_LOAD_CONFIG",
                /**
                 * @api private
                 */
                sharedCredentialsFileEnv: "AWS_SHARED_CREDENTIALS_FILE",
                /**
                 * @api private
                 */
                sharedConfigFileEnv: "AWS_CONFIG_FILE",
                /**
                 * @api private
                 */
                imdsDisabledEnv: "AWS_EC2_METADATA_DISABLED"
              };
              module2.exports = util;
            }).call(this);
          }).call(this, require2("_process"), require2("timers").setImmediate);
        }, { "../apis/metadata.json": 4, "./core": 19, "_process": 91, "fs": 82, "timers": 99, "uuid": 102 }], 75: [function(require2, module2, exports2) {
          var util = require2("../util");
          var Shape = require2("../model/shape");
          function DomXmlParser() {
          }
          DomXmlParser.prototype.parse = function(xml, shape) {
            if (xml.replace(/^\s+/, "") === "")
              return {};
            var result, error;
            try {
              if (window.DOMParser) {
                try {
                  var parser = new DOMParser();
                  result = parser.parseFromString(xml, "text/xml");
                } catch (syntaxError) {
                  throw util.error(
                    new Error("Parse error in document"),
                    {
                      originalError: syntaxError,
                      code: "XMLParserError",
                      retryable: true
                    }
                  );
                }
                if (result.documentElement === null) {
                  throw util.error(
                    new Error("Cannot parse empty document."),
                    {
                      code: "XMLParserError",
                      retryable: true
                    }
                  );
                }
                var isError = result.getElementsByTagName("parsererror")[0];
                if (isError && (isError.parentNode === result || isError.parentNode.nodeName === "body" || isError.parentNode.parentNode === result || isError.parentNode.parentNode.nodeName === "body")) {
                  var errorElement = isError.getElementsByTagName("div")[0] || isError;
                  throw util.error(
                    new Error(errorElement.textContent || "Parser error in document"),
                    {
                      code: "XMLParserError",
                      retryable: true
                    }
                  );
                }
              } else if (window.ActiveXObject) {
                result = new window.ActiveXObject("Microsoft.XMLDOM");
                result.async = false;
                if (!result.loadXML(xml)) {
                  throw util.error(
                    new Error("Parse error in document"),
                    {
                      code: "XMLParserError",
                      retryable: true
                    }
                  );
                }
              } else {
                throw new Error("Cannot load XML parser");
              }
            } catch (e) {
              error = e;
            }
            if (result && result.documentElement && !error) {
              var data = parseXml(result.documentElement, shape);
              var metadata = getElementByTagName(result.documentElement, "ResponseMetadata");
              if (metadata) {
                data.ResponseMetadata = parseXml(metadata, {});
              }
              return data;
            } else if (error) {
              throw util.error(error || new Error(), { code: "XMLParserError", retryable: true });
            } else {
              return {};
            }
          };
          function getElementByTagName(xml, tag) {
            var elements = xml.getElementsByTagName(tag);
            for (var i = 0, iLen = elements.length; i < iLen; i++) {
              if (elements[i].parentNode === xml) {
                return elements[i];
              }
            }
          }
          function parseXml(xml, shape) {
            if (!shape)
              shape = {};
            switch (shape.type) {
              case "structure":
                return parseStructure(xml, shape);
              case "map":
                return parseMap(xml, shape);
              case "list":
                return parseList(xml, shape);
              case void 0:
              case null:
                return parseUnknown(xml);
              default:
                return parseScalar(xml, shape);
            }
          }
          function parseStructure(xml, shape) {
            var data = {};
            if (xml === null)
              return data;
            util.each(shape.members, function(memberName, memberShape) {
              if (memberShape.isXmlAttribute) {
                if (Object.prototype.hasOwnProperty.call(xml.attributes, memberShape.name)) {
                  var value = xml.attributes[memberShape.name].value;
                  data[memberName] = parseXml({ textContent: value }, memberShape);
                }
              } else {
                var xmlChild = memberShape.flattened ? xml : getElementByTagName(xml, memberShape.name);
                if (xmlChild) {
                  data[memberName] = parseXml(xmlChild, memberShape);
                } else if (!memberShape.flattened && memberShape.type === "list" && !shape.api.xmlNoDefaultLists) {
                  data[memberName] = memberShape.defaultValue;
                }
              }
            });
            return data;
          }
          function parseMap(xml, shape) {
            var data = {};
            var xmlKey = shape.key.name || "key";
            var xmlValue = shape.value.name || "value";
            var tagName = shape.flattened ? shape.name : "entry";
            var child = xml.firstElementChild;
            while (child) {
              if (child.nodeName === tagName) {
                var key = getElementByTagName(child, xmlKey).textContent;
                var value = getElementByTagName(child, xmlValue);
                data[key] = parseXml(value, shape.value);
              }
              child = child.nextElementSibling;
            }
            return data;
          }
          function parseList(xml, shape) {
            var data = [];
            var tagName = shape.flattened ? shape.name : shape.member.name || "member";
            var child = xml.firstElementChild;
            while (child) {
              if (child.nodeName === tagName) {
                data.push(parseXml(child, shape.member));
              }
              child = child.nextElementSibling;
            }
            return data;
          }
          function parseScalar(xml, shape) {
            if (xml.getAttribute) {
              var encoding = xml.getAttribute("encoding");
              if (encoding === "base64") {
                shape = new Shape.create({ type: encoding });
              }
            }
            var text = xml.textContent;
            if (text === "")
              text = null;
            if (typeof shape.toType === "function") {
              return shape.toType(text);
            } else {
              return text;
            }
          }
          function parseUnknown(xml) {
            if (xml === void 0 || xml === null)
              return "";
            if (!xml.firstElementChild) {
              if (xml.parentNode.parentNode === null)
                return {};
              if (xml.childNodes.length === 0)
                return "";
              else
                return xml.textContent;
            }
            var shape = { type: "structure", members: {} };
            var child = xml.firstElementChild;
            while (child) {
              var tag = child.nodeName;
              if (Object.prototype.hasOwnProperty.call(shape.members, tag)) {
                shape.members[tag].type = "list";
              } else {
                shape.members[tag] = { name: tag };
              }
              child = child.nextElementSibling;
            }
            return parseStructure(xml, shape);
          }
          module2.exports = DomXmlParser;
        }, { "../model/shape": 45, "../util": 74 }], 76: [function(require2, module2, exports2) {
          var util = require2("../util");
          var XmlNode = require2("./xml-node").XmlNode;
          var XmlText = require2("./xml-text").XmlText;
          function XmlBuilder() {
          }
          XmlBuilder.prototype.toXML = function(params, shape, rootElement, noEmpty) {
            var xml = new XmlNode(rootElement);
            applyNamespaces(xml, shape, true);
            serialize(xml, params, shape);
            return xml.children.length > 0 || noEmpty ? xml.toString() : "";
          };
          function serialize(xml, value, shape) {
            switch (shape.type) {
              case "structure":
                return serializeStructure(xml, value, shape);
              case "map":
                return serializeMap(xml, value, shape);
              case "list":
                return serializeList(xml, value, shape);
              default:
                return serializeScalar(xml, value, shape);
            }
          }
          function serializeStructure(xml, params, shape) {
            util.arrayEach(shape.memberNames, function(memberName) {
              var memberShape = shape.members[memberName];
              if (memberShape.location !== "body")
                return;
              var value = params[memberName];
              var name = memberShape.name;
              if (value !== void 0 && value !== null) {
                if (memberShape.isXmlAttribute) {
                  xml.addAttribute(name, value);
                } else if (memberShape.flattened) {
                  serialize(xml, value, memberShape);
                } else {
                  var element = new XmlNode(name);
                  xml.addChildNode(element);
                  applyNamespaces(element, memberShape);
                  serialize(element, value, memberShape);
                }
              }
            });
          }
          function serializeMap(xml, map, shape) {
            var xmlKey = shape.key.name || "key";
            var xmlValue = shape.value.name || "value";
            util.each(map, function(key, value) {
              var entry = new XmlNode(shape.flattened ? shape.name : "entry");
              xml.addChildNode(entry);
              var entryKey = new XmlNode(xmlKey);
              var entryValue = new XmlNode(xmlValue);
              entry.addChildNode(entryKey);
              entry.addChildNode(entryValue);
              serialize(entryKey, key, shape.key);
              serialize(entryValue, value, shape.value);
            });
          }
          function serializeList(xml, list, shape) {
            if (shape.flattened) {
              util.arrayEach(list, function(value) {
                var name = shape.member.name || shape.name;
                var element = new XmlNode(name);
                xml.addChildNode(element);
                serialize(element, value, shape.member);
              });
            } else {
              util.arrayEach(list, function(value) {
                var name = shape.member.name || "member";
                var element = new XmlNode(name);
                xml.addChildNode(element);
                serialize(element, value, shape.member);
              });
            }
          }
          function serializeScalar(xml, value, shape) {
            xml.addChildNode(
              new XmlText(shape.toWireFormat(value))
            );
          }
          function applyNamespaces(xml, shape, isRoot) {
            var uri, prefix = "xmlns";
            if (shape.xmlNamespaceUri) {
              uri = shape.xmlNamespaceUri;
              if (shape.xmlNamespacePrefix)
                prefix += ":" + shape.xmlNamespacePrefix;
            } else if (isRoot && shape.api.xmlNamespaceUri) {
              uri = shape.api.xmlNamespaceUri;
            }
            if (uri)
              xml.addAttribute(prefix, uri);
          }
          module2.exports = XmlBuilder;
        }, { "../util": 74, "./xml-node": 79, "./xml-text": 80 }], 77: [function(require2, module2, exports2) {
          function escapeAttribute(value) {
            return value.replace(/&/g, "&amp;").replace(/'/g, "&apos;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;");
          }
          module2.exports = {
            escapeAttribute
          };
        }, {}], 78: [function(require2, module2, exports2) {
          function escapeElement(value) {
            return value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/\r/g, "&#x0D;").replace(/\n/g, "&#x0A;").replace(/\u0085/g, "&#x85;").replace(/\u2028/, "&#x2028;");
          }
          module2.exports = {
            escapeElement
          };
        }, {}], 79: [function(require2, module2, exports2) {
          var escapeAttribute = require2("./escape-attribute").escapeAttribute;
          function XmlNode(name, children) {
            if (children === void 0) {
              children = [];
            }
            this.name = name;
            this.children = children;
            this.attributes = {};
          }
          XmlNode.prototype.addAttribute = function(name, value) {
            this.attributes[name] = value;
            return this;
          };
          XmlNode.prototype.addChildNode = function(child) {
            this.children.push(child);
            return this;
          };
          XmlNode.prototype.removeAttribute = function(name) {
            delete this.attributes[name];
            return this;
          };
          XmlNode.prototype.toString = function() {
            var hasChildren = Boolean(this.children.length);
            var xmlText = "<" + this.name;
            var attributes = this.attributes;
            for (var i = 0, attributeNames = Object.keys(attributes); i < attributeNames.length; i++) {
              var attributeName = attributeNames[i];
              var attribute = attributes[attributeName];
              if (typeof attribute !== "undefined" && attribute !== null) {
                xmlText += " " + attributeName + '="' + escapeAttribute("" + attribute) + '"';
              }
            }
            return xmlText += !hasChildren ? "/>" : ">" + this.children.map(function(c) {
              return c.toString();
            }).join("") + "</" + this.name + ">";
          };
          module2.exports = {
            XmlNode
          };
        }, { "./escape-attribute": 77 }], 80: [function(require2, module2, exports2) {
          var escapeElement = require2("./escape-element").escapeElement;
          function XmlText(value) {
            this.value = value;
          }
          XmlText.prototype.toString = function() {
            return escapeElement("" + this.value);
          };
          module2.exports = {
            XmlText
          };
        }, { "./escape-element": 78 }], 81: [function(require2, module2, exports2) {
          "use strict";
          exports2.byteLength = byteLength;
          exports2.toByteArray = toByteArray;
          exports2.fromByteArray = fromByteArray;
          var lookup = [];
          var revLookup = [];
          var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
          var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
          for (var i = 0, len = code.length; i < len; ++i) {
            lookup[i] = code[i];
            revLookup[code.charCodeAt(i)] = i;
          }
          revLookup["-".charCodeAt(0)] = 62;
          revLookup["_".charCodeAt(0)] = 63;
          function getLens(b64) {
            var len2 = b64.length;
            if (len2 % 4 > 0) {
              throw new Error("Invalid string. Length must be a multiple of 4");
            }
            var validLen = b64.indexOf("=");
            if (validLen === -1)
              validLen = len2;
            var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
            return [validLen, placeHoldersLen];
          }
          function byteLength(b64) {
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function _byteLength(b64, validLen, placeHoldersLen) {
            return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
          }
          function toByteArray(b64) {
            var tmp;
            var lens = getLens(b64);
            var validLen = lens[0];
            var placeHoldersLen = lens[1];
            var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
            var curByte = 0;
            var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
            var i2;
            for (i2 = 0; i2 < len2; i2 += 4) {
              tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
              arr[curByte++] = tmp >> 16 & 255;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 2) {
              tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
              arr[curByte++] = tmp & 255;
            }
            if (placeHoldersLen === 1) {
              tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
              arr[curByte++] = tmp >> 8 & 255;
              arr[curByte++] = tmp & 255;
            }
            return arr;
          }
          function tripletToBase64(num) {
            return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
          }
          function encodeChunk(uint8, start, end) {
            var tmp;
            var output = [];
            for (var i2 = start; i2 < end; i2 += 3) {
              tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
              output.push(tripletToBase64(tmp));
            }
            return output.join("");
          }
          function fromByteArray(uint8) {
            var tmp;
            var len2 = uint8.length;
            var extraBytes = len2 % 3;
            var parts = [];
            var maxChunkLength = 16383;
            for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
              parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
            }
            if (extraBytes === 1) {
              tmp = uint8[len2 - 1];
              parts.push(
                lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "=="
              );
            } else if (extraBytes === 2) {
              tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
              parts.push(
                lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "="
              );
            }
            return parts.join("");
          }
        }, {}], 82: [function(require2, module2, exports2) {
        }, {}], 83: [function(require2, module2, exports2) {
          if (typeof Object.create === "function") {
            module2.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              ctor.prototype = Object.create(superCtor.prototype, {
                constructor: {
                  value: ctor,
                  enumerable: false,
                  writable: true,
                  configurable: true
                }
              });
            };
          } else {
            module2.exports = function inherits(ctor, superCtor) {
              ctor.super_ = superCtor;
              var TempCtor = function() {
              };
              TempCtor.prototype = superCtor.prototype;
              ctor.prototype = new TempCtor();
              ctor.prototype.constructor = ctor;
            };
          }
        }, {}], 84: [function(require2, module2, exports2) {
          module2.exports = function isBuffer(arg) {
            return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
          };
        }, {}], 85: [function(require2, module2, exports2) {
          (function(process, global) {
            (function() {
              var formatRegExp = /%[sdj%]/g;
              exports2.format = function(f) {
                if (!isString(f)) {
                  var objects = [];
                  for (var i = 0; i < arguments.length; i++) {
                    objects.push(inspect(arguments[i]));
                  }
                  return objects.join(" ");
                }
                var i = 1;
                var args = arguments;
                var len = args.length;
                var str = String(f).replace(formatRegExp, function(x2) {
                  if (x2 === "%%")
                    return "%";
                  if (i >= len)
                    return x2;
                  switch (x2) {
                    case "%s":
                      return String(args[i++]);
                    case "%d":
                      return Number(args[i++]);
                    case "%j":
                      try {
                        return JSON.stringify(args[i++]);
                      } catch (_) {
                        return "[Circular]";
                      }
                    default:
                      return x2;
                  }
                });
                for (var x = args[i]; i < len; x = args[++i]) {
                  if (isNull(x) || !isObject(x)) {
                    str += " " + x;
                  } else {
                    str += " " + inspect(x);
                  }
                }
                return str;
              };
              exports2.deprecate = function(fn, msg) {
                if (isUndefined(global.process)) {
                  return function() {
                    return exports2.deprecate(fn, msg).apply(this, arguments);
                  };
                }
                if (process.noDeprecation === true) {
                  return fn;
                }
                var warned = false;
                function deprecated() {
                  if (!warned) {
                    if (process.throwDeprecation) {
                      throw new Error(msg);
                    } else if (process.traceDeprecation) {
                      console.trace(msg);
                    } else {
                      console.error(msg);
                    }
                    warned = true;
                  }
                  return fn.apply(this, arguments);
                }
                return deprecated;
              };
              var debugs = {};
              var debugEnviron;
              exports2.debuglog = function(set) {
                if (isUndefined(debugEnviron))
                  debugEnviron = process.env.NODE_DEBUG || "";
                set = set.toUpperCase();
                if (!debugs[set]) {
                  if (new RegExp("\\b" + set + "\\b", "i").test(debugEnviron)) {
                    var pid = process.pid;
                    debugs[set] = function() {
                      var msg = exports2.format.apply(exports2, arguments);
                      console.error("%s %d: %s", set, pid, msg);
                    };
                  } else {
                    debugs[set] = function() {
                    };
                  }
                }
                return debugs[set];
              };
              function inspect(obj, opts) {
                var ctx = {
                  seen: [],
                  stylize: stylizeNoColor
                };
                if (arguments.length >= 3)
                  ctx.depth = arguments[2];
                if (arguments.length >= 4)
                  ctx.colors = arguments[3];
                if (isBoolean(opts)) {
                  ctx.showHidden = opts;
                } else if (opts) {
                  exports2._extend(ctx, opts);
                }
                if (isUndefined(ctx.showHidden))
                  ctx.showHidden = false;
                if (isUndefined(ctx.depth))
                  ctx.depth = 2;
                if (isUndefined(ctx.colors))
                  ctx.colors = false;
                if (isUndefined(ctx.customInspect))
                  ctx.customInspect = true;
                if (ctx.colors)
                  ctx.stylize = stylizeWithColor;
                return formatValue(ctx, obj, ctx.depth);
              }
              exports2.inspect = inspect;
              inspect.colors = {
                "bold": [1, 22],
                "italic": [3, 23],
                "underline": [4, 24],
                "inverse": [7, 27],
                "white": [37, 39],
                "grey": [90, 39],
                "black": [30, 39],
                "blue": [34, 39],
                "cyan": [36, 39],
                "green": [32, 39],
                "magenta": [35, 39],
                "red": [31, 39],
                "yellow": [33, 39]
              };
              inspect.styles = {
                "special": "cyan",
                "number": "yellow",
                "boolean": "yellow",
                "undefined": "grey",
                "null": "bold",
                "string": "green",
                "date": "magenta",
                // "name": intentionally not styling
                "regexp": "red"
              };
              function stylizeWithColor(str, styleType) {
                var style = inspect.styles[styleType];
                if (style) {
                  return "\x1B[" + inspect.colors[style][0] + "m" + str + "\x1B[" + inspect.colors[style][1] + "m";
                } else {
                  return str;
                }
              }
              function stylizeNoColor(str, styleType) {
                return str;
              }
              function arrayToHash(array) {
                var hash = {};
                array.forEach(function(val, idx) {
                  hash[val] = true;
                });
                return hash;
              }
              function formatValue(ctx, value, recurseTimes) {
                if (ctx.customInspect && value && isFunction(value.inspect) && // Filter out the util module, it's inspect function is special
                value.inspect !== exports2.inspect && // Also filter out any prototype objects using the circular check.
                !(value.constructor && value.constructor.prototype === value)) {
                  var ret = value.inspect(recurseTimes, ctx);
                  if (!isString(ret)) {
                    ret = formatValue(ctx, ret, recurseTimes);
                  }
                  return ret;
                }
                var primitive = formatPrimitive(ctx, value);
                if (primitive) {
                  return primitive;
                }
                var keys = Object.keys(value);
                var visibleKeys = arrayToHash(keys);
                if (ctx.showHidden) {
                  keys = Object.getOwnPropertyNames(value);
                }
                if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
                  return formatError(value);
                }
                if (keys.length === 0) {
                  if (isFunction(value)) {
                    var name = value.name ? ": " + value.name : "";
                    return ctx.stylize("[Function" + name + "]", "special");
                  }
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  }
                  if (isDate(value)) {
                    return ctx.stylize(Date.prototype.toString.call(value), "date");
                  }
                  if (isError(value)) {
                    return formatError(value);
                  }
                }
                var base = "", array = false, braces = ["{", "}"];
                if (isArray(value)) {
                  array = true;
                  braces = ["[", "]"];
                }
                if (isFunction(value)) {
                  var n = value.name ? ": " + value.name : "";
                  base = " [Function" + n + "]";
                }
                if (isRegExp(value)) {
                  base = " " + RegExp.prototype.toString.call(value);
                }
                if (isDate(value)) {
                  base = " " + Date.prototype.toUTCString.call(value);
                }
                if (isError(value)) {
                  base = " " + formatError(value);
                }
                if (keys.length === 0 && (!array || value.length == 0)) {
                  return braces[0] + base + braces[1];
                }
                if (recurseTimes < 0) {
                  if (isRegExp(value)) {
                    return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
                  } else {
                    return ctx.stylize("[Object]", "special");
                  }
                }
                ctx.seen.push(value);
                var output;
                if (array) {
                  output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
                } else {
                  output = keys.map(function(key) {
                    return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
                  });
                }
                ctx.seen.pop();
                return reduceToSingleString(output, base, braces);
              }
              function formatPrimitive(ctx, value) {
                if (isUndefined(value))
                  return ctx.stylize("undefined", "undefined");
                if (isString(value)) {
                  var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                  return ctx.stylize(simple, "string");
                }
                if (isNumber(value))
                  return ctx.stylize("" + value, "number");
                if (isBoolean(value))
                  return ctx.stylize("" + value, "boolean");
                if (isNull(value))
                  return ctx.stylize("null", "null");
              }
              function formatError(value) {
                return "[" + Error.prototype.toString.call(value) + "]";
              }
              function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
                var output = [];
                for (var i = 0, l = value.length; i < l; ++i) {
                  if (hasOwnProperty2(value, String(i))) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      String(i),
                      true
                    ));
                  } else {
                    output.push("");
                  }
                }
                keys.forEach(function(key) {
                  if (!key.match(/^\d+$/)) {
                    output.push(formatProperty(
                      ctx,
                      value,
                      recurseTimes,
                      visibleKeys,
                      key,
                      true
                    ));
                  }
                });
                return output;
              }
              function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
                var name, str, desc;
                desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
                if (desc.get) {
                  if (desc.set) {
                    str = ctx.stylize("[Getter/Setter]", "special");
                  } else {
                    str = ctx.stylize("[Getter]", "special");
                  }
                } else {
                  if (desc.set) {
                    str = ctx.stylize("[Setter]", "special");
                  }
                }
                if (!hasOwnProperty2(visibleKeys, key)) {
                  name = "[" + key + "]";
                }
                if (!str) {
                  if (ctx.seen.indexOf(desc.value) < 0) {
                    if (isNull(recurseTimes)) {
                      str = formatValue(ctx, desc.value, null);
                    } else {
                      str = formatValue(ctx, desc.value, recurseTimes - 1);
                    }
                    if (str.indexOf("\n") > -1) {
                      if (array) {
                        str = str.split("\n").map(function(line) {
                          return "  " + line;
                        }).join("\n").substr(2);
                      } else {
                        str = "\n" + str.split("\n").map(function(line) {
                          return "   " + line;
                        }).join("\n");
                      }
                    }
                  } else {
                    str = ctx.stylize("[Circular]", "special");
                  }
                }
                if (isUndefined(name)) {
                  if (array && key.match(/^\d+$/)) {
                    return str;
                  }
                  name = JSON.stringify("" + key);
                  if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
                    name = name.substr(1, name.length - 2);
                    name = ctx.stylize(name, "name");
                  } else {
                    name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
                    name = ctx.stylize(name, "string");
                  }
                }
                return name + ": " + str;
              }
              function reduceToSingleString(output, base, braces) {
                var numLinesEst = 0;
                var length = output.reduce(function(prev, cur) {
                  numLinesEst++;
                  if (cur.indexOf("\n") >= 0)
                    numLinesEst++;
                  return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
                }, 0);
                if (length > 60) {
                  return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
                }
                return braces[0] + base + " " + output.join(", ") + " " + braces[1];
              }
              function isArray(ar) {
                return Array.isArray(ar);
              }
              exports2.isArray = isArray;
              function isBoolean(arg) {
                return typeof arg === "boolean";
              }
              exports2.isBoolean = isBoolean;
              function isNull(arg) {
                return arg === null;
              }
              exports2.isNull = isNull;
              function isNullOrUndefined(arg) {
                return arg == null;
              }
              exports2.isNullOrUndefined = isNullOrUndefined;
              function isNumber(arg) {
                return typeof arg === "number";
              }
              exports2.isNumber = isNumber;
              function isString(arg) {
                return typeof arg === "string";
              }
              exports2.isString = isString;
              function isSymbol(arg) {
                return typeof arg === "symbol";
              }
              exports2.isSymbol = isSymbol;
              function isUndefined(arg) {
                return arg === void 0;
              }
              exports2.isUndefined = isUndefined;
              function isRegExp(re) {
                return isObject(re) && objectToString(re) === "[object RegExp]";
              }
              exports2.isRegExp = isRegExp;
              function isObject(arg) {
                return typeof arg === "object" && arg !== null;
              }
              exports2.isObject = isObject;
              function isDate(d) {
                return isObject(d) && objectToString(d) === "[object Date]";
              }
              exports2.isDate = isDate;
              function isError(e) {
                return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
              }
              exports2.isError = isError;
              function isFunction(arg) {
                return typeof arg === "function";
              }
              exports2.isFunction = isFunction;
              function isPrimitive(arg) {
                return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || // ES6 symbol
                typeof arg === "undefined";
              }
              exports2.isPrimitive = isPrimitive;
              exports2.isBuffer = require2("./support/isBuffer");
              function objectToString(o) {
                return Object.prototype.toString.call(o);
              }
              function pad(n) {
                return n < 10 ? "0" + n.toString(10) : n.toString(10);
              }
              var months = [
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec"
              ];
              function timestamp() {
                var d = /* @__PURE__ */ new Date();
                var time = [
                  pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())
                ].join(":");
                return [d.getDate(), months[d.getMonth()], time].join(" ");
              }
              exports2.log = function() {
                console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
              };
              exports2.inherits = require2("inherits");
              exports2._extend = function(origin, add) {
                if (!add || !isObject(add))
                  return origin;
                var keys = Object.keys(add);
                var i = keys.length;
                while (i--) {
                  origin[keys[i]] = add[keys[i]];
                }
                return origin;
              };
              function hasOwnProperty2(obj, prop) {
                return Object.prototype.hasOwnProperty.call(obj, prop);
              }
            }).call(this);
          }).call(this, require2("_process"), typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, { "./support/isBuffer": 84, "_process": 91, "inherits": 83 }], 86: [function(require2, module2, exports2) {
          (function(global, Buffer) {
            (function() {
              "use strict";
              var base64 = require2("base64-js");
              var ieee754 = require2("ieee754");
              var isArray = require2("isarray");
              exports2.Buffer = Buffer2;
              exports2.SlowBuffer = SlowBuffer;
              exports2.INSPECT_MAX_BYTES = 50;
              Buffer2.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== void 0 ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();
              exports2.kMaxLength = kMaxLength();
              function typedArraySupport() {
                try {
                  var arr = new Uint8Array(1);
                  arr.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                    return 42;
                  } };
                  return arr.foo() === 42 && // typed array instances can be augmented
                  typeof arr.subarray === "function" && // chrome 9-10 lack `subarray`
                  arr.subarray(1, 1).byteLength === 0;
                } catch (e) {
                  return false;
                }
              }
              function kMaxLength() {
                return Buffer2.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
              }
              function createBuffer(that, length) {
                if (kMaxLength() < length) {
                  throw new RangeError("Invalid typed array length");
                }
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  that = new Uint8Array(length);
                  that.__proto__ = Buffer2.prototype;
                } else {
                  if (that === null) {
                    that = new Buffer2(length);
                  }
                  that.length = length;
                }
                return that;
              }
              function Buffer2(arg, encodingOrOffset, length) {
                if (!Buffer2.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer2)) {
                  return new Buffer2(arg, encodingOrOffset, length);
                }
                if (typeof arg === "number") {
                  if (typeof encodingOrOffset === "string") {
                    throw new Error(
                      "If encoding is specified then the first argument must be a string"
                    );
                  }
                  return allocUnsafe(this, arg);
                }
                return from(this, arg, encodingOrOffset, length);
              }
              Buffer2.poolSize = 8192;
              Buffer2._augment = function(arr) {
                arr.__proto__ = Buffer2.prototype;
                return arr;
              };
              function from(that, value, encodingOrOffset, length) {
                if (typeof value === "number") {
                  throw new TypeError('"value" argument must not be a number');
                }
                if (typeof ArrayBuffer !== "undefined" && value instanceof ArrayBuffer) {
                  return fromArrayBuffer(that, value, encodingOrOffset, length);
                }
                if (typeof value === "string") {
                  return fromString(that, value, encodingOrOffset);
                }
                return fromObject(that, value);
              }
              Buffer2.from = function(value, encodingOrOffset, length) {
                return from(null, value, encodingOrOffset, length);
              };
              if (Buffer2.TYPED_ARRAY_SUPPORT) {
                Buffer2.prototype.__proto__ = Uint8Array.prototype;
                Buffer2.__proto__ = Uint8Array;
                if (typeof Symbol !== "undefined" && Symbol.species && Buffer2[Symbol.species] === Buffer2) {
                  Object.defineProperty(Buffer2, Symbol.species, {
                    value: null,
                    configurable: true
                  });
                }
              }
              function assertSize(size) {
                if (typeof size !== "number") {
                  throw new TypeError('"size" argument must be a number');
                } else if (size < 0) {
                  throw new RangeError('"size" argument must not be negative');
                }
              }
              function alloc(that, size, fill, encoding) {
                assertSize(size);
                if (size <= 0) {
                  return createBuffer(that, size);
                }
                if (fill !== void 0) {
                  return typeof encoding === "string" ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
                }
                return createBuffer(that, size);
              }
              Buffer2.alloc = function(size, fill, encoding) {
                return alloc(null, size, fill, encoding);
              };
              function allocUnsafe(that, size) {
                assertSize(size);
                that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
                if (!Buffer2.TYPED_ARRAY_SUPPORT) {
                  for (var i = 0; i < size; ++i) {
                    that[i] = 0;
                  }
                }
                return that;
              }
              Buffer2.allocUnsafe = function(size) {
                return allocUnsafe(null, size);
              };
              Buffer2.allocUnsafeSlow = function(size) {
                return allocUnsafe(null, size);
              };
              function fromString(that, string, encoding) {
                if (typeof encoding !== "string" || encoding === "") {
                  encoding = "utf8";
                }
                if (!Buffer2.isEncoding(encoding)) {
                  throw new TypeError('"encoding" must be a valid string encoding');
                }
                var length = byteLength(string, encoding) | 0;
                that = createBuffer(that, length);
                var actual = that.write(string, encoding);
                if (actual !== length) {
                  that = that.slice(0, actual);
                }
                return that;
              }
              function fromArrayLike(that, array) {
                var length = array.length < 0 ? 0 : checked(array.length) | 0;
                that = createBuffer(that, length);
                for (var i = 0; i < length; i += 1) {
                  that[i] = array[i] & 255;
                }
                return that;
              }
              function fromArrayBuffer(that, array, byteOffset, length) {
                array.byteLength;
                if (byteOffset < 0 || array.byteLength < byteOffset) {
                  throw new RangeError("'offset' is out of bounds");
                }
                if (array.byteLength < byteOffset + (length || 0)) {
                  throw new RangeError("'length' is out of bounds");
                }
                if (byteOffset === void 0 && length === void 0) {
                  array = new Uint8Array(array);
                } else if (length === void 0) {
                  array = new Uint8Array(array, byteOffset);
                } else {
                  array = new Uint8Array(array, byteOffset, length);
                }
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  that = array;
                  that.__proto__ = Buffer2.prototype;
                } else {
                  that = fromArrayLike(that, array);
                }
                return that;
              }
              function fromObject(that, obj) {
                if (Buffer2.isBuffer(obj)) {
                  var len = checked(obj.length) | 0;
                  that = createBuffer(that, len);
                  if (that.length === 0) {
                    return that;
                  }
                  obj.copy(that, 0, 0, len);
                  return that;
                }
                if (obj) {
                  if (typeof ArrayBuffer !== "undefined" && obj.buffer instanceof ArrayBuffer || "length" in obj) {
                    if (typeof obj.length !== "number" || isnan(obj.length)) {
                      return createBuffer(that, 0);
                    }
                    return fromArrayLike(that, obj);
                  }
                  if (obj.type === "Buffer" && isArray(obj.data)) {
                    return fromArrayLike(that, obj.data);
                  }
                }
                throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.");
              }
              function checked(length) {
                if (length >= kMaxLength()) {
                  throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + kMaxLength().toString(16) + " bytes");
                }
                return length | 0;
              }
              function SlowBuffer(length) {
                if (+length != length) {
                  length = 0;
                }
                return Buffer2.alloc(+length);
              }
              Buffer2.isBuffer = function isBuffer(b) {
                return !!(b != null && b._isBuffer);
              };
              Buffer2.compare = function compare(a, b) {
                if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
                  throw new TypeError("Arguments must be Buffers");
                }
                if (a === b)
                  return 0;
                var x = a.length;
                var y = b.length;
                for (var i = 0, len = Math.min(x, y); i < len; ++i) {
                  if (a[i] !== b[i]) {
                    x = a[i];
                    y = b[i];
                    break;
                  }
                }
                if (x < y)
                  return -1;
                if (y < x)
                  return 1;
                return 0;
              };
              Buffer2.isEncoding = function isEncoding(encoding) {
                switch (String(encoding).toLowerCase()) {
                  case "hex":
                  case "utf8":
                  case "utf-8":
                  case "ascii":
                  case "latin1":
                  case "binary":
                  case "base64":
                  case "ucs2":
                  case "ucs-2":
                  case "utf16le":
                  case "utf-16le":
                    return true;
                  default:
                    return false;
                }
              };
              Buffer2.concat = function concat(list, length) {
                if (!isArray(list)) {
                  throw new TypeError('"list" argument must be an Array of Buffers');
                }
                if (list.length === 0) {
                  return Buffer2.alloc(0);
                }
                var i;
                if (length === void 0) {
                  length = 0;
                  for (i = 0; i < list.length; ++i) {
                    length += list[i].length;
                  }
                }
                var buffer = Buffer2.allocUnsafe(length);
                var pos = 0;
                for (i = 0; i < list.length; ++i) {
                  var buf = list[i];
                  if (!Buffer2.isBuffer(buf)) {
                    throw new TypeError('"list" argument must be an Array of Buffers');
                  }
                  buf.copy(buffer, pos);
                  pos += buf.length;
                }
                return buffer;
              };
              function byteLength(string, encoding) {
                if (Buffer2.isBuffer(string)) {
                  return string.length;
                }
                if (typeof ArrayBuffer !== "undefined" && typeof ArrayBuffer.isView === "function" && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
                  return string.byteLength;
                }
                if (typeof string !== "string") {
                  string = "" + string;
                }
                var len = string.length;
                if (len === 0)
                  return 0;
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "ascii":
                    case "latin1":
                    case "binary":
                      return len;
                    case "utf8":
                    case "utf-8":
                    case void 0:
                      return utf8ToBytes(string).length;
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return len * 2;
                    case "hex":
                      return len >>> 1;
                    case "base64":
                      return base64ToBytes(string).length;
                    default:
                      if (loweredCase)
                        return utf8ToBytes(string).length;
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer2.byteLength = byteLength;
              function slowToString(encoding, start, end) {
                var loweredCase = false;
                if (start === void 0 || start < 0) {
                  start = 0;
                }
                if (start > this.length) {
                  return "";
                }
                if (end === void 0 || end > this.length) {
                  end = this.length;
                }
                if (end <= 0) {
                  return "";
                }
                end >>>= 0;
                start >>>= 0;
                if (end <= start) {
                  return "";
                }
                if (!encoding)
                  encoding = "utf8";
                while (true) {
                  switch (encoding) {
                    case "hex":
                      return hexSlice(this, start, end);
                    case "utf8":
                    case "utf-8":
                      return utf8Slice(this, start, end);
                    case "ascii":
                      return asciiSlice(this, start, end);
                    case "latin1":
                    case "binary":
                      return latin1Slice(this, start, end);
                    case "base64":
                      return base64Slice(this, start, end);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return utf16leSlice(this, start, end);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = (encoding + "").toLowerCase();
                      loweredCase = true;
                  }
                }
              }
              Buffer2.prototype._isBuffer = true;
              function swap(b, n, m) {
                var i = b[n];
                b[n] = b[m];
                b[m] = i;
              }
              Buffer2.prototype.swap16 = function swap16() {
                var len = this.length;
                if (len % 2 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 16-bits");
                }
                for (var i = 0; i < len; i += 2) {
                  swap(this, i, i + 1);
                }
                return this;
              };
              Buffer2.prototype.swap32 = function swap32() {
                var len = this.length;
                if (len % 4 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 32-bits");
                }
                for (var i = 0; i < len; i += 4) {
                  swap(this, i, i + 3);
                  swap(this, i + 1, i + 2);
                }
                return this;
              };
              Buffer2.prototype.swap64 = function swap64() {
                var len = this.length;
                if (len % 8 !== 0) {
                  throw new RangeError("Buffer size must be a multiple of 64-bits");
                }
                for (var i = 0; i < len; i += 8) {
                  swap(this, i, i + 7);
                  swap(this, i + 1, i + 6);
                  swap(this, i + 2, i + 5);
                  swap(this, i + 3, i + 4);
                }
                return this;
              };
              Buffer2.prototype.toString = function toString() {
                var length = this.length | 0;
                if (length === 0)
                  return "";
                if (arguments.length === 0)
                  return utf8Slice(this, 0, length);
                return slowToString.apply(this, arguments);
              };
              Buffer2.prototype.equals = function equals(b) {
                if (!Buffer2.isBuffer(b))
                  throw new TypeError("Argument must be a Buffer");
                if (this === b)
                  return true;
                return Buffer2.compare(this, b) === 0;
              };
              Buffer2.prototype.inspect = function inspect() {
                var str = "";
                var max = exports2.INSPECT_MAX_BYTES;
                if (this.length > 0) {
                  str = this.toString("hex", 0, max).match(/.{2}/g).join(" ");
                  if (this.length > max)
                    str += " ... ";
                }
                return "<Buffer " + str + ">";
              };
              Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
                if (!Buffer2.isBuffer(target)) {
                  throw new TypeError("Argument must be a Buffer");
                }
                if (start === void 0) {
                  start = 0;
                }
                if (end === void 0) {
                  end = target ? target.length : 0;
                }
                if (thisStart === void 0) {
                  thisStart = 0;
                }
                if (thisEnd === void 0) {
                  thisEnd = this.length;
                }
                if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
                  throw new RangeError("out of range index");
                }
                if (thisStart >= thisEnd && start >= end) {
                  return 0;
                }
                if (thisStart >= thisEnd) {
                  return -1;
                }
                if (start >= end) {
                  return 1;
                }
                start >>>= 0;
                end >>>= 0;
                thisStart >>>= 0;
                thisEnd >>>= 0;
                if (this === target)
                  return 0;
                var x = thisEnd - thisStart;
                var y = end - start;
                var len = Math.min(x, y);
                var thisCopy = this.slice(thisStart, thisEnd);
                var targetCopy = target.slice(start, end);
                for (var i = 0; i < len; ++i) {
                  if (thisCopy[i] !== targetCopy[i]) {
                    x = thisCopy[i];
                    y = targetCopy[i];
                    break;
                  }
                }
                if (x < y)
                  return -1;
                if (y < x)
                  return 1;
                return 0;
              };
              function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
                if (buffer.length === 0)
                  return -1;
                if (typeof byteOffset === "string") {
                  encoding = byteOffset;
                  byteOffset = 0;
                } else if (byteOffset > 2147483647) {
                  byteOffset = 2147483647;
                } else if (byteOffset < -2147483648) {
                  byteOffset = -2147483648;
                }
                byteOffset = +byteOffset;
                if (isNaN(byteOffset)) {
                  byteOffset = dir ? 0 : buffer.length - 1;
                }
                if (byteOffset < 0)
                  byteOffset = buffer.length + byteOffset;
                if (byteOffset >= buffer.length) {
                  if (dir)
                    return -1;
                  else
                    byteOffset = buffer.length - 1;
                } else if (byteOffset < 0) {
                  if (dir)
                    byteOffset = 0;
                  else
                    return -1;
                }
                if (typeof val === "string") {
                  val = Buffer2.from(val, encoding);
                }
                if (Buffer2.isBuffer(val)) {
                  if (val.length === 0) {
                    return -1;
                  }
                  return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
                } else if (typeof val === "number") {
                  val = val & 255;
                  if (Buffer2.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === "function") {
                    if (dir) {
                      return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
                    } else {
                      return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
                    }
                  }
                  return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
                }
                throw new TypeError("val must be string, number or Buffer");
              }
              function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
                var indexSize = 1;
                var arrLength = arr.length;
                var valLength = val.length;
                if (encoding !== void 0) {
                  encoding = String(encoding).toLowerCase();
                  if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
                    if (arr.length < 2 || val.length < 2) {
                      return -1;
                    }
                    indexSize = 2;
                    arrLength /= 2;
                    valLength /= 2;
                    byteOffset /= 2;
                  }
                }
                function read(buf, i2) {
                  if (indexSize === 1) {
                    return buf[i2];
                  } else {
                    return buf.readUInt16BE(i2 * indexSize);
                  }
                }
                var i;
                if (dir) {
                  var foundIndex = -1;
                  for (i = byteOffset; i < arrLength; i++) {
                    if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                      if (foundIndex === -1)
                        foundIndex = i;
                      if (i - foundIndex + 1 === valLength)
                        return foundIndex * indexSize;
                    } else {
                      if (foundIndex !== -1)
                        i -= i - foundIndex;
                      foundIndex = -1;
                    }
                  }
                } else {
                  if (byteOffset + valLength > arrLength)
                    byteOffset = arrLength - valLength;
                  for (i = byteOffset; i >= 0; i--) {
                    var found = true;
                    for (var j = 0; j < valLength; j++) {
                      if (read(arr, i + j) !== read(val, j)) {
                        found = false;
                        break;
                      }
                    }
                    if (found)
                      return i;
                  }
                }
                return -1;
              }
              Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
                return this.indexOf(val, byteOffset, encoding) !== -1;
              };
              Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
              };
              Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
                return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
              };
              function hexWrite(buf, string, offset, length) {
                offset = Number(offset) || 0;
                var remaining = buf.length - offset;
                if (!length) {
                  length = remaining;
                } else {
                  length = Number(length);
                  if (length > remaining) {
                    length = remaining;
                  }
                }
                var strLen = string.length;
                if (strLen % 2 !== 0)
                  throw new TypeError("Invalid hex string");
                if (length > strLen / 2) {
                  length = strLen / 2;
                }
                for (var i = 0; i < length; ++i) {
                  var parsed = parseInt(string.substr(i * 2, 2), 16);
                  if (isNaN(parsed))
                    return i;
                  buf[offset + i] = parsed;
                }
                return i;
              }
              function utf8Write(buf, string, offset, length) {
                return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
              }
              function asciiWrite(buf, string, offset, length) {
                return blitBuffer(asciiToBytes(string), buf, offset, length);
              }
              function latin1Write(buf, string, offset, length) {
                return asciiWrite(buf, string, offset, length);
              }
              function base64Write(buf, string, offset, length) {
                return blitBuffer(base64ToBytes(string), buf, offset, length);
              }
              function ucs2Write(buf, string, offset, length) {
                return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
              }
              Buffer2.prototype.write = function write(string, offset, length, encoding) {
                if (offset === void 0) {
                  encoding = "utf8";
                  length = this.length;
                  offset = 0;
                } else if (length === void 0 && typeof offset === "string") {
                  encoding = offset;
                  length = this.length;
                  offset = 0;
                } else if (isFinite(offset)) {
                  offset = offset | 0;
                  if (isFinite(length)) {
                    length = length | 0;
                    if (encoding === void 0)
                      encoding = "utf8";
                  } else {
                    encoding = length;
                    length = void 0;
                  }
                } else {
                  throw new Error(
                    "Buffer.write(string, encoding, offset[, length]) is no longer supported"
                  );
                }
                var remaining = this.length - offset;
                if (length === void 0 || length > remaining)
                  length = remaining;
                if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
                  throw new RangeError("Attempt to write outside buffer bounds");
                }
                if (!encoding)
                  encoding = "utf8";
                var loweredCase = false;
                for (; ; ) {
                  switch (encoding) {
                    case "hex":
                      return hexWrite(this, string, offset, length);
                    case "utf8":
                    case "utf-8":
                      return utf8Write(this, string, offset, length);
                    case "ascii":
                      return asciiWrite(this, string, offset, length);
                    case "latin1":
                    case "binary":
                      return latin1Write(this, string, offset, length);
                    case "base64":
                      return base64Write(this, string, offset, length);
                    case "ucs2":
                    case "ucs-2":
                    case "utf16le":
                    case "utf-16le":
                      return ucs2Write(this, string, offset, length);
                    default:
                      if (loweredCase)
                        throw new TypeError("Unknown encoding: " + encoding);
                      encoding = ("" + encoding).toLowerCase();
                      loweredCase = true;
                  }
                }
              };
              Buffer2.prototype.toJSON = function toJSON() {
                return {
                  type: "Buffer",
                  data: Array.prototype.slice.call(this._arr || this, 0)
                };
              };
              function base64Slice(buf, start, end) {
                if (start === 0 && end === buf.length) {
                  return base64.fromByteArray(buf);
                } else {
                  return base64.fromByteArray(buf.slice(start, end));
                }
              }
              function utf8Slice(buf, start, end) {
                end = Math.min(buf.length, end);
                var res = [];
                var i = start;
                while (i < end) {
                  var firstByte = buf[i];
                  var codePoint = null;
                  var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
                  if (i + bytesPerSequence <= end) {
                    var secondByte, thirdByte, fourthByte, tempCodePoint;
                    switch (bytesPerSequence) {
                      case 1:
                        if (firstByte < 128) {
                          codePoint = firstByte;
                        }
                        break;
                      case 2:
                        secondByte = buf[i + 1];
                        if ((secondByte & 192) === 128) {
                          tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
                          if (tempCodePoint > 127) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 3:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
                          if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                            codePoint = tempCodePoint;
                          }
                        }
                        break;
                      case 4:
                        secondByte = buf[i + 1];
                        thirdByte = buf[i + 2];
                        fourthByte = buf[i + 3];
                        if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
                          tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
                          if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                            codePoint = tempCodePoint;
                          }
                        }
                    }
                  }
                  if (codePoint === null) {
                    codePoint = 65533;
                    bytesPerSequence = 1;
                  } else if (codePoint > 65535) {
                    codePoint -= 65536;
                    res.push(codePoint >>> 10 & 1023 | 55296);
                    codePoint = 56320 | codePoint & 1023;
                  }
                  res.push(codePoint);
                  i += bytesPerSequence;
                }
                return decodeCodePointsArray(res);
              }
              var MAX_ARGUMENTS_LENGTH = 4096;
              function decodeCodePointsArray(codePoints) {
                var len = codePoints.length;
                if (len <= MAX_ARGUMENTS_LENGTH) {
                  return String.fromCharCode.apply(String, codePoints);
                }
                var res = "";
                var i = 0;
                while (i < len) {
                  res += String.fromCharCode.apply(
                    String,
                    codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
                  );
                }
                return res;
              }
              function asciiSlice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i] & 127);
                }
                return ret;
              }
              function latin1Slice(buf, start, end) {
                var ret = "";
                end = Math.min(buf.length, end);
                for (var i = start; i < end; ++i) {
                  ret += String.fromCharCode(buf[i]);
                }
                return ret;
              }
              function hexSlice(buf, start, end) {
                var len = buf.length;
                if (!start || start < 0)
                  start = 0;
                if (!end || end < 0 || end > len)
                  end = len;
                var out = "";
                for (var i = start; i < end; ++i) {
                  out += toHex(buf[i]);
                }
                return out;
              }
              function utf16leSlice(buf, start, end) {
                var bytes = buf.slice(start, end);
                var res = "";
                for (var i = 0; i < bytes.length; i += 2) {
                  res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
                }
                return res;
              }
              Buffer2.prototype.slice = function slice(start, end) {
                var len = this.length;
                start = ~~start;
                end = end === void 0 ? len : ~~end;
                if (start < 0) {
                  start += len;
                  if (start < 0)
                    start = 0;
                } else if (start > len) {
                  start = len;
                }
                if (end < 0) {
                  end += len;
                  if (end < 0)
                    end = 0;
                } else if (end > len) {
                  end = len;
                }
                if (end < start)
                  end = start;
                var newBuf;
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  newBuf = this.subarray(start, end);
                  newBuf.__proto__ = Buffer2.prototype;
                } else {
                  var sliceLen = end - start;
                  newBuf = new Buffer2(sliceLen, void 0);
                  for (var i = 0; i < sliceLen; ++i) {
                    newBuf[i] = this[i + start];
                  }
                }
                return newBuf;
              };
              function checkOffset(offset, ext, length) {
                if (offset % 1 !== 0 || offset < 0)
                  throw new RangeError("offset is not uint");
                if (offset + ext > length)
                  throw new RangeError("Trying to access beyond buffer length");
              }
              Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                return val;
              };
              Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  checkOffset(offset, byteLength2, this.length);
                }
                var val = this[offset + --byteLength2];
                var mul = 1;
                while (byteLength2 > 0 && (mul *= 256)) {
                  val += this[offset + --byteLength2] * mul;
                }
                return val;
              };
              Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 1, this.length);
                return this[offset];
              };
              Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                return this[offset] | this[offset + 1] << 8;
              };
              Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                return this[offset] << 8 | this[offset + 1];
              };
              Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
              };
              Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
              };
              Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var val = this[offset];
                var mul = 1;
                var i = 0;
                while (++i < byteLength2 && (mul *= 256)) {
                  val += this[offset + i] * mul;
                }
                mul *= 128;
                if (val >= mul)
                  val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert)
                  checkOffset(offset, byteLength2, this.length);
                var i = byteLength2;
                var mul = 1;
                var val = this[offset + --i];
                while (i > 0 && (mul *= 256)) {
                  val += this[offset + --i] * mul;
                }
                mul *= 128;
                if (val >= mul)
                  val -= Math.pow(2, 8 * byteLength2);
                return val;
              };
              Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 1, this.length);
                if (!(this[offset] & 128))
                  return this[offset];
                return (255 - this[offset] + 1) * -1;
              };
              Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                var val = this[offset] | this[offset + 1] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 2, this.length);
                var val = this[offset + 1] | this[offset] << 8;
                return val & 32768 ? val | 4294901760 : val;
              };
              Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
              };
              Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
              };
              Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, true, 23, 4);
              };
              Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 4, this.length);
                return ieee754.read(this, offset, false, 23, 4);
              };
              Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, true, 52, 8);
              };
              Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
                if (!noAssert)
                  checkOffset(offset, 8, this.length);
                return ieee754.read(this, offset, false, 52, 8);
              };
              function checkInt(buf, value, offset, ext, max, min) {
                if (!Buffer2.isBuffer(buf))
                  throw new TypeError('"buffer" argument must be a Buffer instance');
                if (value > max || value < min)
                  throw new RangeError('"value" argument is out of bounds');
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
              }
              Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var mul = 1;
                var i = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                byteLength2 = byteLength2 | 0;
                if (!noAssert) {
                  var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
                  checkInt(this, value, offset, byteLength2, maxBytes, 0);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  this[offset + i] = value / mul & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 1, 255, 0);
                if (!Buffer2.TYPED_ARRAY_SUPPORT)
                  value = Math.floor(value);
                this[offset] = value & 255;
                return offset + 1;
              };
              function objectWriteUInt16(buf, value, offset, littleEndian) {
                if (value < 0)
                  value = 65535 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
                  buf[offset + i] = (value & 255 << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
                }
              }
              Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 65535, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              function objectWriteUInt32(buf, value, offset, littleEndian) {
                if (value < 0)
                  value = 4294967295 + value + 1;
                for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
                  buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 255;
                }
              }
              Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset + 3] = value >>> 24;
                  this[offset + 2] = value >>> 16;
                  this[offset + 1] = value >>> 8;
                  this[offset] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 4294967295, 0);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = 0;
                var mul = 1;
                var sub = 0;
                this[offset] = value & 255;
                while (++i < byteLength2 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert) {
                  var limit = Math.pow(2, 8 * byteLength2 - 1);
                  checkInt(this, value, offset, byteLength2, limit - 1, -limit);
                }
                var i = byteLength2 - 1;
                var mul = 1;
                var sub = 0;
                this[offset + i] = value & 255;
                while (--i >= 0 && (mul *= 256)) {
                  if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
                    sub = 1;
                  }
                  this[offset + i] = (value / mul >> 0) - sub & 255;
                }
                return offset + byteLength2;
              };
              Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 1, 127, -128);
                if (!Buffer2.TYPED_ARRAY_SUPPORT)
                  value = Math.floor(value);
                if (value < 0)
                  value = 255 + value + 1;
                this[offset] = value & 255;
                return offset + 1;
              };
              Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                } else {
                  objectWriteUInt16(this, value, offset, true);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 2, 32767, -32768);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 8;
                  this[offset + 1] = value & 255;
                } else {
                  objectWriteUInt16(this, value, offset, false);
                }
                return offset + 2;
              };
              Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value & 255;
                  this[offset + 1] = value >>> 8;
                  this[offset + 2] = value >>> 16;
                  this[offset + 3] = value >>> 24;
                } else {
                  objectWriteUInt32(this, value, offset, true);
                }
                return offset + 4;
              };
              Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
                value = +value;
                offset = offset | 0;
                if (!noAssert)
                  checkInt(this, value, offset, 4, 2147483647, -2147483648);
                if (value < 0)
                  value = 4294967295 + value + 1;
                if (Buffer2.TYPED_ARRAY_SUPPORT) {
                  this[offset] = value >>> 24;
                  this[offset + 1] = value >>> 16;
                  this[offset + 2] = value >>> 8;
                  this[offset + 3] = value & 255;
                } else {
                  objectWriteUInt32(this, value, offset, false);
                }
                return offset + 4;
              };
              function checkIEEE754(buf, value, offset, ext, max, min) {
                if (offset + ext > buf.length)
                  throw new RangeError("Index out of range");
                if (offset < 0)
                  throw new RangeError("Index out of range");
              }
              function writeFloat(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
                }
                ieee754.write(buf, value, offset, littleEndian, 23, 4);
                return offset + 4;
              }
              Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
                return writeFloat(this, value, offset, true, noAssert);
              };
              Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
                return writeFloat(this, value, offset, false, noAssert);
              };
              function writeDouble(buf, value, offset, littleEndian, noAssert) {
                if (!noAssert) {
                  checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
                }
                ieee754.write(buf, value, offset, littleEndian, 52, 8);
                return offset + 8;
              }
              Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
                return writeDouble(this, value, offset, true, noAssert);
              };
              Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
                return writeDouble(this, value, offset, false, noAssert);
              };
              Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
                if (!start)
                  start = 0;
                if (!end && end !== 0)
                  end = this.length;
                if (targetStart >= target.length)
                  targetStart = target.length;
                if (!targetStart)
                  targetStart = 0;
                if (end > 0 && end < start)
                  end = start;
                if (end === start)
                  return 0;
                if (target.length === 0 || this.length === 0)
                  return 0;
                if (targetStart < 0) {
                  throw new RangeError("targetStart out of bounds");
                }
                if (start < 0 || start >= this.length)
                  throw new RangeError("sourceStart out of bounds");
                if (end < 0)
                  throw new RangeError("sourceEnd out of bounds");
                if (end > this.length)
                  end = this.length;
                if (target.length - targetStart < end - start) {
                  end = target.length - targetStart + start;
                }
                var len = end - start;
                var i;
                if (this === target && start < targetStart && targetStart < end) {
                  for (i = len - 1; i >= 0; --i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else if (len < 1e3 || !Buffer2.TYPED_ARRAY_SUPPORT) {
                  for (i = 0; i < len; ++i) {
                    target[i + targetStart] = this[i + start];
                  }
                } else {
                  Uint8Array.prototype.set.call(
                    target,
                    this.subarray(start, start + len),
                    targetStart
                  );
                }
                return len;
              };
              Buffer2.prototype.fill = function fill(val, start, end, encoding) {
                if (typeof val === "string") {
                  if (typeof start === "string") {
                    encoding = start;
                    start = 0;
                    end = this.length;
                  } else if (typeof end === "string") {
                    encoding = end;
                    end = this.length;
                  }
                  if (val.length === 1) {
                    var code = val.charCodeAt(0);
                    if (code < 256) {
                      val = code;
                    }
                  }
                  if (encoding !== void 0 && typeof encoding !== "string") {
                    throw new TypeError("encoding must be a string");
                  }
                  if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
                    throw new TypeError("Unknown encoding: " + encoding);
                  }
                } else if (typeof val === "number") {
                  val = val & 255;
                }
                if (start < 0 || this.length < start || this.length < end) {
                  throw new RangeError("Out of range index");
                }
                if (end <= start) {
                  return this;
                }
                start = start >>> 0;
                end = end === void 0 ? this.length : end >>> 0;
                if (!val)
                  val = 0;
                var i;
                if (typeof val === "number") {
                  for (i = start; i < end; ++i) {
                    this[i] = val;
                  }
                } else {
                  var bytes = Buffer2.isBuffer(val) ? val : utf8ToBytes(new Buffer2(val, encoding).toString());
                  var len = bytes.length;
                  for (i = 0; i < end - start; ++i) {
                    this[i + start] = bytes[i % len];
                  }
                }
                return this;
              };
              var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
              function base64clean(str) {
                str = stringtrim(str).replace(INVALID_BASE64_RE, "");
                if (str.length < 2)
                  return "";
                while (str.length % 4 !== 0) {
                  str = str + "=";
                }
                return str;
              }
              function stringtrim(str) {
                if (str.trim)
                  return str.trim();
                return str.replace(/^\s+|\s+$/g, "");
              }
              function toHex(n) {
                if (n < 16)
                  return "0" + n.toString(16);
                return n.toString(16);
              }
              function utf8ToBytes(string, units) {
                units = units || Infinity;
                var codePoint;
                var length = string.length;
                var leadSurrogate = null;
                var bytes = [];
                for (var i = 0; i < length; ++i) {
                  codePoint = string.charCodeAt(i);
                  if (codePoint > 55295 && codePoint < 57344) {
                    if (!leadSurrogate) {
                      if (codePoint > 56319) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        continue;
                      } else if (i + 1 === length) {
                        if ((units -= 3) > -1)
                          bytes.push(239, 191, 189);
                        continue;
                      }
                      leadSurrogate = codePoint;
                      continue;
                    }
                    if (codePoint < 56320) {
                      if ((units -= 3) > -1)
                        bytes.push(239, 191, 189);
                      leadSurrogate = codePoint;
                      continue;
                    }
                    codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
                  } else if (leadSurrogate) {
                    if ((units -= 3) > -1)
                      bytes.push(239, 191, 189);
                  }
                  leadSurrogate = null;
                  if (codePoint < 128) {
                    if ((units -= 1) < 0)
                      break;
                    bytes.push(codePoint);
                  } else if (codePoint < 2048) {
                    if ((units -= 2) < 0)
                      break;
                    bytes.push(
                      codePoint >> 6 | 192,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 65536) {
                    if ((units -= 3) < 0)
                      break;
                    bytes.push(
                      codePoint >> 12 | 224,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else if (codePoint < 1114112) {
                    if ((units -= 4) < 0)
                      break;
                    bytes.push(
                      codePoint >> 18 | 240,
                      codePoint >> 12 & 63 | 128,
                      codePoint >> 6 & 63 | 128,
                      codePoint & 63 | 128
                    );
                  } else {
                    throw new Error("Invalid code point");
                  }
                }
                return bytes;
              }
              function asciiToBytes(str) {
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  byteArray.push(str.charCodeAt(i) & 255);
                }
                return byteArray;
              }
              function utf16leToBytes(str, units) {
                var c, hi, lo;
                var byteArray = [];
                for (var i = 0; i < str.length; ++i) {
                  if ((units -= 2) < 0)
                    break;
                  c = str.charCodeAt(i);
                  hi = c >> 8;
                  lo = c % 256;
                  byteArray.push(lo);
                  byteArray.push(hi);
                }
                return byteArray;
              }
              function base64ToBytes(str) {
                return base64.toByteArray(base64clean(str));
              }
              function blitBuffer(src, dst, offset, length) {
                for (var i = 0; i < length; ++i) {
                  if (i + offset >= dst.length || i >= src.length)
                    break;
                  dst[i + offset] = src[i];
                }
                return i;
              }
              function isnan(val) {
                return val !== val;
              }
            }).call(this);
          }).call(this, typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {}, require2("buffer").Buffer);
        }, { "base64-js": 81, "buffer": 86, "ieee754": 88, "isarray": 89 }], 87: [function(require2, module2, exports2) {
          function EventEmitter() {
            this._events = this._events || {};
            this._maxListeners = this._maxListeners || void 0;
          }
          module2.exports = EventEmitter;
          EventEmitter.EventEmitter = EventEmitter;
          EventEmitter.prototype._events = void 0;
          EventEmitter.prototype._maxListeners = void 0;
          EventEmitter.defaultMaxListeners = 10;
          EventEmitter.prototype.setMaxListeners = function(n) {
            if (!isNumber(n) || n < 0 || isNaN(n))
              throw TypeError("n must be a positive number");
            this._maxListeners = n;
            return this;
          };
          EventEmitter.prototype.emit = function(type) {
            var er, handler, len, args, i, listeners;
            if (!this._events)
              this._events = {};
            if (type === "error") {
              if (!this._events.error || isObject(this._events.error) && !this._events.error.length) {
                er = arguments[1];
                if (er instanceof Error) {
                  throw er;
                } else {
                  var err = new Error('Uncaught, unspecified "error" event. (' + er + ")");
                  err.context = er;
                  throw err;
                }
              }
            }
            handler = this._events[type];
            if (isUndefined(handler))
              return false;
            if (isFunction(handler)) {
              switch (arguments.length) {
                case 1:
                  handler.call(this);
                  break;
                case 2:
                  handler.call(this, arguments[1]);
                  break;
                case 3:
                  handler.call(this, arguments[1], arguments[2]);
                  break;
                default:
                  args = Array.prototype.slice.call(arguments, 1);
                  handler.apply(this, args);
              }
            } else if (isObject(handler)) {
              args = Array.prototype.slice.call(arguments, 1);
              listeners = handler.slice();
              len = listeners.length;
              for (i = 0; i < len; i++)
                listeners[i].apply(this, args);
            }
            return true;
          };
          EventEmitter.prototype.addListener = function(type, listener) {
            var m;
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            if (!this._events)
              this._events = {};
            if (this._events.newListener)
              this.emit(
                "newListener",
                type,
                isFunction(listener.listener) ? listener.listener : listener
              );
            if (!this._events[type])
              this._events[type] = listener;
            else if (isObject(this._events[type]))
              this._events[type].push(listener);
            else
              this._events[type] = [this._events[type], listener];
            if (isObject(this._events[type]) && !this._events[type].warned) {
              if (!isUndefined(this._maxListeners)) {
                m = this._maxListeners;
              } else {
                m = EventEmitter.defaultMaxListeners;
              }
              if (m && m > 0 && this._events[type].length > m) {
                this._events[type].warned = true;
                console.error(
                  "(node) warning: possible EventEmitter memory leak detected. %d listeners added. Use emitter.setMaxListeners() to increase limit.",
                  this._events[type].length
                );
                if (typeof console.trace === "function") {
                  console.trace();
                }
              }
            }
            return this;
          };
          EventEmitter.prototype.on = EventEmitter.prototype.addListener;
          EventEmitter.prototype.once = function(type, listener) {
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            var fired = false;
            function g() {
              this.removeListener(type, g);
              if (!fired) {
                fired = true;
                listener.apply(this, arguments);
              }
            }
            g.listener = listener;
            this.on(type, g);
            return this;
          };
          EventEmitter.prototype.removeListener = function(type, listener) {
            var list, position, length, i;
            if (!isFunction(listener))
              throw TypeError("listener must be a function");
            if (!this._events || !this._events[type])
              return this;
            list = this._events[type];
            length = list.length;
            position = -1;
            if (list === listener || isFunction(list.listener) && list.listener === listener) {
              delete this._events[type];
              if (this._events.removeListener)
                this.emit("removeListener", type, listener);
            } else if (isObject(list)) {
              for (i = length; i-- > 0; ) {
                if (list[i] === listener || list[i].listener && list[i].listener === listener) {
                  position = i;
                  break;
                }
              }
              if (position < 0)
                return this;
              if (list.length === 1) {
                list.length = 0;
                delete this._events[type];
              } else {
                list.splice(position, 1);
              }
              if (this._events.removeListener)
                this.emit("removeListener", type, listener);
            }
            return this;
          };
          EventEmitter.prototype.removeAllListeners = function(type) {
            var key, listeners;
            if (!this._events)
              return this;
            if (!this._events.removeListener) {
              if (arguments.length === 0)
                this._events = {};
              else if (this._events[type])
                delete this._events[type];
              return this;
            }
            if (arguments.length === 0) {
              for (key in this._events) {
                if (key === "removeListener")
                  continue;
                this.removeAllListeners(key);
              }
              this.removeAllListeners("removeListener");
              this._events = {};
              return this;
            }
            listeners = this._events[type];
            if (isFunction(listeners)) {
              this.removeListener(type, listeners);
            } else if (listeners) {
              while (listeners.length)
                this.removeListener(type, listeners[listeners.length - 1]);
            }
            delete this._events[type];
            return this;
          };
          EventEmitter.prototype.listeners = function(type) {
            var ret;
            if (!this._events || !this._events[type])
              ret = [];
            else if (isFunction(this._events[type]))
              ret = [this._events[type]];
            else
              ret = this._events[type].slice();
            return ret;
          };
          EventEmitter.prototype.listenerCount = function(type) {
            if (this._events) {
              var evlistener = this._events[type];
              if (isFunction(evlistener))
                return 1;
              else if (evlistener)
                return evlistener.length;
            }
            return 0;
          };
          EventEmitter.listenerCount = function(emitter, type) {
            return emitter.listenerCount(type);
          };
          function isFunction(arg) {
            return typeof arg === "function";
          }
          function isNumber(arg) {
            return typeof arg === "number";
          }
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          function isUndefined(arg) {
            return arg === void 0;
          }
        }, {}], 88: [function(require2, module2, exports2) {
          exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
            var e, m;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var nBits = -7;
            var i = isLE ? nBytes - 1 : 0;
            var d = isLE ? -1 : 1;
            var s = buffer[offset + i];
            i += d;
            e = s & (1 << -nBits) - 1;
            s >>= -nBits;
            nBits += eLen;
            for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            m = e & (1 << -nBits) - 1;
            e >>= -nBits;
            nBits += mLen;
            for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
            }
            if (e === 0) {
              e = 1 - eBias;
            } else if (e === eMax) {
              return m ? NaN : (s ? -1 : 1) * Infinity;
            } else {
              m = m + Math.pow(2, mLen);
              e = e - eBias;
            }
            return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
          };
          exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
            var e, m, c;
            var eLen = nBytes * 8 - mLen - 1;
            var eMax = (1 << eLen) - 1;
            var eBias = eMax >> 1;
            var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
            var i = isLE ? 0 : nBytes - 1;
            var d = isLE ? 1 : -1;
            var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
            value = Math.abs(value);
            if (isNaN(value) || value === Infinity) {
              m = isNaN(value) ? 1 : 0;
              e = eMax;
            } else {
              e = Math.floor(Math.log(value) / Math.LN2);
              if (value * (c = Math.pow(2, -e)) < 1) {
                e--;
                c *= 2;
              }
              if (e + eBias >= 1) {
                value += rt / c;
              } else {
                value += rt * Math.pow(2, 1 - eBias);
              }
              if (value * c >= 2) {
                e++;
                c /= 2;
              }
              if (e + eBias >= eMax) {
                m = 0;
                e = eMax;
              } else if (e + eBias >= 1) {
                m = (value * c - 1) * Math.pow(2, mLen);
                e = e + eBias;
              } else {
                m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
                e = 0;
              }
            }
            for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
            }
            e = e << mLen | m;
            eLen += mLen;
            for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
            }
            buffer[offset + i - d] |= s * 128;
          };
        }, {}], 89: [function(require2, module2, exports2) {
          var toString = {}.toString;
          module2.exports = Array.isArray || function(arr) {
            return toString.call(arr) == "[object Array]";
          };
        }, {}], 90: [function(require2, module2, exports2) {
          (function(exports3) {
            "use strict";
            function isArray(obj) {
              if (obj !== null) {
                return Object.prototype.toString.call(obj) === "[object Array]";
              } else {
                return false;
              }
            }
            function isObject(obj) {
              if (obj !== null) {
                return Object.prototype.toString.call(obj) === "[object Object]";
              } else {
                return false;
              }
            }
            function strictDeepEqual(first, second) {
              if (first === second) {
                return true;
              }
              var firstType = Object.prototype.toString.call(first);
              if (firstType !== Object.prototype.toString.call(second)) {
                return false;
              }
              if (isArray(first) === true) {
                if (first.length !== second.length) {
                  return false;
                }
                for (var i = 0; i < first.length; i++) {
                  if (strictDeepEqual(first[i], second[i]) === false) {
                    return false;
                  }
                }
                return true;
              }
              if (isObject(first) === true) {
                var keysSeen = {};
                for (var key in first) {
                  if (hasOwnProperty.call(first, key)) {
                    if (strictDeepEqual(first[key], second[key]) === false) {
                      return false;
                    }
                    keysSeen[key] = true;
                  }
                }
                for (var key2 in second) {
                  if (hasOwnProperty.call(second, key2)) {
                    if (keysSeen[key2] !== true) {
                      return false;
                    }
                  }
                }
                return true;
              }
              return false;
            }
            function isFalse(obj) {
              if (obj === "" || obj === false || obj === null) {
                return true;
              } else if (isArray(obj) && obj.length === 0) {
                return true;
              } else if (isObject(obj)) {
                for (var key in obj) {
                  if (obj.hasOwnProperty(key)) {
                    return false;
                  }
                }
                return true;
              } else {
                return false;
              }
            }
            function objValues(obj) {
              var keys = Object.keys(obj);
              var values = [];
              for (var i = 0; i < keys.length; i++) {
                values.push(obj[keys[i]]);
              }
              return values;
            }
            function merge(a, b) {
              var merged = {};
              for (var key in a) {
                merged[key] = a[key];
              }
              for (var key2 in b) {
                merged[key2] = b[key2];
              }
              return merged;
            }
            var trimLeft;
            if (typeof String.prototype.trimLeft === "function") {
              trimLeft = function(str) {
                return str.trimLeft();
              };
            } else {
              trimLeft = function(str) {
                return str.match(/^\s*(.*)/)[1];
              };
            }
            var TYPE_NUMBER = 0;
            var TYPE_ANY = 1;
            var TYPE_STRING = 2;
            var TYPE_ARRAY = 3;
            var TYPE_OBJECT = 4;
            var TYPE_BOOLEAN = 5;
            var TYPE_EXPREF = 6;
            var TYPE_NULL = 7;
            var TYPE_ARRAY_NUMBER = 8;
            var TYPE_ARRAY_STRING = 9;
            var TYPE_NAME_TABLE = {
              0: "number",
              1: "any",
              2: "string",
              3: "array",
              4: "object",
              5: "boolean",
              6: "expression",
              7: "null",
              8: "Array<number>",
              9: "Array<string>"
            };
            var TOK_EOF = "EOF";
            var TOK_UNQUOTEDIDENTIFIER = "UnquotedIdentifier";
            var TOK_QUOTEDIDENTIFIER = "QuotedIdentifier";
            var TOK_RBRACKET = "Rbracket";
            var TOK_RPAREN = "Rparen";
            var TOK_COMMA = "Comma";
            var TOK_COLON = "Colon";
            var TOK_RBRACE = "Rbrace";
            var TOK_NUMBER = "Number";
            var TOK_CURRENT = "Current";
            var TOK_EXPREF = "Expref";
            var TOK_PIPE = "Pipe";
            var TOK_OR = "Or";
            var TOK_AND = "And";
            var TOK_EQ = "EQ";
            var TOK_GT = "GT";
            var TOK_LT = "LT";
            var TOK_GTE = "GTE";
            var TOK_LTE = "LTE";
            var TOK_NE = "NE";
            var TOK_FLATTEN = "Flatten";
            var TOK_STAR = "Star";
            var TOK_FILTER = "Filter";
            var TOK_DOT = "Dot";
            var TOK_NOT = "Not";
            var TOK_LBRACE = "Lbrace";
            var TOK_LBRACKET = "Lbracket";
            var TOK_LPAREN = "Lparen";
            var TOK_LITERAL = "Literal";
            var basicTokens = {
              ".": TOK_DOT,
              "*": TOK_STAR,
              ",": TOK_COMMA,
              ":": TOK_COLON,
              "{": TOK_LBRACE,
              "}": TOK_RBRACE,
              "]": TOK_RBRACKET,
              "(": TOK_LPAREN,
              ")": TOK_RPAREN,
              "@": TOK_CURRENT
            };
            var operatorStartToken = {
              "<": true,
              ">": true,
              "=": true,
              "!": true
            };
            var skipChars = {
              " ": true,
              "	": true,
              "\n": true
            };
            function isAlpha(ch) {
              return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch === "_";
            }
            function isNum(ch) {
              return ch >= "0" && ch <= "9" || ch === "-";
            }
            function isAlphaNum(ch) {
              return ch >= "a" && ch <= "z" || ch >= "A" && ch <= "Z" || ch >= "0" && ch <= "9" || ch === "_";
            }
            function Lexer() {
            }
            Lexer.prototype = {
              tokenize: function(stream) {
                var tokens = [];
                this._current = 0;
                var start;
                var identifier;
                var token;
                while (this._current < stream.length) {
                  if (isAlpha(stream[this._current])) {
                    start = this._current;
                    identifier = this._consumeUnquotedIdentifier(stream);
                    tokens.push({
                      type: TOK_UNQUOTEDIDENTIFIER,
                      value: identifier,
                      start
                    });
                  } else if (basicTokens[stream[this._current]] !== void 0) {
                    tokens.push({
                      type: basicTokens[stream[this._current]],
                      value: stream[this._current],
                      start: this._current
                    });
                    this._current++;
                  } else if (isNum(stream[this._current])) {
                    token = this._consumeNumber(stream);
                    tokens.push(token);
                  } else if (stream[this._current] === "[") {
                    token = this._consumeLBracket(stream);
                    tokens.push(token);
                  } else if (stream[this._current] === '"') {
                    start = this._current;
                    identifier = this._consumeQuotedIdentifier(stream);
                    tokens.push({
                      type: TOK_QUOTEDIDENTIFIER,
                      value: identifier,
                      start
                    });
                  } else if (stream[this._current] === "'") {
                    start = this._current;
                    identifier = this._consumeRawStringLiteral(stream);
                    tokens.push({
                      type: TOK_LITERAL,
                      value: identifier,
                      start
                    });
                  } else if (stream[this._current] === "`") {
                    start = this._current;
                    var literal = this._consumeLiteral(stream);
                    tokens.push({
                      type: TOK_LITERAL,
                      value: literal,
                      start
                    });
                  } else if (operatorStartToken[stream[this._current]] !== void 0) {
                    tokens.push(this._consumeOperator(stream));
                  } else if (skipChars[stream[this._current]] !== void 0) {
                    this._current++;
                  } else if (stream[this._current] === "&") {
                    start = this._current;
                    this._current++;
                    if (stream[this._current] === "&") {
                      this._current++;
                      tokens.push({ type: TOK_AND, value: "&&", start });
                    } else {
                      tokens.push({ type: TOK_EXPREF, value: "&", start });
                    }
                  } else if (stream[this._current] === "|") {
                    start = this._current;
                    this._current++;
                    if (stream[this._current] === "|") {
                      this._current++;
                      tokens.push({ type: TOK_OR, value: "||", start });
                    } else {
                      tokens.push({ type: TOK_PIPE, value: "|", start });
                    }
                  } else {
                    var error = new Error("Unknown character:" + stream[this._current]);
                    error.name = "LexerError";
                    throw error;
                  }
                }
                return tokens;
              },
              _consumeUnquotedIdentifier: function(stream) {
                var start = this._current;
                this._current++;
                while (this._current < stream.length && isAlphaNum(stream[this._current])) {
                  this._current++;
                }
                return stream.slice(start, this._current);
              },
              _consumeQuotedIdentifier: function(stream) {
                var start = this._current;
                this._current++;
                var maxLength = stream.length;
                while (stream[this._current] !== '"' && this._current < maxLength) {
                  var current = this._current;
                  if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === '"')) {
                    current += 2;
                  } else {
                    current++;
                  }
                  this._current = current;
                }
                this._current++;
                return JSON.parse(stream.slice(start, this._current));
              },
              _consumeRawStringLiteral: function(stream) {
                var start = this._current;
                this._current++;
                var maxLength = stream.length;
                while (stream[this._current] !== "'" && this._current < maxLength) {
                  var current = this._current;
                  if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "'")) {
                    current += 2;
                  } else {
                    current++;
                  }
                  this._current = current;
                }
                this._current++;
                var literal = stream.slice(start + 1, this._current - 1);
                return literal.replace("\\'", "'");
              },
              _consumeNumber: function(stream) {
                var start = this._current;
                this._current++;
                var maxLength = stream.length;
                while (isNum(stream[this._current]) && this._current < maxLength) {
                  this._current++;
                }
                var value = parseInt(stream.slice(start, this._current));
                return { type: TOK_NUMBER, value, start };
              },
              _consumeLBracket: function(stream) {
                var start = this._current;
                this._current++;
                if (stream[this._current] === "?") {
                  this._current++;
                  return { type: TOK_FILTER, value: "[?", start };
                } else if (stream[this._current] === "]") {
                  this._current++;
                  return { type: TOK_FLATTEN, value: "[]", start };
                } else {
                  return { type: TOK_LBRACKET, value: "[", start };
                }
              },
              _consumeOperator: function(stream) {
                var start = this._current;
                var startingChar = stream[start];
                this._current++;
                if (startingChar === "!") {
                  if (stream[this._current] === "=") {
                    this._current++;
                    return { type: TOK_NE, value: "!=", start };
                  } else {
                    return { type: TOK_NOT, value: "!", start };
                  }
                } else if (startingChar === "<") {
                  if (stream[this._current] === "=") {
                    this._current++;
                    return { type: TOK_LTE, value: "<=", start };
                  } else {
                    return { type: TOK_LT, value: "<", start };
                  }
                } else if (startingChar === ">") {
                  if (stream[this._current] === "=") {
                    this._current++;
                    return { type: TOK_GTE, value: ">=", start };
                  } else {
                    return { type: TOK_GT, value: ">", start };
                  }
                } else if (startingChar === "=") {
                  if (stream[this._current] === "=") {
                    this._current++;
                    return { type: TOK_EQ, value: "==", start };
                  }
                }
              },
              _consumeLiteral: function(stream) {
                this._current++;
                var start = this._current;
                var maxLength = stream.length;
                var literal;
                while (stream[this._current] !== "`" && this._current < maxLength) {
                  var current = this._current;
                  if (stream[current] === "\\" && (stream[current + 1] === "\\" || stream[current + 1] === "`")) {
                    current += 2;
                  } else {
                    current++;
                  }
                  this._current = current;
                }
                var literalString = trimLeft(stream.slice(start, this._current));
                literalString = literalString.replace("\\`", "`");
                if (this._looksLikeJSON(literalString)) {
                  literal = JSON.parse(literalString);
                } else {
                  literal = JSON.parse('"' + literalString + '"');
                }
                this._current++;
                return literal;
              },
              _looksLikeJSON: function(literalString) {
                var startingChars = '[{"';
                var jsonLiterals = ["true", "false", "null"];
                var numberLooking = "-0123456789";
                if (literalString === "") {
                  return false;
                } else if (startingChars.indexOf(literalString[0]) >= 0) {
                  return true;
                } else if (jsonLiterals.indexOf(literalString) >= 0) {
                  return true;
                } else if (numberLooking.indexOf(literalString[0]) >= 0) {
                  try {
                    JSON.parse(literalString);
                    return true;
                  } catch (ex) {
                    return false;
                  }
                } else {
                  return false;
                }
              }
            };
            var bindingPower = {};
            bindingPower[TOK_EOF] = 0;
            bindingPower[TOK_UNQUOTEDIDENTIFIER] = 0;
            bindingPower[TOK_QUOTEDIDENTIFIER] = 0;
            bindingPower[TOK_RBRACKET] = 0;
            bindingPower[TOK_RPAREN] = 0;
            bindingPower[TOK_COMMA] = 0;
            bindingPower[TOK_RBRACE] = 0;
            bindingPower[TOK_NUMBER] = 0;
            bindingPower[TOK_CURRENT] = 0;
            bindingPower[TOK_EXPREF] = 0;
            bindingPower[TOK_PIPE] = 1;
            bindingPower[TOK_OR] = 2;
            bindingPower[TOK_AND] = 3;
            bindingPower[TOK_EQ] = 5;
            bindingPower[TOK_GT] = 5;
            bindingPower[TOK_LT] = 5;
            bindingPower[TOK_GTE] = 5;
            bindingPower[TOK_LTE] = 5;
            bindingPower[TOK_NE] = 5;
            bindingPower[TOK_FLATTEN] = 9;
            bindingPower[TOK_STAR] = 20;
            bindingPower[TOK_FILTER] = 21;
            bindingPower[TOK_DOT] = 40;
            bindingPower[TOK_NOT] = 45;
            bindingPower[TOK_LBRACE] = 50;
            bindingPower[TOK_LBRACKET] = 55;
            bindingPower[TOK_LPAREN] = 60;
            function Parser() {
            }
            Parser.prototype = {
              parse: function(expression) {
                this._loadTokens(expression);
                this.index = 0;
                var ast = this.expression(0);
                if (this._lookahead(0) !== TOK_EOF) {
                  var t = this._lookaheadToken(0);
                  var error = new Error(
                    "Unexpected token type: " + t.type + ", value: " + t.value
                  );
                  error.name = "ParserError";
                  throw error;
                }
                return ast;
              },
              _loadTokens: function(expression) {
                var lexer = new Lexer();
                var tokens = lexer.tokenize(expression);
                tokens.push({ type: TOK_EOF, value: "", start: expression.length });
                this.tokens = tokens;
              },
              expression: function(rbp) {
                var leftToken = this._lookaheadToken(0);
                this._advance();
                var left = this.nud(leftToken);
                var currentToken = this._lookahead(0);
                while (rbp < bindingPower[currentToken]) {
                  this._advance();
                  left = this.led(currentToken, left);
                  currentToken = this._lookahead(0);
                }
                return left;
              },
              _lookahead: function(number) {
                return this.tokens[this.index + number].type;
              },
              _lookaheadToken: function(number) {
                return this.tokens[this.index + number];
              },
              _advance: function() {
                this.index++;
              },
              nud: function(token) {
                var left;
                var right;
                var expression;
                switch (token.type) {
                  case TOK_LITERAL:
                    return { type: "Literal", value: token.value };
                  case TOK_UNQUOTEDIDENTIFIER:
                    return { type: "Field", name: token.value };
                  case TOK_QUOTEDIDENTIFIER:
                    var node = { type: "Field", name: token.value };
                    if (this._lookahead(0) === TOK_LPAREN) {
                      throw new Error("Quoted identifier not allowed for function names.");
                    }
                    return node;
                  case TOK_NOT:
                    right = this.expression(bindingPower.Not);
                    return { type: "NotExpression", children: [right] };
                  case TOK_STAR:
                    left = { type: "Identity" };
                    right = null;
                    if (this._lookahead(0) === TOK_RBRACKET) {
                      right = { type: "Identity" };
                    } else {
                      right = this._parseProjectionRHS(bindingPower.Star);
                    }
                    return { type: "ValueProjection", children: [left, right] };
                  case TOK_FILTER:
                    return this.led(token.type, { type: "Identity" });
                  case TOK_LBRACE:
                    return this._parseMultiselectHash();
                  case TOK_FLATTEN:
                    left = { type: TOK_FLATTEN, children: [{ type: "Identity" }] };
                    right = this._parseProjectionRHS(bindingPower.Flatten);
                    return { type: "Projection", children: [left, right] };
                  case TOK_LBRACKET:
                    if (this._lookahead(0) === TOK_NUMBER || this._lookahead(0) === TOK_COLON) {
                      right = this._parseIndexExpression();
                      return this._projectIfSlice({ type: "Identity" }, right);
                    } else if (this._lookahead(0) === TOK_STAR && this._lookahead(1) === TOK_RBRACKET) {
                      this._advance();
                      this._advance();
                      right = this._parseProjectionRHS(bindingPower.Star);
                      return {
                        type: "Projection",
                        children: [{ type: "Identity" }, right]
                      };
                    }
                    return this._parseMultiselectList();
                  case TOK_CURRENT:
                    return { type: TOK_CURRENT };
                  case TOK_EXPREF:
                    expression = this.expression(bindingPower.Expref);
                    return { type: "ExpressionReference", children: [expression] };
                  case TOK_LPAREN:
                    var args = [];
                    while (this._lookahead(0) !== TOK_RPAREN) {
                      if (this._lookahead(0) === TOK_CURRENT) {
                        expression = { type: TOK_CURRENT };
                        this._advance();
                      } else {
                        expression = this.expression(0);
                      }
                      args.push(expression);
                    }
                    this._match(TOK_RPAREN);
                    return args[0];
                  default:
                    this._errorToken(token);
                }
              },
              led: function(tokenName, left) {
                var right;
                switch (tokenName) {
                  case TOK_DOT:
                    var rbp = bindingPower.Dot;
                    if (this._lookahead(0) !== TOK_STAR) {
                      right = this._parseDotRHS(rbp);
                      return { type: "Subexpression", children: [left, right] };
                    }
                    this._advance();
                    right = this._parseProjectionRHS(rbp);
                    return { type: "ValueProjection", children: [left, right] };
                  case TOK_PIPE:
                    right = this.expression(bindingPower.Pipe);
                    return { type: TOK_PIPE, children: [left, right] };
                  case TOK_OR:
                    right = this.expression(bindingPower.Or);
                    return { type: "OrExpression", children: [left, right] };
                  case TOK_AND:
                    right = this.expression(bindingPower.And);
                    return { type: "AndExpression", children: [left, right] };
                  case TOK_LPAREN:
                    var name = left.name;
                    var args = [];
                    var expression, node;
                    while (this._lookahead(0) !== TOK_RPAREN) {
                      if (this._lookahead(0) === TOK_CURRENT) {
                        expression = { type: TOK_CURRENT };
                        this._advance();
                      } else {
                        expression = this.expression(0);
                      }
                      if (this._lookahead(0) === TOK_COMMA) {
                        this._match(TOK_COMMA);
                      }
                      args.push(expression);
                    }
                    this._match(TOK_RPAREN);
                    node = { type: "Function", name, children: args };
                    return node;
                  case TOK_FILTER:
                    var condition = this.expression(0);
                    this._match(TOK_RBRACKET);
                    if (this._lookahead(0) === TOK_FLATTEN) {
                      right = { type: "Identity" };
                    } else {
                      right = this._parseProjectionRHS(bindingPower.Filter);
                    }
                    return { type: "FilterProjection", children: [left, right, condition] };
                  case TOK_FLATTEN:
                    var leftNode = { type: TOK_FLATTEN, children: [left] };
                    var rightNode = this._parseProjectionRHS(bindingPower.Flatten);
                    return { type: "Projection", children: [leftNode, rightNode] };
                  case TOK_EQ:
                  case TOK_NE:
                  case TOK_GT:
                  case TOK_GTE:
                  case TOK_LT:
                  case TOK_LTE:
                    return this._parseComparator(left, tokenName);
                  case TOK_LBRACKET:
                    var token = this._lookaheadToken(0);
                    if (token.type === TOK_NUMBER || token.type === TOK_COLON) {
                      right = this._parseIndexExpression();
                      return this._projectIfSlice(left, right);
                    }
                    this._match(TOK_STAR);
                    this._match(TOK_RBRACKET);
                    right = this._parseProjectionRHS(bindingPower.Star);
                    return { type: "Projection", children: [left, right] };
                  default:
                    this._errorToken(this._lookaheadToken(0));
                }
              },
              _match: function(tokenType) {
                if (this._lookahead(0) === tokenType) {
                  this._advance();
                } else {
                  var t = this._lookaheadToken(0);
                  var error = new Error("Expected " + tokenType + ", got: " + t.type);
                  error.name = "ParserError";
                  throw error;
                }
              },
              _errorToken: function(token) {
                var error = new Error("Invalid token (" + token.type + '): "' + token.value + '"');
                error.name = "ParserError";
                throw error;
              },
              _parseIndexExpression: function() {
                if (this._lookahead(0) === TOK_COLON || this._lookahead(1) === TOK_COLON) {
                  return this._parseSliceExpression();
                } else {
                  var node = {
                    type: "Index",
                    value: this._lookaheadToken(0).value
                  };
                  this._advance();
                  this._match(TOK_RBRACKET);
                  return node;
                }
              },
              _projectIfSlice: function(left, right) {
                var indexExpr = { type: "IndexExpression", children: [left, right] };
                if (right.type === "Slice") {
                  return {
                    type: "Projection",
                    children: [indexExpr, this._parseProjectionRHS(bindingPower.Star)]
                  };
                } else {
                  return indexExpr;
                }
              },
              _parseSliceExpression: function() {
                var parts = [null, null, null];
                var index = 0;
                var currentToken = this._lookahead(0);
                while (currentToken !== TOK_RBRACKET && index < 3) {
                  if (currentToken === TOK_COLON) {
                    index++;
                    this._advance();
                  } else if (currentToken === TOK_NUMBER) {
                    parts[index] = this._lookaheadToken(0).value;
                    this._advance();
                  } else {
                    var t = this._lookahead(0);
                    var error = new Error("Syntax error, unexpected token: " + t.value + "(" + t.type + ")");
                    error.name = "Parsererror";
                    throw error;
                  }
                  currentToken = this._lookahead(0);
                }
                this._match(TOK_RBRACKET);
                return {
                  type: "Slice",
                  children: parts
                };
              },
              _parseComparator: function(left, comparator) {
                var right = this.expression(bindingPower[comparator]);
                return { type: "Comparator", name: comparator, children: [left, right] };
              },
              _parseDotRHS: function(rbp) {
                var lookahead = this._lookahead(0);
                var exprTokens = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER, TOK_STAR];
                if (exprTokens.indexOf(lookahead) >= 0) {
                  return this.expression(rbp);
                } else if (lookahead === TOK_LBRACKET) {
                  this._match(TOK_LBRACKET);
                  return this._parseMultiselectList();
                } else if (lookahead === TOK_LBRACE) {
                  this._match(TOK_LBRACE);
                  return this._parseMultiselectHash();
                }
              },
              _parseProjectionRHS: function(rbp) {
                var right;
                if (bindingPower[this._lookahead(0)] < 10) {
                  right = { type: "Identity" };
                } else if (this._lookahead(0) === TOK_LBRACKET) {
                  right = this.expression(rbp);
                } else if (this._lookahead(0) === TOK_FILTER) {
                  right = this.expression(rbp);
                } else if (this._lookahead(0) === TOK_DOT) {
                  this._match(TOK_DOT);
                  right = this._parseDotRHS(rbp);
                } else {
                  var t = this._lookaheadToken(0);
                  var error = new Error("Sytanx error, unexpected token: " + t.value + "(" + t.type + ")");
                  error.name = "ParserError";
                  throw error;
                }
                return right;
              },
              _parseMultiselectList: function() {
                var expressions = [];
                while (this._lookahead(0) !== TOK_RBRACKET) {
                  var expression = this.expression(0);
                  expressions.push(expression);
                  if (this._lookahead(0) === TOK_COMMA) {
                    this._match(TOK_COMMA);
                    if (this._lookahead(0) === TOK_RBRACKET) {
                      throw new Error("Unexpected token Rbracket");
                    }
                  }
                }
                this._match(TOK_RBRACKET);
                return { type: "MultiSelectList", children: expressions };
              },
              _parseMultiselectHash: function() {
                var pairs = [];
                var identifierTypes = [TOK_UNQUOTEDIDENTIFIER, TOK_QUOTEDIDENTIFIER];
                var keyToken, keyName, value, node;
                for (; ; ) {
                  keyToken = this._lookaheadToken(0);
                  if (identifierTypes.indexOf(keyToken.type) < 0) {
                    throw new Error("Expecting an identifier token, got: " + keyToken.type);
                  }
                  keyName = keyToken.value;
                  this._advance();
                  this._match(TOK_COLON);
                  value = this.expression(0);
                  node = { type: "KeyValuePair", name: keyName, value };
                  pairs.push(node);
                  if (this._lookahead(0) === TOK_COMMA) {
                    this._match(TOK_COMMA);
                  } else if (this._lookahead(0) === TOK_RBRACE) {
                    this._match(TOK_RBRACE);
                    break;
                  }
                }
                return { type: "MultiSelectHash", children: pairs };
              }
            };
            function TreeInterpreter(runtime) {
              this.runtime = runtime;
            }
            TreeInterpreter.prototype = {
              search: function(node, value) {
                return this.visit(node, value);
              },
              visit: function(node, value) {
                var matched, current, result, first, second, field, left, right, collected, i;
                switch (node.type) {
                  case "Field":
                    if (value !== null && isObject(value)) {
                      field = value[node.name];
                      if (field === void 0) {
                        return null;
                      } else {
                        return field;
                      }
                    }
                    return null;
                  case "Subexpression":
                    result = this.visit(node.children[0], value);
                    for (i = 1; i < node.children.length; i++) {
                      result = this.visit(node.children[1], result);
                      if (result === null) {
                        return null;
                      }
                    }
                    return result;
                  case "IndexExpression":
                    left = this.visit(node.children[0], value);
                    right = this.visit(node.children[1], left);
                    return right;
                  case "Index":
                    if (!isArray(value)) {
                      return null;
                    }
                    var index = node.value;
                    if (index < 0) {
                      index = value.length + index;
                    }
                    result = value[index];
                    if (result === void 0) {
                      result = null;
                    }
                    return result;
                  case "Slice":
                    if (!isArray(value)) {
                      return null;
                    }
                    var sliceParams = node.children.slice(0);
                    var computed = this.computeSliceParams(value.length, sliceParams);
                    var start = computed[0];
                    var stop = computed[1];
                    var step = computed[2];
                    result = [];
                    if (step > 0) {
                      for (i = start; i < stop; i += step) {
                        result.push(value[i]);
                      }
                    } else {
                      for (i = start; i > stop; i += step) {
                        result.push(value[i]);
                      }
                    }
                    return result;
                  case "Projection":
                    var base = this.visit(node.children[0], value);
                    if (!isArray(base)) {
                      return null;
                    }
                    collected = [];
                    for (i = 0; i < base.length; i++) {
                      current = this.visit(node.children[1], base[i]);
                      if (current !== null) {
                        collected.push(current);
                      }
                    }
                    return collected;
                  case "ValueProjection":
                    base = this.visit(node.children[0], value);
                    if (!isObject(base)) {
                      return null;
                    }
                    collected = [];
                    var values = objValues(base);
                    for (i = 0; i < values.length; i++) {
                      current = this.visit(node.children[1], values[i]);
                      if (current !== null) {
                        collected.push(current);
                      }
                    }
                    return collected;
                  case "FilterProjection":
                    base = this.visit(node.children[0], value);
                    if (!isArray(base)) {
                      return null;
                    }
                    var filtered = [];
                    var finalResults = [];
                    for (i = 0; i < base.length; i++) {
                      matched = this.visit(node.children[2], base[i]);
                      if (!isFalse(matched)) {
                        filtered.push(base[i]);
                      }
                    }
                    for (var j = 0; j < filtered.length; j++) {
                      current = this.visit(node.children[1], filtered[j]);
                      if (current !== null) {
                        finalResults.push(current);
                      }
                    }
                    return finalResults;
                  case "Comparator":
                    first = this.visit(node.children[0], value);
                    second = this.visit(node.children[1], value);
                    switch (node.name) {
                      case TOK_EQ:
                        result = strictDeepEqual(first, second);
                        break;
                      case TOK_NE:
                        result = !strictDeepEqual(first, second);
                        break;
                      case TOK_GT:
                        result = first > second;
                        break;
                      case TOK_GTE:
                        result = first >= second;
                        break;
                      case TOK_LT:
                        result = first < second;
                        break;
                      case TOK_LTE:
                        result = first <= second;
                        break;
                      default:
                        throw new Error("Unknown comparator: " + node.name);
                    }
                    return result;
                  case TOK_FLATTEN:
                    var original = this.visit(node.children[0], value);
                    if (!isArray(original)) {
                      return null;
                    }
                    var merged = [];
                    for (i = 0; i < original.length; i++) {
                      current = original[i];
                      if (isArray(current)) {
                        merged.push.apply(merged, current);
                      } else {
                        merged.push(current);
                      }
                    }
                    return merged;
                  case "Identity":
                    return value;
                  case "MultiSelectList":
                    if (value === null) {
                      return null;
                    }
                    collected = [];
                    for (i = 0; i < node.children.length; i++) {
                      collected.push(this.visit(node.children[i], value));
                    }
                    return collected;
                  case "MultiSelectHash":
                    if (value === null) {
                      return null;
                    }
                    collected = {};
                    var child;
                    for (i = 0; i < node.children.length; i++) {
                      child = node.children[i];
                      collected[child.name] = this.visit(child.value, value);
                    }
                    return collected;
                  case "OrExpression":
                    matched = this.visit(node.children[0], value);
                    if (isFalse(matched)) {
                      matched = this.visit(node.children[1], value);
                    }
                    return matched;
                  case "AndExpression":
                    first = this.visit(node.children[0], value);
                    if (isFalse(first) === true) {
                      return first;
                    }
                    return this.visit(node.children[1], value);
                  case "NotExpression":
                    first = this.visit(node.children[0], value);
                    return isFalse(first);
                  case "Literal":
                    return node.value;
                  case TOK_PIPE:
                    left = this.visit(node.children[0], value);
                    return this.visit(node.children[1], left);
                  case TOK_CURRENT:
                    return value;
                  case "Function":
                    var resolvedArgs = [];
                    for (i = 0; i < node.children.length; i++) {
                      resolvedArgs.push(this.visit(node.children[i], value));
                    }
                    return this.runtime.callFunction(node.name, resolvedArgs);
                  case "ExpressionReference":
                    var refNode = node.children[0];
                    refNode.jmespathType = TOK_EXPREF;
                    return refNode;
                  default:
                    throw new Error("Unknown node type: " + node.type);
                }
              },
              computeSliceParams: function(arrayLength, sliceParams) {
                var start = sliceParams[0];
                var stop = sliceParams[1];
                var step = sliceParams[2];
                var computed = [null, null, null];
                if (step === null) {
                  step = 1;
                } else if (step === 0) {
                  var error = new Error("Invalid slice, step cannot be 0");
                  error.name = "RuntimeError";
                  throw error;
                }
                var stepValueNegative = step < 0 ? true : false;
                if (start === null) {
                  start = stepValueNegative ? arrayLength - 1 : 0;
                } else {
                  start = this.capSliceRange(arrayLength, start, step);
                }
                if (stop === null) {
                  stop = stepValueNegative ? -1 : arrayLength;
                } else {
                  stop = this.capSliceRange(arrayLength, stop, step);
                }
                computed[0] = start;
                computed[1] = stop;
                computed[2] = step;
                return computed;
              },
              capSliceRange: function(arrayLength, actualValue, step) {
                if (actualValue < 0) {
                  actualValue += arrayLength;
                  if (actualValue < 0) {
                    actualValue = step < 0 ? -1 : 0;
                  }
                } else if (actualValue >= arrayLength) {
                  actualValue = step < 0 ? arrayLength - 1 : arrayLength;
                }
                return actualValue;
              }
            };
            function Runtime(interpreter) {
              this._interpreter = interpreter;
              this.functionTable = {
                // name: [function, <signature>]
                // The <signature> can be:
                //
                // {
                //   args: [[type1, type2], [type1, type2]],
                //   variadic: true|false
                // }
                //
                // Each arg in the arg list is a list of valid types
                // (if the function is overloaded and supports multiple
                // types.  If the type is "any" then no type checking
                // occurs on the argument.  Variadic is optional
                // and if not provided is assumed to be false.
                abs: { _func: this._functionAbs, _signature: [{ types: [TYPE_NUMBER] }] },
                avg: { _func: this._functionAvg, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
                ceil: { _func: this._functionCeil, _signature: [{ types: [TYPE_NUMBER] }] },
                contains: {
                  _func: this._functionContains,
                  _signature: [
                    { types: [TYPE_STRING, TYPE_ARRAY] },
                    { types: [TYPE_ANY] }
                  ]
                },
                "ends_with": {
                  _func: this._functionEndsWith,
                  _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
                },
                floor: { _func: this._functionFloor, _signature: [{ types: [TYPE_NUMBER] }] },
                length: {
                  _func: this._functionLength,
                  _signature: [{ types: [TYPE_STRING, TYPE_ARRAY, TYPE_OBJECT] }]
                },
                map: {
                  _func: this._functionMap,
                  _signature: [{ types: [TYPE_EXPREF] }, { types: [TYPE_ARRAY] }]
                },
                max: {
                  _func: this._functionMax,
                  _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
                },
                "merge": {
                  _func: this._functionMerge,
                  _signature: [{ types: [TYPE_OBJECT], variadic: true }]
                },
                "max_by": {
                  _func: this._functionMaxBy,
                  _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
                },
                sum: { _func: this._functionSum, _signature: [{ types: [TYPE_ARRAY_NUMBER] }] },
                "starts_with": {
                  _func: this._functionStartsWith,
                  _signature: [{ types: [TYPE_STRING] }, { types: [TYPE_STRING] }]
                },
                min: {
                  _func: this._functionMin,
                  _signature: [{ types: [TYPE_ARRAY_NUMBER, TYPE_ARRAY_STRING] }]
                },
                "min_by": {
                  _func: this._functionMinBy,
                  _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
                },
                type: { _func: this._functionType, _signature: [{ types: [TYPE_ANY] }] },
                keys: { _func: this._functionKeys, _signature: [{ types: [TYPE_OBJECT] }] },
                values: { _func: this._functionValues, _signature: [{ types: [TYPE_OBJECT] }] },
                sort: { _func: this._functionSort, _signature: [{ types: [TYPE_ARRAY_STRING, TYPE_ARRAY_NUMBER] }] },
                "sort_by": {
                  _func: this._functionSortBy,
                  _signature: [{ types: [TYPE_ARRAY] }, { types: [TYPE_EXPREF] }]
                },
                join: {
                  _func: this._functionJoin,
                  _signature: [
                    { types: [TYPE_STRING] },
                    { types: [TYPE_ARRAY_STRING] }
                  ]
                },
                reverse: {
                  _func: this._functionReverse,
                  _signature: [{ types: [TYPE_STRING, TYPE_ARRAY] }]
                },
                "to_array": { _func: this._functionToArray, _signature: [{ types: [TYPE_ANY] }] },
                "to_string": { _func: this._functionToString, _signature: [{ types: [TYPE_ANY] }] },
                "to_number": { _func: this._functionToNumber, _signature: [{ types: [TYPE_ANY] }] },
                "not_null": {
                  _func: this._functionNotNull,
                  _signature: [{ types: [TYPE_ANY], variadic: true }]
                }
              };
            }
            Runtime.prototype = {
              callFunction: function(name, resolvedArgs) {
                var functionEntry = this.functionTable[name];
                if (functionEntry === void 0) {
                  throw new Error("Unknown function: " + name + "()");
                }
                this._validateArgs(name, resolvedArgs, functionEntry._signature);
                return functionEntry._func.call(this, resolvedArgs);
              },
              _validateArgs: function(name, args, signature) {
                var pluralized;
                if (signature[signature.length - 1].variadic) {
                  if (args.length < signature.length) {
                    pluralized = signature.length === 1 ? " argument" : " arguments";
                    throw new Error("ArgumentError: " + name + "() takes at least" + signature.length + pluralized + " but received " + args.length);
                  }
                } else if (args.length !== signature.length) {
                  pluralized = signature.length === 1 ? " argument" : " arguments";
                  throw new Error("ArgumentError: " + name + "() takes " + signature.length + pluralized + " but received " + args.length);
                }
                var currentSpec;
                var actualType;
                var typeMatched;
                for (var i = 0; i < signature.length; i++) {
                  typeMatched = false;
                  currentSpec = signature[i].types;
                  actualType = this._getTypeName(args[i]);
                  for (var j = 0; j < currentSpec.length; j++) {
                    if (this._typeMatches(actualType, currentSpec[j], args[i])) {
                      typeMatched = true;
                      break;
                    }
                  }
                  if (!typeMatched) {
                    var expected = currentSpec.map(function(typeIdentifier) {
                      return TYPE_NAME_TABLE[typeIdentifier];
                    }).join(",");
                    throw new Error("TypeError: " + name + "() expected argument " + (i + 1) + " to be type " + expected + " but received type " + TYPE_NAME_TABLE[actualType] + " instead.");
                  }
                }
              },
              _typeMatches: function(actual, expected, argValue) {
                if (expected === TYPE_ANY) {
                  return true;
                }
                if (expected === TYPE_ARRAY_STRING || expected === TYPE_ARRAY_NUMBER || expected === TYPE_ARRAY) {
                  if (expected === TYPE_ARRAY) {
                    return actual === TYPE_ARRAY;
                  } else if (actual === TYPE_ARRAY) {
                    var subtype;
                    if (expected === TYPE_ARRAY_NUMBER) {
                      subtype = TYPE_NUMBER;
                    } else if (expected === TYPE_ARRAY_STRING) {
                      subtype = TYPE_STRING;
                    }
                    for (var i = 0; i < argValue.length; i++) {
                      if (!this._typeMatches(
                        this._getTypeName(argValue[i]),
                        subtype,
                        argValue[i]
                      )) {
                        return false;
                      }
                    }
                    return true;
                  }
                } else {
                  return actual === expected;
                }
              },
              _getTypeName: function(obj) {
                switch (Object.prototype.toString.call(obj)) {
                  case "[object String]":
                    return TYPE_STRING;
                  case "[object Number]":
                    return TYPE_NUMBER;
                  case "[object Array]":
                    return TYPE_ARRAY;
                  case "[object Boolean]":
                    return TYPE_BOOLEAN;
                  case "[object Null]":
                    return TYPE_NULL;
                  case "[object Object]":
                    if (obj.jmespathType === TOK_EXPREF) {
                      return TYPE_EXPREF;
                    } else {
                      return TYPE_OBJECT;
                    }
                }
              },
              _functionStartsWith: function(resolvedArgs) {
                return resolvedArgs[0].lastIndexOf(resolvedArgs[1]) === 0;
              },
              _functionEndsWith: function(resolvedArgs) {
                var searchStr = resolvedArgs[0];
                var suffix = resolvedArgs[1];
                return searchStr.indexOf(suffix, searchStr.length - suffix.length) !== -1;
              },
              _functionReverse: function(resolvedArgs) {
                var typeName = this._getTypeName(resolvedArgs[0]);
                if (typeName === TYPE_STRING) {
                  var originalStr = resolvedArgs[0];
                  var reversedStr = "";
                  for (var i = originalStr.length - 1; i >= 0; i--) {
                    reversedStr += originalStr[i];
                  }
                  return reversedStr;
                } else {
                  var reversedArray = resolvedArgs[0].slice(0);
                  reversedArray.reverse();
                  return reversedArray;
                }
              },
              _functionAbs: function(resolvedArgs) {
                return Math.abs(resolvedArgs[0]);
              },
              _functionCeil: function(resolvedArgs) {
                return Math.ceil(resolvedArgs[0]);
              },
              _functionAvg: function(resolvedArgs) {
                var sum = 0;
                var inputArray = resolvedArgs[0];
                for (var i = 0; i < inputArray.length; i++) {
                  sum += inputArray[i];
                }
                return sum / inputArray.length;
              },
              _functionContains: function(resolvedArgs) {
                return resolvedArgs[0].indexOf(resolvedArgs[1]) >= 0;
              },
              _functionFloor: function(resolvedArgs) {
                return Math.floor(resolvedArgs[0]);
              },
              _functionLength: function(resolvedArgs) {
                if (!isObject(resolvedArgs[0])) {
                  return resolvedArgs[0].length;
                } else {
                  return Object.keys(resolvedArgs[0]).length;
                }
              },
              _functionMap: function(resolvedArgs) {
                var mapped = [];
                var interpreter = this._interpreter;
                var exprefNode = resolvedArgs[0];
                var elements = resolvedArgs[1];
                for (var i = 0; i < elements.length; i++) {
                  mapped.push(interpreter.visit(exprefNode, elements[i]));
                }
                return mapped;
              },
              _functionMerge: function(resolvedArgs) {
                var merged = {};
                for (var i = 0; i < resolvedArgs.length; i++) {
                  var current = resolvedArgs[i];
                  for (var key in current) {
                    merged[key] = current[key];
                  }
                }
                return merged;
              },
              _functionMax: function(resolvedArgs) {
                if (resolvedArgs[0].length > 0) {
                  var typeName = this._getTypeName(resolvedArgs[0][0]);
                  if (typeName === TYPE_NUMBER) {
                    return Math.max.apply(Math, resolvedArgs[0]);
                  } else {
                    var elements = resolvedArgs[0];
                    var maxElement = elements[0];
                    for (var i = 1; i < elements.length; i++) {
                      if (maxElement.localeCompare(elements[i]) < 0) {
                        maxElement = elements[i];
                      }
                    }
                    return maxElement;
                  }
                } else {
                  return null;
                }
              },
              _functionMin: function(resolvedArgs) {
                if (resolvedArgs[0].length > 0) {
                  var typeName = this._getTypeName(resolvedArgs[0][0]);
                  if (typeName === TYPE_NUMBER) {
                    return Math.min.apply(Math, resolvedArgs[0]);
                  } else {
                    var elements = resolvedArgs[0];
                    var minElement = elements[0];
                    for (var i = 1; i < elements.length; i++) {
                      if (elements[i].localeCompare(minElement) < 0) {
                        minElement = elements[i];
                      }
                    }
                    return minElement;
                  }
                } else {
                  return null;
                }
              },
              _functionSum: function(resolvedArgs) {
                var sum = 0;
                var listToSum = resolvedArgs[0];
                for (var i = 0; i < listToSum.length; i++) {
                  sum += listToSum[i];
                }
                return sum;
              },
              _functionType: function(resolvedArgs) {
                switch (this._getTypeName(resolvedArgs[0])) {
                  case TYPE_NUMBER:
                    return "number";
                  case TYPE_STRING:
                    return "string";
                  case TYPE_ARRAY:
                    return "array";
                  case TYPE_OBJECT:
                    return "object";
                  case TYPE_BOOLEAN:
                    return "boolean";
                  case TYPE_EXPREF:
                    return "expref";
                  case TYPE_NULL:
                    return "null";
                }
              },
              _functionKeys: function(resolvedArgs) {
                return Object.keys(resolvedArgs[0]);
              },
              _functionValues: function(resolvedArgs) {
                var obj = resolvedArgs[0];
                var keys = Object.keys(obj);
                var values = [];
                for (var i = 0; i < keys.length; i++) {
                  values.push(obj[keys[i]]);
                }
                return values;
              },
              _functionJoin: function(resolvedArgs) {
                var joinChar = resolvedArgs[0];
                var listJoin = resolvedArgs[1];
                return listJoin.join(joinChar);
              },
              _functionToArray: function(resolvedArgs) {
                if (this._getTypeName(resolvedArgs[0]) === TYPE_ARRAY) {
                  return resolvedArgs[0];
                } else {
                  return [resolvedArgs[0]];
                }
              },
              _functionToString: function(resolvedArgs) {
                if (this._getTypeName(resolvedArgs[0]) === TYPE_STRING) {
                  return resolvedArgs[0];
                } else {
                  return JSON.stringify(resolvedArgs[0]);
                }
              },
              _functionToNumber: function(resolvedArgs) {
                var typeName = this._getTypeName(resolvedArgs[0]);
                var convertedValue;
                if (typeName === TYPE_NUMBER) {
                  return resolvedArgs[0];
                } else if (typeName === TYPE_STRING) {
                  convertedValue = +resolvedArgs[0];
                  if (!isNaN(convertedValue)) {
                    return convertedValue;
                  }
                }
                return null;
              },
              _functionNotNull: function(resolvedArgs) {
                for (var i = 0; i < resolvedArgs.length; i++) {
                  if (this._getTypeName(resolvedArgs[i]) !== TYPE_NULL) {
                    return resolvedArgs[i];
                  }
                }
                return null;
              },
              _functionSort: function(resolvedArgs) {
                var sortedArray = resolvedArgs[0].slice(0);
                sortedArray.sort();
                return sortedArray;
              },
              _functionSortBy: function(resolvedArgs) {
                var sortedArray = resolvedArgs[0].slice(0);
                if (sortedArray.length === 0) {
                  return sortedArray;
                }
                var interpreter = this._interpreter;
                var exprefNode = resolvedArgs[1];
                var requiredType = this._getTypeName(
                  interpreter.visit(exprefNode, sortedArray[0])
                );
                if ([TYPE_NUMBER, TYPE_STRING].indexOf(requiredType) < 0) {
                  throw new Error("TypeError");
                }
                var that = this;
                var decorated = [];
                for (var i = 0; i < sortedArray.length; i++) {
                  decorated.push([i, sortedArray[i]]);
                }
                decorated.sort(function(a, b) {
                  var exprA = interpreter.visit(exprefNode, a[1]);
                  var exprB = interpreter.visit(exprefNode, b[1]);
                  if (that._getTypeName(exprA) !== requiredType) {
                    throw new Error(
                      "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprA)
                    );
                  } else if (that._getTypeName(exprB) !== requiredType) {
                    throw new Error(
                      "TypeError: expected " + requiredType + ", received " + that._getTypeName(exprB)
                    );
                  }
                  if (exprA > exprB) {
                    return 1;
                  } else if (exprA < exprB) {
                    return -1;
                  } else {
                    return a[0] - b[0];
                  }
                });
                for (var j = 0; j < decorated.length; j++) {
                  sortedArray[j] = decorated[j][1];
                }
                return sortedArray;
              },
              _functionMaxBy: function(resolvedArgs) {
                var exprefNode = resolvedArgs[1];
                var resolvedArray = resolvedArgs[0];
                var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
                var maxNumber = -Infinity;
                var maxRecord;
                var current;
                for (var i = 0; i < resolvedArray.length; i++) {
                  current = keyFunction(resolvedArray[i]);
                  if (current > maxNumber) {
                    maxNumber = current;
                    maxRecord = resolvedArray[i];
                  }
                }
                return maxRecord;
              },
              _functionMinBy: function(resolvedArgs) {
                var exprefNode = resolvedArgs[1];
                var resolvedArray = resolvedArgs[0];
                var keyFunction = this.createKeyFunction(exprefNode, [TYPE_NUMBER, TYPE_STRING]);
                var minNumber = Infinity;
                var minRecord;
                var current;
                for (var i = 0; i < resolvedArray.length; i++) {
                  current = keyFunction(resolvedArray[i]);
                  if (current < minNumber) {
                    minNumber = current;
                    minRecord = resolvedArray[i];
                  }
                }
                return minRecord;
              },
              createKeyFunction: function(exprefNode, allowedTypes) {
                var that = this;
                var interpreter = this._interpreter;
                var keyFunc = function(x) {
                  var current = interpreter.visit(exprefNode, x);
                  if (allowedTypes.indexOf(that._getTypeName(current)) < 0) {
                    var msg = "TypeError: expected one of " + allowedTypes + ", received " + that._getTypeName(current);
                    throw new Error(msg);
                  }
                  return current;
                };
                return keyFunc;
              }
            };
            function compile(stream) {
              var parser = new Parser();
              var ast = parser.parse(stream);
              return ast;
            }
            function tokenize(stream) {
              var lexer = new Lexer();
              return lexer.tokenize(stream);
            }
            function search(data, expression) {
              var parser = new Parser();
              var runtime = new Runtime();
              var interpreter = new TreeInterpreter(runtime);
              runtime._interpreter = interpreter;
              var node = parser.parse(expression);
              return interpreter.search(node, data);
            }
            exports3.tokenize = tokenize;
            exports3.compile = compile;
            exports3.search = search;
            exports3.strictDeepEqual = strictDeepEqual;
          })(typeof exports2 === "undefined" ? this.jmespath = {} : exports2);
        }, {}], 91: [function(require2, module2, exports2) {
          var process = module2.exports = {};
          var cachedSetTimeout;
          var cachedClearTimeout;
          function defaultSetTimout() {
            throw new Error("setTimeout has not been defined");
          }
          function defaultClearTimeout() {
            throw new Error("clearTimeout has not been defined");
          }
          (function() {
            try {
              if (typeof setTimeout === "function") {
                cachedSetTimeout = setTimeout;
              } else {
                cachedSetTimeout = defaultSetTimout;
              }
            } catch (e) {
              cachedSetTimeout = defaultSetTimout;
            }
            try {
              if (typeof clearTimeout === "function") {
                cachedClearTimeout = clearTimeout;
              } else {
                cachedClearTimeout = defaultClearTimeout;
              }
            } catch (e) {
              cachedClearTimeout = defaultClearTimeout;
            }
          })();
          function runTimeout(fun) {
            if (cachedSetTimeout === setTimeout) {
              return setTimeout(fun, 0);
            }
            if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
              cachedSetTimeout = setTimeout;
              return setTimeout(fun, 0);
            }
            try {
              return cachedSetTimeout(fun, 0);
            } catch (e) {
              try {
                return cachedSetTimeout.call(null, fun, 0);
              } catch (e2) {
                return cachedSetTimeout.call(this, fun, 0);
              }
            }
          }
          function runClearTimeout(marker) {
            if (cachedClearTimeout === clearTimeout) {
              return clearTimeout(marker);
            }
            if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
              cachedClearTimeout = clearTimeout;
              return clearTimeout(marker);
            }
            try {
              return cachedClearTimeout(marker);
            } catch (e) {
              try {
                return cachedClearTimeout.call(null, marker);
              } catch (e2) {
                return cachedClearTimeout.call(this, marker);
              }
            }
          }
          var queue = [];
          var draining = false;
          var currentQueue;
          var queueIndex = -1;
          function cleanUpNextTick() {
            if (!draining || !currentQueue) {
              return;
            }
            draining = false;
            if (currentQueue.length) {
              queue = currentQueue.concat(queue);
            } else {
              queueIndex = -1;
            }
            if (queue.length) {
              drainQueue();
            }
          }
          function drainQueue() {
            if (draining) {
              return;
            }
            var timeout = runTimeout(cleanUpNextTick);
            draining = true;
            var len = queue.length;
            while (len) {
              currentQueue = queue;
              queue = [];
              while (++queueIndex < len) {
                if (currentQueue) {
                  currentQueue[queueIndex].run();
                }
              }
              queueIndex = -1;
              len = queue.length;
            }
            currentQueue = null;
            draining = false;
            runClearTimeout(timeout);
          }
          process.nextTick = function(fun) {
            var args = new Array(arguments.length - 1);
            if (arguments.length > 1) {
              for (var i = 1; i < arguments.length; i++) {
                args[i - 1] = arguments[i];
              }
            }
            queue.push(new Item(fun, args));
            if (queue.length === 1 && !draining) {
              runTimeout(drainQueue);
            }
          };
          function Item(fun, array) {
            this.fun = fun;
            this.array = array;
          }
          Item.prototype.run = function() {
            this.fun.apply(null, this.array);
          };
          process.title = "browser";
          process.browser = true;
          process.env = {};
          process.argv = [];
          process.version = "";
          process.versions = {};
          function noop() {
          }
          process.on = noop;
          process.addListener = noop;
          process.once = noop;
          process.off = noop;
          process.removeListener = noop;
          process.removeAllListeners = noop;
          process.emit = noop;
          process.prependListener = noop;
          process.prependOnceListener = noop;
          process.listeners = function(name) {
            return [];
          };
          process.binding = function(name) {
            throw new Error("process.binding is not supported");
          };
          process.cwd = function() {
            return "/";
          };
          process.chdir = function(dir) {
            throw new Error("process.chdir is not supported");
          };
          process.umask = function() {
            return 0;
          };
        }, {}], 92: [function(require2, module2, exports2) {
          (function(global) {
            (function() {
              ;
              (function(root) {
                var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
                var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
                var freeGlobal = typeof global == "object" && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                  root = freeGlobal;
                }
                var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
                  "overflow": "Overflow: input needs wider integers to process",
                  "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                  "invalid-input": "Invalid input"
                }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
                function error(type) {
                  throw new RangeError(errors[type]);
                }
                function map(array, fn) {
                  var length = array.length;
                  var result = [];
                  while (length--) {
                    result[length] = fn(array[length]);
                  }
                  return result;
                }
                function mapDomain(string, fn) {
                  var parts = string.split("@");
                  var result = "";
                  if (parts.length > 1) {
                    result = parts[0] + "@";
                    string = parts[1];
                  }
                  string = string.replace(regexSeparators, ".");
                  var labels = string.split(".");
                  var encoded = map(labels, fn).join(".");
                  return result + encoded;
                }
                function ucs2decode(string) {
                  var output = [], counter = 0, length = string.length, value, extra;
                  while (counter < length) {
                    value = string.charCodeAt(counter++);
                    if (value >= 55296 && value <= 56319 && counter < length) {
                      extra = string.charCodeAt(counter++);
                      if ((extra & 64512) == 56320) {
                        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
                      } else {
                        output.push(value);
                        counter--;
                      }
                    } else {
                      output.push(value);
                    }
                  }
                  return output;
                }
                function ucs2encode(array) {
                  return map(array, function(value) {
                    var output = "";
                    if (value > 65535) {
                      value -= 65536;
                      output += stringFromCharCode(value >>> 10 & 1023 | 55296);
                      value = 56320 | value & 1023;
                    }
                    output += stringFromCharCode(value);
                    return output;
                  }).join("");
                }
                function basicToDigit(codePoint) {
                  if (codePoint - 48 < 10) {
                    return codePoint - 22;
                  }
                  if (codePoint - 65 < 26) {
                    return codePoint - 65;
                  }
                  if (codePoint - 97 < 26) {
                    return codePoint - 97;
                  }
                  return base;
                }
                function digitToBasic(digit, flag) {
                  return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }
                function adapt(delta, numPoints, firstTime) {
                  var k = 0;
                  delta = firstTime ? floor(delta / damp) : delta >> 1;
                  delta += floor(delta / numPoints);
                  for (; delta > baseMinusTMin * tMax >> 1; k += base) {
                    delta = floor(delta / baseMinusTMin);
                  }
                  return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }
                function decode(input) {
                  var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
                  basic = input.lastIndexOf(delimiter);
                  if (basic < 0) {
                    basic = 0;
                  }
                  for (j = 0; j < basic; ++j) {
                    if (input.charCodeAt(j) >= 128) {
                      error("not-basic");
                    }
                    output.push(input.charCodeAt(j));
                  }
                  for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
                    for (oldi = i, w = 1, k = base; ; k += base) {
                      if (index >= inputLength) {
                        error("invalid-input");
                      }
                      digit = basicToDigit(input.charCodeAt(index++));
                      if (digit >= base || digit > floor((maxInt - i) / w)) {
                        error("overflow");
                      }
                      i += digit * w;
                      t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                      if (digit < t) {
                        break;
                      }
                      baseMinusT = base - t;
                      if (w > floor(maxInt / baseMinusT)) {
                        error("overflow");
                      }
                      w *= baseMinusT;
                    }
                    out = output.length + 1;
                    bias = adapt(i - oldi, out, oldi == 0);
                    if (floor(i / out) > maxInt - n) {
                      error("overflow");
                    }
                    n += floor(i / out);
                    i %= out;
                    output.splice(i++, 0, n);
                  }
                  return ucs2encode(output);
                }
                function encode(input) {
                  var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
                  input = ucs2decode(input);
                  inputLength = input.length;
                  n = initialN;
                  delta = 0;
                  bias = initialBias;
                  for (j = 0; j < inputLength; ++j) {
                    currentValue = input[j];
                    if (currentValue < 128) {
                      output.push(stringFromCharCode(currentValue));
                    }
                  }
                  handledCPCount = basicLength = output.length;
                  if (basicLength) {
                    output.push(delimiter);
                  }
                  while (handledCPCount < inputLength) {
                    for (m = maxInt, j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue >= n && currentValue < m) {
                        m = currentValue;
                      }
                    }
                    handledCPCountPlusOne = handledCPCount + 1;
                    if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                      error("overflow");
                    }
                    delta += (m - n) * handledCPCountPlusOne;
                    n = m;
                    for (j = 0; j < inputLength; ++j) {
                      currentValue = input[j];
                      if (currentValue < n && ++delta > maxInt) {
                        error("overflow");
                      }
                      if (currentValue == n) {
                        for (q = delta, k = base; ; k += base) {
                          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                          if (q < t) {
                            break;
                          }
                          qMinusT = q - t;
                          baseMinusT = base - t;
                          output.push(
                            stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
                          );
                          q = floor(qMinusT / baseMinusT);
                        }
                        output.push(stringFromCharCode(digitToBasic(q, 0)));
                        bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                        delta = 0;
                        ++handledCPCount;
                      }
                    }
                    ++delta;
                    ++n;
                  }
                  return output.join("");
                }
                function toUnicode(input) {
                  return mapDomain(input, function(string) {
                    return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                  });
                }
                function toASCII(input) {
                  return mapDomain(input, function(string) {
                    return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
                  });
                }
                punycode = {
                  /**
                   * A string representing the current Punycode.js version number.
                   * @memberOf punycode
                   * @type String
                   */
                  "version": "1.4.1",
                  /**
                   * An object of methods to convert from JavaScript's internal character
                   * representation (UCS-2) to Unicode code points, and back.
                   * @see <https://mathiasbynens.be/notes/javascript-encoding>
                   * @memberOf punycode
                   * @type Object
                   */
                  "ucs2": {
                    "decode": ucs2decode,
                    "encode": ucs2encode
                  },
                  "decode": decode,
                  "encode": encode,
                  "toASCII": toASCII,
                  "toUnicode": toUnicode
                };
                if (true) {
                  !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
                    return punycode;
                  }).call(exports2, __webpack_require__2, exports2, module2), __WEBPACK_AMD_DEFINE_RESULT__ !== void 0 && (module2.exports = __WEBPACK_AMD_DEFINE_RESULT__));
                } else {
                }
              })(this);
            }).call(this);
          }).call(this, typeof __webpack_require__2.g !== "undefined" ? __webpack_require__2.g : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
        }, {}], 93: [function(require2, module2, exports2) {
          "use strict";
          function hasOwnProperty2(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          module2.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
              return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === "number") {
              maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
              if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
              } else {
                kstr = x;
                vstr = "";
              }
              k = decodeURIComponent(kstr);
              v = decodeURIComponent(vstr);
              if (!hasOwnProperty2(obj, k)) {
                obj[k] = v;
              } else if (isArray(obj[k])) {
                obj[k].push(v);
              } else {
                obj[k] = [obj[k], v];
              }
            }
            return obj;
          };
          var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
        }, {}], 94: [function(require2, module2, exports2) {
          "use strict";
          var stringifyPrimitive = function(v) {
            switch (typeof v) {
              case "string":
                return v;
              case "boolean":
                return v ? "true" : "false";
              case "number":
                return isFinite(v) ? v : "";
              default:
                return "";
            }
          };
          module2.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
              obj = void 0;
            }
            if (typeof obj === "object") {
              return map(objectKeys(obj), function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (isArray(obj[k])) {
                  return map(obj[k], function(v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
              }).join(sep);
            }
            if (!name)
              return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
          };
          var isArray = Array.isArray || function(xs) {
            return Object.prototype.toString.call(xs) === "[object Array]";
          };
          function map(xs, f) {
            if (xs.map)
              return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
              res.push(f(xs[i], i));
            }
            return res;
          }
          var objectKeys = Object.keys || function(obj) {
            var res = [];
            for (var key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key))
                res.push(key);
            }
            return res;
          };
        }, {}], 95: [function(require2, module2, exports2) {
          "use strict";
          exports2.decode = exports2.parse = require2("./decode");
          exports2.encode = exports2.stringify = require2("./encode");
        }, { "./decode": 93, "./encode": 94 }], 96: [function(require2, module2, exports2) {
          "use strict";
          function hasOwnProperty2(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
          }
          module2.exports = function(qs, sep, eq, options) {
            sep = sep || "&";
            eq = eq || "=";
            var obj = {};
            if (typeof qs !== "string" || qs.length === 0) {
              return obj;
            }
            var regexp = /\+/g;
            qs = qs.split(sep);
            var maxKeys = 1e3;
            if (options && typeof options.maxKeys === "number") {
              maxKeys = options.maxKeys;
            }
            var len = qs.length;
            if (maxKeys > 0 && len > maxKeys) {
              len = maxKeys;
            }
            for (var i = 0; i < len; ++i) {
              var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
              if (idx >= 0) {
                kstr = x.substr(0, idx);
                vstr = x.substr(idx + 1);
              } else {
                kstr = x;
                vstr = "";
              }
              k = decodeURIComponent(kstr);
              v = decodeURIComponent(vstr);
              if (!hasOwnProperty2(obj, k)) {
                obj[k] = v;
              } else if (Array.isArray(obj[k])) {
                obj[k].push(v);
              } else {
                obj[k] = [obj[k], v];
              }
            }
            return obj;
          };
        }, {}], 97: [function(require2, module2, exports2) {
          "use strict";
          var stringifyPrimitive = function(v) {
            switch (typeof v) {
              case "string":
                return v;
              case "boolean":
                return v ? "true" : "false";
              case "number":
                return isFinite(v) ? v : "";
              default:
                return "";
            }
          };
          module2.exports = function(obj, sep, eq, name) {
            sep = sep || "&";
            eq = eq || "=";
            if (obj === null) {
              obj = void 0;
            }
            if (typeof obj === "object") {
              return Object.keys(obj).map(function(k) {
                var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                if (Array.isArray(obj[k])) {
                  return obj[k].map(function(v) {
                    return ks + encodeURIComponent(stringifyPrimitive(v));
                  }).join(sep);
                } else {
                  return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                }
              }).join(sep);
            }
            if (!name)
              return "";
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
          };
        }, {}], 98: [function(require2, module2, exports2) {
          arguments[4][95][0].apply(exports2, arguments);
        }, { "./decode": 96, "./encode": 97, "dup": 95 }], 99: [function(require2, module2, exports2) {
          (function(setImmediate, clearImmediate) {
            (function() {
              var nextTick = require2("process/browser.js").nextTick;
              var apply = Function.prototype.apply;
              var slice = Array.prototype.slice;
              var immediateIds = {};
              var nextImmediateId = 0;
              exports2.setTimeout = function() {
                return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
              };
              exports2.setInterval = function() {
                return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
              };
              exports2.clearTimeout = exports2.clearInterval = function(timeout) {
                timeout.close();
              };
              function Timeout(id, clearFn) {
                this._id = id;
                this._clearFn = clearFn;
              }
              Timeout.prototype.unref = Timeout.prototype.ref = function() {
              };
              Timeout.prototype.close = function() {
                this._clearFn.call(window, this._id);
              };
              exports2.enroll = function(item, msecs) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = msecs;
              };
              exports2.unenroll = function(item) {
                clearTimeout(item._idleTimeoutId);
                item._idleTimeout = -1;
              };
              exports2._unrefActive = exports2.active = function(item) {
                clearTimeout(item._idleTimeoutId);
                var msecs = item._idleTimeout;
                if (msecs >= 0) {
                  item._idleTimeoutId = setTimeout(function onTimeout() {
                    if (item._onTimeout)
                      item._onTimeout();
                  }, msecs);
                }
              };
              exports2.setImmediate = typeof setImmediate === "function" ? setImmediate : function(fn) {
                var id = nextImmediateId++;
                var args = arguments.length < 2 ? false : slice.call(arguments, 1);
                immediateIds[id] = true;
                nextTick(function onNextTick() {
                  if (immediateIds[id]) {
                    if (args) {
                      fn.apply(null, args);
                    } else {
                      fn.call(null);
                    }
                    exports2.clearImmediate(id);
                  }
                });
                return id;
              };
              exports2.clearImmediate = typeof clearImmediate === "function" ? clearImmediate : function(id) {
                delete immediateIds[id];
              };
            }).call(this);
          }).call(this, require2("timers").setImmediate, require2("timers").clearImmediate);
        }, { "process/browser.js": 91, "timers": 99 }], 100: [function(require2, module2, exports2) {
          var punycode = require2("punycode");
          exports2.parse = urlParse;
          exports2.resolve = urlResolve;
          exports2.resolveObject = urlResolveObject;
          exports2.format = urlFormat;
          exports2.Url = Url;
          function Url() {
            this.protocol = null;
            this.slashes = null;
            this.auth = null;
            this.host = null;
            this.port = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.query = null;
            this.pathname = null;
            this.path = null;
            this.href = null;
          }
          var protocolPattern = /^([a-z0-9.+-]+:)/i, portPattern = /:[0-9]*$/, delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"], unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims), autoEscape = ["'"].concat(unwise), nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape), hostEndingChars = ["/", "?", "#"], hostnameMaxLen = 255, hostnamePartPattern = /^[a-z0-9A-Z_-]{0,63}$/, hostnamePartStart = /^([a-z0-9A-Z_-]{0,63})(.*)$/, unsafeProtocol = {
            "javascript": true,
            "javascript:": true
          }, hostlessProtocol = {
            "javascript": true,
            "javascript:": true
          }, slashedProtocol = {
            "http": true,
            "https": true,
            "ftp": true,
            "gopher": true,
            "file": true,
            "http:": true,
            "https:": true,
            "ftp:": true,
            "gopher:": true,
            "file:": true
          }, querystring = require2("querystring");
          function urlParse(url, parseQueryString, slashesDenoteHost) {
            if (url && isObject(url) && url instanceof Url)
              return url;
            var u = new Url();
            u.parse(url, parseQueryString, slashesDenoteHost);
            return u;
          }
          Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
            if (!isString(url)) {
              throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
            }
            var rest = url;
            rest = rest.trim();
            var proto = protocolPattern.exec(rest);
            if (proto) {
              proto = proto[0];
              var lowerProto = proto.toLowerCase();
              this.protocol = lowerProto;
              rest = rest.substr(proto.length);
            }
            if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
              var slashes = rest.substr(0, 2) === "//";
              if (slashes && !(proto && hostlessProtocol[proto])) {
                rest = rest.substr(2);
                this.slashes = true;
              }
            }
            if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
              var hostEnd = -1;
              for (var i = 0; i < hostEndingChars.length; i++) {
                var hec = rest.indexOf(hostEndingChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              var auth, atSign;
              if (hostEnd === -1) {
                atSign = rest.lastIndexOf("@");
              } else {
                atSign = rest.lastIndexOf("@", hostEnd);
              }
              if (atSign !== -1) {
                auth = rest.slice(0, atSign);
                rest = rest.slice(atSign + 1);
                this.auth = decodeURIComponent(auth);
              }
              hostEnd = -1;
              for (var i = 0; i < nonHostChars.length; i++) {
                var hec = rest.indexOf(nonHostChars[i]);
                if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
                  hostEnd = hec;
              }
              if (hostEnd === -1)
                hostEnd = rest.length;
              this.host = rest.slice(0, hostEnd);
              rest = rest.slice(hostEnd);
              this.parseHost();
              this.hostname = this.hostname || "";
              var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
              if (!ipv6Hostname) {
                var hostparts = this.hostname.split(/\./);
                for (var i = 0, l = hostparts.length; i < l; i++) {
                  var part = hostparts[i];
                  if (!part)
                    continue;
                  if (!part.match(hostnamePartPattern)) {
                    var newpart = "";
                    for (var j = 0, k = part.length; j < k; j++) {
                      if (part.charCodeAt(j) > 127) {
                        newpart += "x";
                      } else {
                        newpart += part[j];
                      }
                    }
                    if (!newpart.match(hostnamePartPattern)) {
                      var validParts = hostparts.slice(0, i);
                      var notHost = hostparts.slice(i + 1);
                      var bit = part.match(hostnamePartStart);
                      if (bit) {
                        validParts.push(bit[1]);
                        notHost.unshift(bit[2]);
                      }
                      if (notHost.length) {
                        rest = "/" + notHost.join(".") + rest;
                      }
                      this.hostname = validParts.join(".");
                      break;
                    }
                  }
                }
              }
              if (this.hostname.length > hostnameMaxLen) {
                this.hostname = "";
              } else {
                this.hostname = this.hostname.toLowerCase();
              }
              if (!ipv6Hostname) {
                var domainArray = this.hostname.split(".");
                var newOut = [];
                for (var i = 0; i < domainArray.length; ++i) {
                  var s = domainArray[i];
                  newOut.push(s.match(/[^A-Za-z0-9_-]/) ? "xn--" + punycode.encode(s) : s);
                }
                this.hostname = newOut.join(".");
              }
              var p = this.port ? ":" + this.port : "";
              var h = this.hostname || "";
              this.host = h + p;
              this.href += this.host;
              if (ipv6Hostname) {
                this.hostname = this.hostname.substr(1, this.hostname.length - 2);
                if (rest[0] !== "/") {
                  rest = "/" + rest;
                }
              }
            }
            if (!unsafeProtocol[lowerProto]) {
              for (var i = 0, l = autoEscape.length; i < l; i++) {
                var ae = autoEscape[i];
                var esc = encodeURIComponent(ae);
                if (esc === ae) {
                  esc = escape(ae);
                }
                rest = rest.split(ae).join(esc);
              }
            }
            var hash = rest.indexOf("#");
            if (hash !== -1) {
              this.hash = rest.substr(hash);
              rest = rest.slice(0, hash);
            }
            var qm = rest.indexOf("?");
            if (qm !== -1) {
              this.search = rest.substr(qm);
              this.query = rest.substr(qm + 1);
              if (parseQueryString) {
                this.query = querystring.parse(this.query);
              }
              rest = rest.slice(0, qm);
            } else if (parseQueryString) {
              this.search = "";
              this.query = {};
            }
            if (rest)
              this.pathname = rest;
            if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
              this.pathname = "/";
            }
            if (this.pathname || this.search) {
              var p = this.pathname || "";
              var s = this.search || "";
              this.path = p + s;
            }
            this.href = this.format();
            return this;
          };
          function urlFormat(obj) {
            if (isString(obj))
              obj = urlParse(obj);
            if (!(obj instanceof Url))
              return Url.prototype.format.call(obj);
            return obj.format();
          }
          Url.prototype.format = function() {
            var auth = this.auth || "";
            if (auth) {
              auth = encodeURIComponent(auth);
              auth = auth.replace(/%3A/i, ":");
              auth += "@";
            }
            var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
            if (this.host) {
              host = auth + this.host;
            } else if (this.hostname) {
              host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
              if (this.port) {
                host += ":" + this.port;
              }
            }
            if (this.query && isObject(this.query) && Object.keys(this.query).length) {
              query = querystring.stringify(this.query);
            }
            var search = this.search || query && "?" + query || "";
            if (protocol && protocol.substr(-1) !== ":")
              protocol += ":";
            if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
              host = "//" + (host || "");
              if (pathname && pathname.charAt(0) !== "/")
                pathname = "/" + pathname;
            } else if (!host) {
              host = "";
            }
            if (hash && hash.charAt(0) !== "#")
              hash = "#" + hash;
            if (search && search.charAt(0) !== "?")
              search = "?" + search;
            pathname = pathname.replace(/[?#]/g, function(match) {
              return encodeURIComponent(match);
            });
            search = search.replace("#", "%23");
            return protocol + host + pathname + search + hash;
          };
          function urlResolve(source, relative) {
            return urlParse(source, false, true).resolve(relative);
          }
          Url.prototype.resolve = function(relative) {
            return this.resolveObject(urlParse(relative, false, true)).format();
          };
          function urlResolveObject(source, relative) {
            if (!source)
              return relative;
            return urlParse(source, false, true).resolveObject(relative);
          }
          Url.prototype.resolveObject = function(relative) {
            if (isString(relative)) {
              var rel = new Url();
              rel.parse(relative, false, true);
              relative = rel;
            }
            var result = new Url();
            Object.keys(this).forEach(function(k) {
              result[k] = this[k];
            }, this);
            result.hash = relative.hash;
            if (relative.href === "") {
              result.href = result.format();
              return result;
            }
            if (relative.slashes && !relative.protocol) {
              Object.keys(relative).forEach(function(k) {
                if (k !== "protocol")
                  result[k] = relative[k];
              });
              if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
                result.path = result.pathname = "/";
              }
              result.href = result.format();
              return result;
            }
            if (relative.protocol && relative.protocol !== result.protocol) {
              if (!slashedProtocol[relative.protocol]) {
                Object.keys(relative).forEach(function(k) {
                  result[k] = relative[k];
                });
                result.href = result.format();
                return result;
              }
              result.protocol = relative.protocol;
              if (!relative.host && !hostlessProtocol[relative.protocol]) {
                var relPath = (relative.pathname || "").split("/");
                while (relPath.length && !(relative.host = relPath.shift()))
                  ;
                if (!relative.host)
                  relative.host = "";
                if (!relative.hostname)
                  relative.hostname = "";
                if (relPath[0] !== "")
                  relPath.unshift("");
                if (relPath.length < 2)
                  relPath.unshift("");
                result.pathname = relPath.join("/");
              } else {
                result.pathname = relative.pathname;
              }
              result.search = relative.search;
              result.query = relative.query;
              result.host = relative.host || "";
              result.auth = relative.auth;
              result.hostname = relative.hostname || relative.host;
              result.port = relative.port;
              if (result.pathname || result.search) {
                var p = result.pathname || "";
                var s = result.search || "";
                result.path = p + s;
              }
              result.slashes = result.slashes || relative.slashes;
              result.href = result.format();
              return result;
            }
            var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
            if (psychotic) {
              result.hostname = "";
              result.port = null;
              if (result.host) {
                if (srcPath[0] === "")
                  srcPath[0] = result.host;
                else
                  srcPath.unshift(result.host);
              }
              result.host = "";
              if (relative.protocol) {
                relative.hostname = null;
                relative.port = null;
                if (relative.host) {
                  if (relPath[0] === "")
                    relPath[0] = relative.host;
                  else
                    relPath.unshift(relative.host);
                }
                relative.host = null;
              }
              mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }
            if (isRelAbs) {
              result.host = relative.host || relative.host === "" ? relative.host : result.host;
              result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
              result.search = relative.search;
              result.query = relative.query;
              srcPath = relPath;
            } else if (relPath.length) {
              if (!srcPath)
                srcPath = [];
              srcPath.pop();
              srcPath = srcPath.concat(relPath);
              result.search = relative.search;
              result.query = relative.query;
            } else if (!isNullOrUndefined(relative.search)) {
              if (psychotic) {
                result.hostname = result.host = srcPath.shift();
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                  result.auth = authInHost.shift();
                  result.host = result.hostname = authInHost.shift();
                }
              }
              result.search = relative.search;
              result.query = relative.query;
              if (!isNull(result.pathname) || !isNull(result.search)) {
                result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
              }
              result.href = result.format();
              return result;
            }
            if (!srcPath.length) {
              result.pathname = null;
              if (result.search) {
                result.path = "/" + result.search;
              } else {
                result.path = null;
              }
              result.href = result.format();
              return result;
            }
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
              last = srcPath[i];
              if (last == ".") {
                srcPath.splice(i, 1);
              } else if (last === "..") {
                srcPath.splice(i, 1);
                up++;
              } else if (up) {
                srcPath.splice(i, 1);
                up--;
              }
            }
            if (!mustEndAbs && !removeAllDots) {
              for (; up--; up) {
                srcPath.unshift("..");
              }
            }
            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
              srcPath.unshift("");
            }
            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
              srcPath.push("");
            }
            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
            if (psychotic) {
              result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
              var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
              if (authInHost) {
                result.auth = authInHost.shift();
                result.host = result.hostname = authInHost.shift();
              }
            }
            mustEndAbs = mustEndAbs || result.host && srcPath.length;
            if (mustEndAbs && !isAbsolute) {
              srcPath.unshift("");
            }
            if (!srcPath.length) {
              result.pathname = null;
              result.path = null;
            } else {
              result.pathname = srcPath.join("/");
            }
            if (!isNull(result.pathname) || !isNull(result.search)) {
              result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
            }
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result.href = result.format();
            return result;
          };
          Url.prototype.parseHost = function() {
            var host = this.host;
            var port = portPattern.exec(host);
            if (port) {
              port = port[0];
              if (port !== ":") {
                this.port = port.substr(1);
              }
              host = host.substr(0, host.length - port.length);
            }
            if (host)
              this.hostname = host;
          };
          function isString(arg) {
            return typeof arg === "string";
          }
          function isObject(arg) {
            return typeof arg === "object" && arg !== null;
          }
          function isNull(arg) {
            return arg === null;
          }
          function isNullOrUndefined(arg) {
            return arg == null;
          }
        }, { "punycode": 92, "querystring": 95 }], 101: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var byteToHex = [];
          for (var i = 0; i < 256; ++i) {
            byteToHex[i] = (i + 256).toString(16).substr(1);
          }
          function bytesToUuid(buf, offset) {
            var i2 = offset || 0;
            var bth = byteToHex;
            return [bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], "-", bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]], bth[buf[i2++]]].join("");
          }
          var _default = bytesToUuid;
          exports2.default = _default;
        }, {}], 102: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          Object.defineProperty(exports2, "v1", {
            enumerable: true,
            get: function() {
              return _v.default;
            }
          });
          Object.defineProperty(exports2, "v3", {
            enumerable: true,
            get: function() {
              return _v2.default;
            }
          });
          Object.defineProperty(exports2, "v4", {
            enumerable: true,
            get: function() {
              return _v3.default;
            }
          });
          Object.defineProperty(exports2, "v5", {
            enumerable: true,
            get: function() {
              return _v4.default;
            }
          });
          var _v = _interopRequireDefault(require2("./v1.js"));
          var _v2 = _interopRequireDefault(require2("./v3.js"));
          var _v3 = _interopRequireDefault(require2("./v4.js"));
          var _v4 = _interopRequireDefault(require2("./v5.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
        }, { "./v1.js": 106, "./v3.js": 107, "./v4.js": 109, "./v5.js": 110 }], 103: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          function md52(bytes) {
            if (typeof bytes == "string") {
              var msg = unescape(encodeURIComponent(bytes));
              bytes = new Array(msg.length);
              for (var i = 0; i < msg.length; i++)
                bytes[i] = msg.charCodeAt(i);
            }
            return md5ToHexEncodedArray(wordsToMd5(bytesToWords(bytes), bytes.length * 8));
          }
          function md5ToHexEncodedArray(input) {
            var i;
            var x;
            var output = [];
            var length32 = input.length * 32;
            var hexTab = "0123456789abcdef";
            var hex;
            for (i = 0; i < length32; i += 8) {
              x = input[i >> 5] >>> i % 32 & 255;
              hex = parseInt(hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15), 16);
              output.push(hex);
            }
            return output;
          }
          function wordsToMd5(x, len) {
            x[len >> 5] |= 128 << len % 32;
            x[(len + 64 >>> 9 << 4) + 14] = len;
            var i;
            var olda;
            var oldb;
            var oldc;
            var oldd;
            var a = 1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d = 271733878;
            for (i = 0; i < x.length; i += 16) {
              olda = a;
              oldb = b;
              oldc = c;
              oldd = d;
              a = md5ff(a, b, c, d, x[i], 7, -680876936);
              d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
              c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
              b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
              a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
              d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
              c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
              b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
              a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
              d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
              c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
              b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
              a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
              d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
              c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
              b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
              a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
              d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
              c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
              b = md5gg(b, c, d, a, x[i], 20, -373897302);
              a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
              d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
              c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
              b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
              a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
              d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
              c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
              b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
              a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
              d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
              c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
              b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
              a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
              d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
              c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
              b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
              a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
              d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
              c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
              b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
              a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
              d = md5hh(d, a, b, c, x[i], 11, -358537222);
              c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
              b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
              a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
              d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
              c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
              b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
              a = md5ii(a, b, c, d, x[i], 6, -198630844);
              d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
              c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
              b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
              a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
              d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
              c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
              b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
              a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
              d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
              c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
              b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
              a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
              d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
              c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
              b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
              a = safeAdd(a, olda);
              b = safeAdd(b, oldb);
              c = safeAdd(c, oldc);
              d = safeAdd(d, oldd);
            }
            return [a, b, c, d];
          }
          function bytesToWords(input) {
            var i;
            var output = [];
            output[(input.length >> 2) - 1] = void 0;
            for (i = 0; i < output.length; i += 1) {
              output[i] = 0;
            }
            var length8 = input.length * 8;
            for (i = 0; i < length8; i += 8) {
              output[i >> 5] |= (input[i / 8] & 255) << i % 32;
            }
            return output;
          }
          function safeAdd(x, y) {
            var lsw = (x & 65535) + (y & 65535);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          }
          function bitRotateLeft(num, cnt) {
            return num << cnt | num >>> 32 - cnt;
          }
          function md5cmn(q, a, b, x, s, t) {
            return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
          }
          function md5ff(a, b, c, d, x, s, t) {
            return md5cmn(b & c | ~b & d, a, b, x, s, t);
          }
          function md5gg(a, b, c, d, x, s, t) {
            return md5cmn(b & d | c & ~d, a, b, x, s, t);
          }
          function md5hh(a, b, c, d, x, s, t) {
            return md5cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function md5ii(a, b, c, d, x, s, t) {
            return md5cmn(c ^ (b | ~d), a, b, x, s, t);
          }
          var _default = md52;
          exports2.default = _default;
        }, {}], 104: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = rng;
          var getRandomValues = typeof crypto != "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto) || typeof msCrypto != "undefined" && typeof msCrypto.getRandomValues == "function" && msCrypto.getRandomValues.bind(msCrypto);
          var rnds8 = new Uint8Array(16);
          function rng() {
            if (!getRandomValues) {
              throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
            }
            return getRandomValues(rnds8);
          }
        }, {}], 105: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          function f(s, x, y, z) {
            switch (s) {
              case 0:
                return x & y ^ ~x & z;
              case 1:
                return x ^ y ^ z;
              case 2:
                return x & y ^ x & z ^ y & z;
              case 3:
                return x ^ y ^ z;
            }
          }
          function ROTL(x, n) {
            return x << n | x >>> 32 - n;
          }
          function sha1(bytes) {
            var K = [1518500249, 1859775393, 2400959708, 3395469782];
            var H = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
            if (typeof bytes == "string") {
              var msg = unescape(encodeURIComponent(bytes));
              bytes = new Array(msg.length);
              for (var i = 0; i < msg.length; i++)
                bytes[i] = msg.charCodeAt(i);
            }
            bytes.push(128);
            var l = bytes.length / 4 + 2;
            var N = Math.ceil(l / 16);
            var M = new Array(N);
            for (var i = 0; i < N; i++) {
              M[i] = new Array(16);
              for (var j = 0; j < 16; j++) {
                M[i][j] = bytes[i * 64 + j * 4] << 24 | bytes[i * 64 + j * 4 + 1] << 16 | bytes[i * 64 + j * 4 + 2] << 8 | bytes[i * 64 + j * 4 + 3];
              }
            }
            M[N - 1][14] = (bytes.length - 1) * 8 / Math.pow(2, 32);
            M[N - 1][14] = Math.floor(M[N - 1][14]);
            M[N - 1][15] = (bytes.length - 1) * 8 & 4294967295;
            for (var i = 0; i < N; i++) {
              var W = new Array(80);
              for (var t = 0; t < 16; t++)
                W[t] = M[i][t];
              for (var t = 16; t < 80; t++) {
                W[t] = ROTL(W[t - 3] ^ W[t - 8] ^ W[t - 14] ^ W[t - 16], 1);
              }
              var a = H[0];
              var b = H[1];
              var c = H[2];
              var d = H[3];
              var e = H[4];
              for (var t = 0; t < 80; t++) {
                var s = Math.floor(t / 20);
                var T = ROTL(a, 5) + f(s, b, c, d) + e + K[s] + W[t] >>> 0;
                e = d;
                d = c;
                c = ROTL(b, 30) >>> 0;
                b = a;
                a = T;
              }
              H[0] = H[0] + a >>> 0;
              H[1] = H[1] + b >>> 0;
              H[2] = H[2] + c >>> 0;
              H[3] = H[3] + d >>> 0;
              H[4] = H[4] + e >>> 0;
            }
            return [H[0] >> 24 & 255, H[0] >> 16 & 255, H[0] >> 8 & 255, H[0] & 255, H[1] >> 24 & 255, H[1] >> 16 & 255, H[1] >> 8 & 255, H[1] & 255, H[2] >> 24 & 255, H[2] >> 16 & 255, H[2] >> 8 & 255, H[2] & 255, H[3] >> 24 & 255, H[3] >> 16 & 255, H[3] >> 8 & 255, H[3] & 255, H[4] >> 24 & 255, H[4] >> 16 & 255, H[4] >> 8 & 255, H[4] & 255];
          }
          var _default = sha1;
          exports2.default = _default;
        }, {}], 106: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _rng = _interopRequireDefault(require2("./rng.js"));
          var _bytesToUuid = _interopRequireDefault(require2("./bytesToUuid.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          var _nodeId;
          var _clockseq;
          var _lastMSecs = 0;
          var _lastNSecs = 0;
          function v1(options, buf, offset) {
            var i = buf && offset || 0;
            var b = buf || [];
            options = options || {};
            var node = options.node || _nodeId;
            var clockseq = options.clockseq !== void 0 ? options.clockseq : _clockseq;
            if (node == null || clockseq == null) {
              var seedBytes = options.random || (options.rng || _rng.default)();
              if (node == null) {
                node = _nodeId = [seedBytes[0] | 1, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];
              }
              if (clockseq == null) {
                clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
              }
            }
            var msecs = options.msecs !== void 0 ? options.msecs : (/* @__PURE__ */ new Date()).getTime();
            var nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
            var dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
            if (dt < 0 && options.clockseq === void 0) {
              clockseq = clockseq + 1 & 16383;
            }
            if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
              nsecs = 0;
            }
            if (nsecs >= 1e4) {
              throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
            }
            _lastMSecs = msecs;
            _lastNSecs = nsecs;
            _clockseq = clockseq;
            msecs += 122192928e5;
            var tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
            b[i++] = tl >>> 24 & 255;
            b[i++] = tl >>> 16 & 255;
            b[i++] = tl >>> 8 & 255;
            b[i++] = tl & 255;
            var tmh = msecs / 4294967296 * 1e4 & 268435455;
            b[i++] = tmh >>> 8 & 255;
            b[i++] = tmh & 255;
            b[i++] = tmh >>> 24 & 15 | 16;
            b[i++] = tmh >>> 16 & 255;
            b[i++] = clockseq >>> 8 | 128;
            b[i++] = clockseq & 255;
            for (var n = 0; n < 6; ++n) {
              b[i + n] = node[n];
            }
            return buf ? buf : (0, _bytesToUuid.default)(b);
          }
          var _default = v1;
          exports2.default = _default;
        }, { "./bytesToUuid.js": 101, "./rng.js": 104 }], 107: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _v = _interopRequireDefault(require2("./v35.js"));
          var _md = _interopRequireDefault(require2("./md5.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const v3 = (0, _v.default)("v3", 48, _md.default);
          var _default = v3;
          exports2.default = _default;
        }, { "./md5.js": 103, "./v35.js": 108 }], 108: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = _default;
          exports2.URL = exports2.DNS = void 0;
          var _bytesToUuid = _interopRequireDefault(require2("./bytesToUuid.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function uuidToBytes(uuid) {
            var bytes = [];
            uuid.replace(/[a-fA-F0-9]{2}/g, function(hex) {
              bytes.push(parseInt(hex, 16));
            });
            return bytes;
          }
          function stringToBytes(str) {
            str = unescape(encodeURIComponent(str));
            var bytes = new Array(str.length);
            for (var i = 0; i < str.length; i++) {
              bytes[i] = str.charCodeAt(i);
            }
            return bytes;
          }
          const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
          exports2.DNS = DNS;
          const URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
          exports2.URL = URL2;
          function _default(name, version, hashfunc) {
            var generateUUID = function(value, namespace, buf, offset) {
              var off = buf && offset || 0;
              if (typeof value == "string")
                value = stringToBytes(value);
              if (typeof namespace == "string")
                namespace = uuidToBytes(namespace);
              if (!Array.isArray(value))
                throw TypeError("value must be an array of bytes");
              if (!Array.isArray(namespace) || namespace.length !== 16)
                throw TypeError("namespace must be uuid string or an Array of 16 byte values");
              var bytes = hashfunc(namespace.concat(value));
              bytes[6] = bytes[6] & 15 | version;
              bytes[8] = bytes[8] & 63 | 128;
              if (buf) {
                for (var idx = 0; idx < 16; ++idx) {
                  buf[off + idx] = bytes[idx];
                }
              }
              return buf || (0, _bytesToUuid.default)(bytes);
            };
            try {
              generateUUID.name = name;
            } catch (err) {
            }
            generateUUID.DNS = DNS;
            generateUUID.URL = URL2;
            return generateUUID;
          }
        }, { "./bytesToUuid.js": 101 }], 109: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _rng = _interopRequireDefault(require2("./rng.js"));
          var _bytesToUuid = _interopRequireDefault(require2("./bytesToUuid.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          function v4(options, buf, offset) {
            var i = buf && offset || 0;
            if (typeof options == "string") {
              buf = options === "binary" ? new Array(16) : null;
              options = null;
            }
            options = options || {};
            var rnds = options.random || (options.rng || _rng.default)();
            rnds[6] = rnds[6] & 15 | 64;
            rnds[8] = rnds[8] & 63 | 128;
            if (buf) {
              for (var ii = 0; ii < 16; ++ii) {
                buf[i + ii] = rnds[ii];
              }
            }
            return buf || (0, _bytesToUuid.default)(rnds);
          }
          var _default = v4;
          exports2.default = _default;
        }, { "./bytesToUuid.js": 101, "./rng.js": 104 }], 110: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", {
            value: true
          });
          exports2.default = void 0;
          var _v = _interopRequireDefault(require2("./v35.js"));
          var _sha = _interopRequireDefault(require2("./sha1.js"));
          function _interopRequireDefault(obj) {
            return obj && obj.__esModule ? obj : { default: obj };
          }
          const v5 = (0, _v.default)("v5", 80, _sha.default);
          var _default = v5;
          exports2.default = _default;
        }, { "./sha1.js": 105, "./v35.js": 108 }], 111: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var LRU_1 = require2("./utils/LRU");
          var CACHE_SIZE = 1e3;
          var EndpointCache = (
            /** @class */
            function() {
              function EndpointCache2(maxSize) {
                if (maxSize === void 0) {
                  maxSize = CACHE_SIZE;
                }
                this.maxSize = maxSize;
                this.cache = new LRU_1.LRUCache(maxSize);
              }
              ;
              Object.defineProperty(EndpointCache2.prototype, "size", {
                get: function() {
                  return this.cache.length;
                },
                enumerable: true,
                configurable: true
              });
              EndpointCache2.prototype.put = function(key, value) {
                var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
                var endpointRecord = this.populateValue(value);
                this.cache.put(keyString, endpointRecord);
              };
              EndpointCache2.prototype.get = function(key) {
                var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
                var now = Date.now();
                var records = this.cache.get(keyString);
                if (records) {
                  for (var i = records.length - 1; i >= 0; i--) {
                    var record = records[i];
                    if (record.Expire < now) {
                      records.splice(i, 1);
                    }
                  }
                  if (records.length === 0) {
                    this.cache.remove(keyString);
                    return void 0;
                  }
                }
                return records;
              };
              EndpointCache2.getKeyString = function(key) {
                var identifiers = [];
                var identifierNames = Object.keys(key).sort();
                for (var i = 0; i < identifierNames.length; i++) {
                  var identifierName = identifierNames[i];
                  if (key[identifierName] === void 0)
                    continue;
                  identifiers.push(key[identifierName]);
                }
                return identifiers.join(" ");
              };
              EndpointCache2.prototype.populateValue = function(endpoints) {
                var now = Date.now();
                return endpoints.map(function(endpoint) {
                  return {
                    Address: endpoint.Address || "",
                    Expire: now + (endpoint.CachePeriodInMinutes || 1) * 60 * 1e3
                  };
                });
              };
              EndpointCache2.prototype.empty = function() {
                this.cache.empty();
              };
              EndpointCache2.prototype.remove = function(key) {
                var keyString = typeof key !== "string" ? EndpointCache2.getKeyString(key) : key;
                this.cache.remove(keyString);
              };
              return EndpointCache2;
            }()
          );
          exports2.EndpointCache = EndpointCache;
        }, { "./utils/LRU": 112 }], 112: [function(require2, module2, exports2) {
          "use strict";
          Object.defineProperty(exports2, "__esModule", { value: true });
          var LinkedListNode = (
            /** @class */
            /* @__PURE__ */ function() {
              function LinkedListNode2(key, value) {
                this.key = key;
                this.value = value;
              }
              return LinkedListNode2;
            }()
          );
          var LRUCache = (
            /** @class */
            function() {
              function LRUCache2(size) {
                this.nodeMap = {};
                this.size = 0;
                if (typeof size !== "number" || size < 1) {
                  throw new Error("Cache size can only be positive number");
                }
                this.sizeLimit = size;
              }
              Object.defineProperty(LRUCache2.prototype, "length", {
                get: function() {
                  return this.size;
                },
                enumerable: true,
                configurable: true
              });
              LRUCache2.prototype.prependToList = function(node) {
                if (!this.headerNode) {
                  this.tailNode = node;
                } else {
                  this.headerNode.prev = node;
                  node.next = this.headerNode;
                }
                this.headerNode = node;
                this.size++;
              };
              LRUCache2.prototype.removeFromTail = function() {
                if (!this.tailNode) {
                  return void 0;
                }
                var node = this.tailNode;
                var prevNode = node.prev;
                if (prevNode) {
                  prevNode.next = void 0;
                }
                node.prev = void 0;
                this.tailNode = prevNode;
                this.size--;
                return node;
              };
              LRUCache2.prototype.detachFromList = function(node) {
                if (this.headerNode === node) {
                  this.headerNode = node.next;
                }
                if (this.tailNode === node) {
                  this.tailNode = node.prev;
                }
                if (node.prev) {
                  node.prev.next = node.next;
                }
                if (node.next) {
                  node.next.prev = node.prev;
                }
                node.next = void 0;
                node.prev = void 0;
                this.size--;
              };
              LRUCache2.prototype.get = function(key) {
                if (this.nodeMap[key]) {
                  var node = this.nodeMap[key];
                  this.detachFromList(node);
                  this.prependToList(node);
                  return node.value;
                }
              };
              LRUCache2.prototype.remove = function(key) {
                if (this.nodeMap[key]) {
                  var node = this.nodeMap[key];
                  this.detachFromList(node);
                  delete this.nodeMap[key];
                }
              };
              LRUCache2.prototype.put = function(key, value) {
                if (this.nodeMap[key]) {
                  this.remove(key);
                } else if (this.size === this.sizeLimit) {
                  var tailNode = this.removeFromTail();
                  var key_1 = tailNode.key;
                  delete this.nodeMap[key_1];
                }
                var newNode = new LinkedListNode(key, value);
                this.nodeMap[key] = newNode;
                this.prependToList(newNode);
              };
              LRUCache2.prototype.empty = function() {
                var keys = Object.keys(this.nodeMap);
                for (var i = 0; i < keys.length; i++) {
                  var key = keys[i];
                  var node = this.nodeMap[key];
                  this.detachFromList(node);
                  delete this.nodeMap[key];
                }
              };
              return LRUCache2;
            }()
          );
          exports2.LRUCache = LRUCache;
        }, {}], 113: [function(require2, module2, exports2) {
          require2("./browser_loader");
          var AWS2 = require2("./core");
          if (typeof window !== "undefined")
            window.AWS = AWS2;
          if (typeof module2 !== "undefined") {
            module2.exports = AWS2;
          }
          if (typeof self !== "undefined")
            self.AWS = AWS2;
          if (!Object.prototype.hasOwnProperty.call(AWS2, "Connect")) {
            AWS2.apiLoader.services["connect"] = {};
            AWS2.Connect = AWS2.Service.defineService("connect", ["2017-02-15"]);
          }
          AWS2.apiLoader.services["connect"]["2017-02-15"] = require2("../apis/connect-2017-02-15.min");
        }, { "../apis/connect-2017-02-15.min": 3, "./browser_loader": 16, "./core": 19 }] }, {}, [113]);
      }
    ),
    /***/
    754: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          connect2.ClientMethods = connect2.makeEnum([
            "getAgentSnapshot",
            "putAgentState",
            "getAgentStates",
            "getDialableCountryCodes",
            "getRoutingProfileQueues",
            "getAgentPermissions",
            "getAgentConfiguration",
            "updateAgentConfiguration",
            "acceptContact",
            "createOutboundContact",
            "createTaskContact",
            "clearContact",
            "completeContact",
            "destroyContact",
            "rejectContact",
            "notifyContactIssue",
            "updateContactAttributes",
            "createAdditionalConnection",
            "destroyConnection",
            "holdConnection",
            "resumeConnection",
            "toggleActiveConnections",
            "conferenceConnections",
            "sendClientLogs",
            "sendDigits",
            "sendSoftphoneCallReport",
            "sendSoftphoneCallMetrics",
            "getEndpoints",
            "getNewAuthToken",
            "createTransport",
            "muteParticipant",
            "unmuteParticipant",
            "updateMonitorParticipantState",
            "pauseContact",
            "resumeContact"
          ]);
          connect2.AgentAppClientMethods = {
            GET_CONTACT: "AgentAppService.Lcms.getContact",
            DELETE_SPEAKER: "AgentAppService.VoiceId.deleteSpeaker",
            ENROLL_BY_SESSION: "AgentAppService.VoiceId.enrollBySession",
            EVALUATE_SESSION: "AgentAppService.VoiceId.evaluateSession",
            DESCRIBE_SPEAKER: "AgentAppService.VoiceId.describeSpeaker",
            OPT_OUT_SPEAKER: "AgentAppService.VoiceId.optOutSpeaker",
            UPDATE_VOICE_ID_DATA: "AgentAppService.Lcms.updateVoiceIdData",
            DESCRIBE_SESSION: "AgentAppService.VoiceId.describeSession",
            UPDATE_SESSION: "AgentAppService.VoiceId.updateSession",
            START_VOICE_ID_SESSION: "AgentAppService.Nasa.startVoiceIdSession",
            LIST_INTEGRATION_ASSOCIATIONS: "AgentAppService.Acs.listIntegrationAssociations"
          };
          connect2.MasterMethods = connect2.makeEnum([
            "becomeMaster",
            "checkMaster"
          ]);
          connect2.TaskTemplatesClientMethods = connect2.makeEnum([
            "listTaskTemplates",
            "getTaskTemplate",
            "createTemplatedTask",
            "updateContact"
          ]);
          connect2.ApiProxyClientMethods = connect2.makeEnum([
            "qrIntegrationExists",
            "qrSearchQuickResponses"
          ]);
          connect2.RetryableClientMethodsList = [
            connect2.ClientMethods.GET_AGENT_SNAPSHOT,
            connect2.ClientMethods.GET_AGENT_CONFIGURATION,
            connect2.ClientMethods.GET_AGENT_PERMISSIONS,
            connect2.ClientMethods.GET_AGENT_STATES,
            connect2.ClientMethods.GET_DIALABLE_COUNTRY_CODES,
            connect2.ClientMethods.GET_ROUTING_PROFILE_QUEUES
          ];
          connect2.RetryableErrors = connect2.makeEnum([
            "unauthorized",
            "accessDenied"
          ]);
          connect2.RetryStatus = connect2.makeEnum([
            "retrying",
            "exhausted",
            "none"
          ]);
          var ClientBase = function() {
          };
          ClientBase.EMPTY_CALLBACKS = {
            success: function() {
            },
            failure: function() {
            }
          };
          ClientBase.prototype.call = function(method, paramsIn, callbacksIn) {
            connect2.assertNotNull(method, "method");
            var params = paramsIn || {};
            var callbacks = callbacksIn || ClientBase.EMPTY_CALLBACKS;
            this._callImpl(method, params, callbacks);
          };
          ClientBase.prototype._callImpl = function(method, params, callbacks) {
            throw new connect2.NotImplementedError();
          };
          var NullClient = function() {
            ClientBase.call(this);
          };
          NullClient.prototype = Object.create(ClientBase.prototype);
          NullClient.prototype.constructor = NullClient;
          NullClient.prototype._callImpl = function(method, params, callbacks) {
            if (callbacks && callbacks.failure) {
              var message = connect2.sprintf("No such method exists on NULL client: %s", method);
              callbacks.failure(new connect2.ValueError(message), { message });
            }
          };
          var UpstreamConduitClientBase = function(conduit, requestEvent, responseEvent) {
            ClientBase.call(this);
            this.conduit = conduit;
            this.requestEvent = requestEvent;
            this.responseEvent = responseEvent;
            this._requestIdCallbacksMap = {};
            this.conduit.onUpstream(responseEvent, connect2.hitch(this, this._handleResponse));
          };
          UpstreamConduitClientBase.prototype = Object.create(ClientBase.prototype);
          UpstreamConduitClientBase.prototype.constructor = UpstreamConduitClientBase;
          UpstreamConduitClientBase.prototype._callImpl = function(method, params, callbacks) {
            var request = connect2.EventFactory.createRequest(this.requestEvent, method, params);
            this._requestIdCallbacksMap[request.requestId] = callbacks;
            const methodsToSkip = [
              connect2.ClientMethods.SEND_CLIENT_LOGS,
              connect2.ClientMethods.SEND_SOFTPHONE_CALL_METRICS,
              connect2.ClientMethods.SEND_SOFTPHONE_CALL_REPORT
            ];
            try {
              if (request.event === connect2.EventType.API_REQUEST && !methodsToSkip.includes(request.method)) {
                connect2.getLog().trace(`Sending API_REQUEST event for ${request.method} to upstream`).withObject({
                  method: request.method,
                  params: request.params,
                  stack: new Error().stack
                }).sendInternalLogToServer();
              }
            } catch (err) {
              connect2.getLog().error("Stack trace Log Failed").withObject({ err }).sendInternalLogToServer();
            }
            this.conduit.sendUpstream(request.event, request);
          };
          UpstreamConduitClientBase.prototype._getCallbacksForRequest = function(requestId) {
            var callbacks = this._requestIdCallbacksMap[requestId] || null;
            if (callbacks != null) {
              delete this._requestIdCallbacksMap[requestId];
            }
            return callbacks;
          };
          UpstreamConduitClientBase.prototype._handleResponse = function(data) {
            var callbacks = this._getCallbacksForRequest(data.requestId);
            if (callbacks == null) {
              return;
            }
            if (data.err && callbacks.failure) {
              callbacks.failure(data.err, data.data);
            } else if (callbacks.success) {
              callbacks.success(data.data);
            }
          };
          var UpstreamConduitClient = function(conduit) {
            UpstreamConduitClientBase.call(this, conduit, connect2.EventType.API_REQUEST, connect2.EventType.API_RESPONSE);
          };
          UpstreamConduitClient.prototype = Object.create(UpstreamConduitClientBase.prototype);
          UpstreamConduitClient.prototype.constructor = UpstreamConduitClient;
          var ApiProxyClient = function() {
            ClientBase.call(this);
            const bus = connect2.core.getEventBus();
            bus.subscribe(connect2.EventType.API_PROXY_RESPONSE, connect2.hitch(this, this._handleResponse));
            this._requestIdCallbacksMap = {};
          };
          ApiProxyClient.prototype = Object.create(ClientBase.prototype);
          ApiProxyClient.prototype.constructor = ApiProxyClient;
          ApiProxyClient.prototype._callImpl = function(method, params, callbacks) {
            var request = connect2.EventFactory.createRequest(connect2.EventType.API_PROXY_REQUEST, method, params);
            this._requestIdCallbacksMap[request.requestId] = callbacks;
            connect2.core.getEventBus().trigger(connect2.EventType.API_PROXY_REQUEST, request);
          };
          ApiProxyClient.prototype._getCallbacksForRequest = function(requestId) {
            var callbacks = this._requestIdCallbacksMap[requestId] || null;
            if (callbacks != null) {
              delete this._requestIdCallbacksMap[requestId];
            }
            return callbacks;
          };
          ApiProxyClient.prototype._handleResponse = function(data) {
            var callbacks = this._getCallbacksForRequest(data.requestId);
            if (callbacks == null) {
              return;
            }
            if (data.err && callbacks.failure) {
              callbacks.failure(data.err, data.data);
            } else if (callbacks.success) {
              callbacks.success(data.data);
            }
          };
          var UpstreamConduitMasterClient = function(conduit) {
            UpstreamConduitClientBase.call(this, conduit, connect2.EventType.MASTER_REQUEST, connect2.EventType.MASTER_RESPONSE);
          };
          UpstreamConduitMasterClient.prototype = Object.create(UpstreamConduitClientBase.prototype);
          UpstreamConduitMasterClient.prototype.constructor = UpstreamConduitMasterClient;
          var AgentAppClient = function(authCookieName, authToken, endpoint) {
            connect2.assertNotNull(authCookieName, "authCookieName");
            connect2.assertNotNull(authToken, "authToken");
            connect2.assertNotNull(endpoint, "endpoint");
            ClientBase.call(this);
            this.endpointUrl = connect2.getUrlWithProtocol(endpoint);
            this.authToken = authToken;
            this.authCookieName = authCookieName;
          };
          AgentAppClient.prototype = Object.create(ClientBase.prototype);
          AgentAppClient.prototype.constructor = AgentAppClient;
          AgentAppClient.prototype._callImpl = function(method, params, callbacks) {
            var self2 = this;
            var bear = {};
            bear[self2.authCookieName] = self2.authToken;
            var options = {
              method: "post",
              body: JSON.stringify(params || {}),
              headers: {
                "Accept": "application/json",
                "Content-Type": "application/json",
                "X-Amz-target": method,
                "X-Amz-Bearer": JSON.stringify(bear)
              }
            };
            connect2.fetch(self2.endpointUrl, options).then(function(res) {
              callbacks.success(res);
            }).catch(function(err) {
              const reader = err.body.getReader();
              let body = "";
              const decoder = new TextDecoder();
              reader.read().then(function processText({ done, value }) {
                if (done) {
                  var error = JSON.parse(body);
                  error.status = err.status;
                  callbacks.failure(error);
                  return;
                }
                body += decoder.decode(value);
                return reader.read().then(processText);
              });
            });
          };
          var AWSClient = function(authToken, region, endpointIn) {
            connect2.assertNotNull(authToken, "authToken");
            connect2.assertNotNull(region, "region");
            ClientBase.call(this);
            AWS.config.credentials = new AWS.Credentials({});
            AWS.config.region = region;
            this.authToken = authToken;
            var baseUrl = connect2.getBaseUrl();
            var endpointUrl = endpointIn || (baseUrl.includes(".awsapps.com") ? baseUrl + "/connect/api" : baseUrl + "/api");
            var endpoint = new AWS.Endpoint(endpointUrl);
            this.client = new AWS.Connect({ endpoint });
            this.unauthorizedFailCounter = 0;
            this.accessDeniedFailCounter = 0;
          };
          AWSClient.prototype = Object.create(ClientBase.prototype);
          AWSClient.prototype.constructor = AWSClient;
          AWSClient.prototype._callImpl = function(method, params, callbacks) {
            var self2 = this;
            var log2 = connect2.getLog();
            if (!connect2.contains(this.client, method)) {
              var message = connect2.sprintf("No such method exists on AWS client: %s", method);
              callbacks.failure(new connect2.ValueError(message), { message });
            } else {
              params = this._translateParams(method, params);
              if (method === "pauseContact" || method === "resumeContact") {
                delete params.authentication;
              }
              if (params && params.relatedContactId && params.relatedContactId !== null) {
                if (params.previousContactId) {
                  delete params.previousContactId;
                }
              }
              log2.trace("AWSClient: --> Calling operation '%s'", method).sendInternalLogToServer();
              this.client[method](params).on("build", function(request) {
                request.httpRequest.headers["X-Amz-Bearer"] = self2.authToken;
              }).send(function(err, data) {
                try {
                  if (err) {
                    if (err.code === connect2.CTIExceptions.UNAUTHORIZED_EXCEPTION || err.statusCode === 401) {
                      self2._retryMethod(method, callbacks, err, data, connect2.RetryableErrors.UNAUTHORIZED);
                    } else if (err.code === connect2.CTIExceptions.ACCESS_DENIED_EXCEPTION || err.statusCode === 403) {
                      self2._retryMethod(method, callbacks, err, data, connect2.RetryableErrors.ACCESS_DENIED);
                    } else {
                      self2.unauthorizedFailCounter = 0;
                      self2.accessDeniedFailCounter = 0;
                      callbacks.failure(self2._formatCallError(self2._addStatusCodeToError(err)), data);
                    }
                    log2.trace("AWSClient: <-- Operation '%s' failed: %s", method, JSON.stringify(err)).sendInternalLogToServer();
                  } else {
                    let dataAttribute = {};
                    log2.trace("AWSClient: <-- Operation '%s' succeeded.", method).withObject(data).sendInternalLogToServer();
                    self2.unauthorizedFailCounter = 0;
                    self2.accessDeniedFailCounter = 0;
                    if (this.httpResponse && this.httpResponse.hasOwnProperty("body")) {
                      dataAttribute.contentLength = this.httpResponse.body.length;
                    }
                    callbacks.success(data, dataAttribute);
                  }
                } catch (e) {
                  connect2.getLog().error("Failed to handle AWS API request for method %s", method).withException(e).sendInternalLogToServer();
                }
              });
            }
          };
          AWSClient.prototype._isRetryableMethod = function(method) {
            return connect2.RetryableClientMethodsList.includes(method);
          };
          AWSClient.prototype._retryMethod = function(method, callbacks, err, data, retryableError) {
            var self2 = this;
            var log2 = connect2.getLog();
            const formatRetryError = (err2) => self2._formatCallError(self2._addStatusCodeToError(err2));
            let retryParams = {
              maxCount: connect2.core.MAX_UNAUTHORIZED_RETRY_COUNT,
              failCounter: self2.unauthorizedFailCounter,
              increaseCounter: () => self2.unauthorizedFailCounter += 1,
              resetCounter: () => self2.unauthorizedFailCounter = 0,
              errorMessage: "unauthorized",
              exhaustedRetries: self2.unauthorizedFailCounter >= connect2.core.MAX_UNAUTHORIZED_RETRY_COUNT,
              retryCallback: (err2, data2) => callbacks.failure(formatRetryError(err2), data2),
              defaultCallback: (err2, data2) => callbacks.authFailure(formatRetryError(err2), data2)
            };
            switch (retryableError) {
              case connect2.RetryableErrors.UNAUTHORIZED:
                break;
              case connect2.RetryableErrors.ACCESS_DENIED:
                retryParams = {
                  ...retryParams,
                  maxCount: connect2.core.MAX_ACCESS_DENIED_RETRY_COUNT,
                  failCounter: self2.accessDeniedFailCounter,
                  increaseCounter: () => self2.accessDeniedFailCounter += 1,
                  resetCounter: () => self2.accessDeniedFailCounter = 0,
                  errorMessage: "access denied",
                  exhaustedRetries: self2.accessDeniedFailCounter >= connect2.core.MAX_ACCESS_DENIED_RETRY_COUNT,
                  defaultCallback: (err2, data2) => callbacks.accessDenied(formatRetryError(err2), data2)
                };
                break;
            }
            let errWithRetry = {
              ...err,
              retryStatus: connect2.RetryStatus.NONE
            };
            if (self2._isRetryableMethod(method)) {
              if (retryParams.exhaustedRetries) {
                log2.trace(`AWSClient: <-- Operation ${method} exhausted max ${retryParams.maxCount} number of retries for ${retryParams.errorMessage} error`).sendInternalLogToServer();
                retryParams.resetCounter();
                errWithRetry = {
                  ...errWithRetry,
                  retryStatus: connect2.RetryStatus.EXHAUSTED
                };
              } else {
                log2.trace(`AWSClient: <-- Operation ${method} failed with ${retryParams.errorMessage} error. Retrying call for a ${retryParams.failCounter + 1} time`).sendInternalLogToServer();
                retryParams.increaseCounter();
                errWithRetry = {
                  ...errWithRetry,
                  retryStatus: connect2.RetryStatus.RETRYING
                };
                retryParams.retryCallback(errWithRetry, data);
                return;
              }
            } else {
              log2.trace(`AWSClient: <-- Operation ${method} failed: ${JSON.stringify(err)}`).sendInternalLogToServer();
            }
            retryParams.defaultCallback(errWithRetry, data);
            return;
          };
          AWSClient.prototype._formatCallError = function(err) {
            const error = {
              type: err.code,
              message: err.message,
              stack: [],
              retryStatus: err.retryStatus || connect2.RetryStatus.NONE,
              ...err.statusCode && { statusCode: err.statusCode }
            };
            if (err.stack) {
              try {
                if (Array.isArray(err.stack)) {
                  error.stack = err.stack;
                } else if (typeof err.stack === "object") {
                  error.stack = [JSON.stringify(err.stack)];
                } else if (typeof err.stack === "string") {
                  error.stack = err.stack.split("\n");
                }
              } finally {
              }
            }
            return error;
          };
          AWSClient.prototype._addStatusCodeToError = function(err) {
            if (err.statusCode)
              return err;
            const error = { ...err };
            if (!err.code) {
              error.statusCode = 400;
            } else {
              switch (error.code) {
                case connect2.CTIExceptions.UNAUTHORIZED_EXCEPTION:
                  error.statusCode = 401;
                  break;
                case connect2.CTIExceptions.ACCESS_DENIED_EXCEPTION:
                  error.statusCode = 403;
                  break;
              }
            }
            return error;
          };
          AWSClient.prototype._requiresAuthenticationParam = function(method) {
            return method !== connect2.ClientMethods.COMPLETE_CONTACT && method !== connect2.ClientMethods.CLEAR_CONTACT && method !== connect2.ClientMethods.REJECT_CONTACT && method !== connect2.ClientMethods.CREATE_TASK_CONTACT && method !== connect2.ClientMethods.UPDATE_MONITOR_PARTICIPANT_STATE;
          };
          AWSClient.prototype._translateParams = function(method, params) {
            switch (method) {
              case connect2.ClientMethods.UPDATE_AGENT_CONFIGURATION:
                params.configuration = this._translateAgentConfiguration(params.configuration);
                break;
              case connect2.ClientMethods.SEND_SOFTPHONE_CALL_METRICS:
                params.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(
                  params.softphoneStreamStatistics
                );
                break;
              case connect2.ClientMethods.SEND_SOFTPHONE_CALL_REPORT:
                params.report = this._translateSoftphoneCallReport(params.report);
                break;
              default:
                break;
            }
            if (this._requiresAuthenticationParam(method)) {
              params.authentication = {
                authToken: this.authToken
              };
            }
            return params;
          };
          AWSClient.prototype._translateAgentConfiguration = function(config) {
            return {
              name: config.name,
              softphoneEnabled: config.softphoneEnabled,
              softphoneAutoAccept: config.softphoneAutoAccept,
              extension: config.extension,
              routingProfile: this._translateRoutingProfile(config.routingProfile),
              agentPreferences: config.agentPreferences
            };
          };
          AWSClient.prototype._translateRoutingProfile = function(profile) {
            return {
              name: profile.name,
              routingProfileARN: profile.routingProfileARN,
              defaultOutboundQueue: this._translateQueue(profile.defaultOutboundQueue)
            };
          };
          AWSClient.prototype._translateQueue = function(queue) {
            return {
              queueARN: queue.queueARN,
              name: queue.name
            };
          };
          AWSClient.prototype._translateSoftphoneStreamStatistics = function(stats) {
            stats.forEach(function(stat) {
              if ("packetsCount" in stat) {
                stat.packetCount = stat.packetsCount;
                delete stat.packetsCount;
              }
            });
            return stats;
          };
          AWSClient.prototype._translateSoftphoneCallReport = function(report) {
            if ("handshakingTimeMillis" in report) {
              report.handshakeTimeMillis = report.handshakingTimeMillis;
              delete report.handshakingTimeMillis;
            }
            if ("preTalkingTimeMillis" in report) {
              report.preTalkTimeMillis = report.preTalkingTimeMillis;
              delete report.preTalkingTimeMillis;
            }
            if ("handshakingFailure" in report) {
              report.handshakeFailure = report.handshakingFailure;
              delete report.handshakingFailure;
            }
            if ("talkingTimeMillis" in report) {
              report.talkTimeMillis = report.talkingTimeMillis;
              delete report.talkingTimeMillis;
            }
            report.softphoneStreamStatistics = this._translateSoftphoneStreamStatistics(
              report.softphoneStreamStatistics
            );
            return report;
          };
          var TaskTemplatesClient = function(endpoint) {
            connect2.assertNotNull(endpoint, "endpoint");
            ClientBase.call(this);
            if (endpoint.includes("/task-templates")) {
              this.endpointUrl = connect2.getUrlWithProtocol(endpoint);
            } else {
              var AWSEndpoint = new AWS.Endpoint(endpoint);
              var CFPrefix = endpoint.includes(".awsapps.com") ? "/connect" : "";
              this.endpointUrl = connect2.getUrlWithProtocol(`${AWSEndpoint.host}${CFPrefix}/task-templates/api/ccp`);
            }
          };
          TaskTemplatesClient.prototype = Object.create(ClientBase.prototype);
          TaskTemplatesClient.prototype.constructor = TaskTemplatesClient;
          TaskTemplatesClient.prototype._callImpl = function(method, params, callbacks) {
            if (params && params.relatedContactId && params.relatedContactId !== null) {
              if (params.previousContactId) {
                delete params.previousContactId;
              }
            }
            connect2.assertNotNull(method, "method");
            connect2.assertNotNull(params, "params");
            var options = {
              credentials: "include",
              method: "GET",
              headers: {
                "Accept": "application/json",
                "Content-Type": "application/json",
                "x-csrf-token": "csrf"
              }
            };
            var instanceId = params.instanceId;
            var url = this.endpointUrl;
            var methods = connect2.TaskTemplatesClientMethods;
            switch (method) {
              case methods.LIST_TASK_TEMPLATES:
                url += `/proxy/instance/${instanceId}/task/template`;
                if (params.queryParams) {
                  const queryString = new URLSearchParams(params.queryParams).toString();
                  if (queryString) {
                    url += `?${queryString}`;
                  }
                }
                break;
              case methods.GET_TASK_TEMPLATE:
                connect2.assertNotNull(params.templateParams, "params.templateParams");
                const id = connect2.assertNotNull(params.templateParams.id, "params.templateParams.id");
                const version = params.templateParams.version;
                url += `/proxy/instance/${instanceId}/task/template/${id}`;
                if (version) {
                  url += `?snapshotVersion=${version}`;
                }
                break;
              case methods.CREATE_TEMPLATED_TASK:
                url += `/${method}`;
                options.body = JSON.stringify(params);
                options.method = "PUT";
                break;
              case methods.UPDATE_CONTACT:
                url += `/${method}`;
                options.body = JSON.stringify(params);
                options.method = "POST";
            }
            connect2.fetch(url, options).then(function(res) {
              callbacks.success(res);
            }).catch(function(err) {
              const reader = err.body.getReader();
              let body = "";
              const decoder = new TextDecoder();
              reader.read().then(function processText({ done, value }) {
                if (done) {
                  var error = JSON.parse(body);
                  error.status = err.status;
                  callbacks.failure(error);
                  return;
                }
                body += decoder.decode(value);
                return reader.read().then(processText);
              });
            });
          };
          connect2.ClientBase = ClientBase;
          connect2.NullClient = NullClient;
          connect2.UpstreamConduitClient = UpstreamConduitClient;
          connect2.ApiProxyClient = ApiProxyClient;
          connect2.UpstreamConduitMasterClient = UpstreamConduitMasterClient;
          connect2.AWSClient = AWSClient;
          connect2.AgentAppClient = AgentAppClient;
          connect2.TaskTemplatesClient = TaskTemplatesClient;
        })();
      }
    ),
    /***/
    895: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          connect2.core = {};
          connect2.core.initialized = false;
          connect2.version = "2.14.1";
          connect2.outerContextStreamsVersion = null;
          connect2.DEFAULT_BATCH_SIZE = 500;
          var CCP_SYN_TIMEOUT = 1e3;
          var CCP_ACK_TIMEOUT = 3e3;
          var CCP_LOAD_TIMEOUT = 5e3;
          var CCP_IFRAME_REFRESH_INTERVAL = 5e3;
          var CCP_DR_IFRAME_REFRESH_INTERVAL = 1e4;
          var CCP_IFRAME_REFRESH_LIMIT = 10;
          var CCP_IFRAME_NAME = "Amazon Connect CCP";
          var LEGACY_LOGIN_URL_PATTERN = "https://{alias}.awsapps.com/auth/?client_id={client_id}&redirect_uri={redirect}";
          var CLIENT_ID_MAP = {
            "us-east-1": "06919f4fd8ed324e"
          };
          var AUTHORIZE_ENDPOINT = "/auth/authorize";
          var LEGACY_AUTHORIZE_ENDPOINT = "/connect/auth/authorize";
          var AUTHORIZE_RETRY_INTERVAL = 2e3;
          var AUTHORIZE_MAX_RETRY = 5;
          var LEGACY_WHITELISTED_ORIGINS_ENDPOINT = "/connect/whitelisted-origins";
          var WHITELISTED_ORIGINS_ENDPOINT = "/whitelisted-origins";
          var WHITELISTED_ORIGINS_RETRY_INTERVAL = 2e3;
          var WHITELISTED_ORIGINS_MAX_RETRY = 5;
          var CSM_IFRAME_REFRESH_ATTEMPTS = "IframeRefreshAttempts";
          var CSM_IFRAME_REFRESH_ATTEMPTS_DR = "IframeRefreshAttemptsDr";
          var CSM_IFRAME_INITIALIZATION_SUCCESS = "IframeInitializationSuccess";
          var CSM_IFRAME_INITIALIZATION_SUCCESS_DR = "IframeInitializationSuccessDr";
          var CSM_IFRAME_INITIALIZATION_TIME = "IframeInitializationTime";
          var CSM_IFRAME_INITIALIZATION_TIME_DR = "IframeInitializationTimeDr";
          var CSM_SET_RINGER_DEVICE_BEFORE_INIT = "SetRingerDeviceBeforeInitRingtoneEngine";
          var CONNECTED_CCPS_SINGLE_TAB = "ConnectedCCPSingleTabCount";
          var CCP_TABS_ACROSS_BROWSER_COUNT = "CCPTabsAcrossBrowserCount";
          var MULTIPLE_INIT_SOFTPHONE_MANAGER_CALLS = "MultipleInitSoftphoneManagerCalls";
          const SNAPSHOT_RECEIVED_BY_CLIENT = "SnapshotReceivedByClient";
          const SNAPSHOT_EVENT_TRIGGER_STEP_TIME = "SnapshotEventTriggerStepTime";
          const SNAPSHOT_TOTAL_PROCESSING_TIME = "SnapshotTotalProcessingTime";
          const SNAPSHOT_COMPARISON_STEP_TIME = "SnapshotComparisonStepTime";
          const APP = {
            GUIDES: "customviews"
          };
          const sizingBucket = {
            "0-100": [0, 100],
            "101-500": [101, 500],
            "501-1000": [501, 1e3],
            "1000-3000": [1001, 3e3],
            "3001-5000": [3001, 5e3],
            "5001-10000": [5001, 1e4],
            "10001-20000": [10001, 2e4],
            "20000+": [20001, Number.MAX_SAFE_INTEGER]
          };
          connect2.numberOfConnectedCCPs = 0;
          connect2.numberOfConnectedCCPsInThisTab = 0;
          connect2.core.MAX_AUTHORIZE_RETRY_COUNT_FOR_SESSION = 3;
          connect2.core.MAX_CTI_AUTH_RETRY_COUNT = 10;
          connect2.core.ctiAuthRetryCount = 0;
          connect2.core.authorizeTimeoutId = null;
          connect2.core.ctiTimeoutId = null;
          connect2.core.MAX_UNAUTHORIZED_RETRY_COUNT = 20;
          connect2.core.MAX_ACCESS_DENIED_RETRY_COUNT = 10;
          connect2.SessionStorageKeys = connect2.makeEnum([
            "tab_id",
            "authorize_retry_count"
          ]);
          var createLoginUrl = function(params) {
            var redirect = "https://lily.us-east-1.amazonaws.com/taw/auth/code";
            connect2.assertNotNull(redirect);
            if (params.loginUrl) {
              return params.loginUrl;
            } else if (params.alias) {
              log.warn("The `alias` param is deprecated and should not be expected to function properly. Please use `ccpUrl` or `loginUrl`. See https://github.com/amazon-connect/amazon-connect-streams/blob/master/README.md#connectcoreinitccp for valid parameters.");
              return LEGACY_LOGIN_URL_PATTERN.replace("{alias}", params.alias).replace("{client_id}", CLIENT_ID_MAP["us-east-1"]).replace("{redirect}", global.encodeURIComponent(
                redirect
              ));
            } else {
              return params.ccpUrl;
            }
          };
          var getLoginUrl = function(params) {
            var redirect = "https://lily.us-east-1.amazonaws.com/taw/auth/code";
            connect2.assertNotNull(redirect);
            if (params.loginUrl) {
              return params.loginUrl;
            } else if (params.alias) {
              log.warn("The `alias` param is deprecated and should not be expected to function properly. Please use `ccpUrl` or `loginUrl`. See https://github.com/amazon-connect/amazon-connect-streams/blob/master/README.md#connectcoreinitccp for valid parameters.");
              return LEGACY_LOGIN_URL_PATTERN.replace("{alias}", params.alias).replace("{client_id}", CLIENT_ID_MAP["us-east-1"]).replace("{redirect}", global.encodeURIComponent(
                redirect
              ));
            } else {
              return params.ccpUrl;
            }
          };
          class BaseParamsStorage {
            constructor(moduleName) {
              this.key = `${moduleName}ParamsStorage::${global.location.origin}`;
            }
            get() {
              try {
                const item = global.localStorage.getItem(this.key);
                return item && JSON.parse(item);
              } catch (e) {
                connect2.getLog().error(`${this.key}:: Failed to get softphone params from local storage!`).withException(e).sendInternalLogToServer();
              }
              return null;
            }
            set(value) {
              try {
                value && global.localStorage.setItem(this.key, JSON.stringify(value));
              } catch (e) {
                connect2.getLog().error(`${this.key}:: Failed to set softphone params to local storage!`).withException(e).sendInternalLogToServer();
              }
            }
            clean() {
              global.localStorage.removeItem(this.key);
            }
          }
          class SoftphoneParamsStorage extends BaseParamsStorage {
            constructor() {
              super("Softphone");
            }
          }
          const softphoneParamsStorage = new SoftphoneParamsStorage();
          class RingtoneParamsStorage extends BaseParamsStorage {
            constructor() {
              super("Ringtone");
            }
          }
          const ringtoneParamsStorage = new RingtoneParamsStorage();
          function sanitizeDomain(url) {
            var domain = url.match(/^(?:https?:\/\/)?(?:[^@\n]+@)?(?:www\.)?([^:\/\n?]+)/ig);
            return domain.length ? domain[0] : "";
          }
          connect2.core.checkNotInitialized = function() {
            if (connect2.core.initialized) {
              var log2 = connect2.getLog();
              log2.warn("Connect core already initialized, only needs to be initialized once.").sendInternalLogToServer();
            }
          };
          var makeAgentOffline = function(agent, callbacks) {
            var offlineState = agent.getAgentStates().find(function(state) {
              return state.type === connect2.AgentStateType.OFFLINE;
            });
            agent.setState(offlineState, callbacks);
          };
          var suppressContacts = function(isSuppressed) {
            connect2.getLog().info(
              "[Disaster Recovery] Signal sharedworker to set contacts suppressor to %s for instance %s.",
              isSuppressed,
              connect2.core.region
            ).sendInternalLogToServer();
            connect2.core.getUpstream().sendUpstream(connect2.DisasterRecoveryEvents.SUPPRESS, {
              suppress: isSuppressed,
              shouldSendFailoverDownstream: false
            });
          };
          var setForceOfflineUpstream = function(offline, nextActiveArn) {
            connect2.getLog().info(
              "[DISASTER RECOVERY] Signal sharedworker to set forceOffline to %s for instance %s.",
              offline,
              connect2.core.region
            ).sendInternalLogToServer();
            connect2.core.getUpstream().sendUpstream(connect2.DisasterRecoveryEvents.FORCE_OFFLINE, {
              offline,
              nextActiveArn
            });
          };
          var forceOffline = function(shouldSoftFailover, nextActiveArn) {
            var log2 = connect2.getLog();
            const instanceIdentifier = connect2.agent.initialized ? connect2.core.getAgentDataProvider().getInstanceId() : connect2.core.region;
            log2.info(`[Disaster Recovery] Attempting to force instance ${instanceIdentifier} offline using ${shouldSoftFailover ? "soft" : "hard"} failover`).sendInternalLogToServer();
            connect2.agent(function(agent) {
              var contactClosed = 0;
              var contacts = agent.getContacts();
              var failureEncountered = false;
              if (contacts.length) {
                for (let contact of contacts) {
                  if (failureEncountered) {
                    break;
                  } else if (shouldSoftFailover && (contact.getType() === connect2.ContactType.QUEUE_CALLBACK || contact.getType() == connect2.ContactType.VOICE)) {
                    log2.info(
                      "[Disaster Recovery] Will wait to complete failover of instance %s until voice contact with ID %s is destroyed",
                      connect2.core.region,
                      contact.getContactId()
                    ).sendInternalLogToServer();
                    connect2.core.getUpstream().sendDownstream(connect2.DisasterRecoveryEvents.FAILOVER_PENDING, { nextActiveArn });
                    contact.onDestroy(function(contact2) {
                      log2.info("[Disaster Recovery] Voice contact with ID %s destroyed, continuing with failover in instance %s", contact2.getContactId(), connect2.core.region);
                      forceOffline(true, nextActiveArn);
                    });
                  } else {
                    contact.getAgentConnection().destroy({
                      success: function() {
                        if (++contactClosed === contacts.length) {
                          setForceOfflineUpstream(false, nextActiveArn);
                          makeAgentOffline(agent);
                          log2.info("[Disaster Recovery] Instance %s is now offline", connect2.core.region).sendInternalLogToServer();
                        }
                      },
                      failure: function(err) {
                        log2.warn("[Disaster Recovery] An error occured while attempting to force this instance to offline in region %s", connect2.core.region).sendInternalLogToServer();
                        log2.warn(err).sendInternalLogToServer();
                        setForceOfflineUpstream(true, nextActiveArn);
                        failureEncountered = true;
                      }
                    });
                  }
                }
              } else {
                setForceOfflineUpstream(false, nextActiveArn);
                makeAgentOffline(agent);
                log2.info("[Disaster Recovery] Instance %s is now offline", connect2.core.region).sendInternalLogToServer();
              }
            });
          };
          connect2.core.terminateCustomView = function(connectUrl, iframeSuffix = "", { resolveIframe = true, timeout = 5e3, hideIframe = true } = {}) {
            var _a;
            let appName;
            const getIframe = function(appName2, containerDOM2, iframeIdSelector2) {
              return (containerDOM2 == null ? void 0 : containerDOM2.querySelector(iframeIdSelector2)) || document.getElementById(appName2) || window.top.document.getElementById(appName2);
            };
            if (!iframeSuffix) {
              appName = `${APP.GUIDES}`;
            } else {
              appName = `${APP.GUIDES}${iframeSuffix}`;
            }
            const containerDOM = (_a = connect2.agentApp.AppRegistry.get(appName)) == null ? void 0 : _a.containerDOM;
            const iframeIdSelector = `iframe[id='${appName}']`;
            const iframe = getIframe(appName, containerDOM, iframeIdSelector);
            if (!iframe) {
              console.warn("[CustomViews] terminateCustomView operation failed due to iframe not found");
              return;
            }
            try {
              const message = { topic: "lifecycle.terminated" };
              iframe.contentWindow.postMessage(message, connectUrl);
              if (resolveIframe) {
                if (hideIframe) {
                  iframe.style.display = "none";
                }
                ;
                console.info("[CustomViews] customviews iframe hidden for resolution during termination");
                setTimeout(function() {
                  connect2.agentApp.stopApp(appName);
                  const iframe2 = getIframe(appName, containerDOM, iframeIdSelector);
                  if (!iframe2) {
                    console.info("[CustomViews] customviews application successfully stopped");
                  } else {
                    console.warn("[CustomViews] customviews application did not stop successfully in terminateCustomView operation");
                  }
                }, timeout);
              }
            } catch (error) {
              throw new Error("[CustomViews] Error in terminateCustomView: ", error);
            }
          };
          connect2.core.initDisasterRecovery = function(params, _suppressContacts, _forceOffline) {
            var log2 = connect2.getLog();
            connect2.core.region = params.region;
            connect2.core.suppressContacts = _suppressContacts || suppressContacts;
            connect2.core.forceOffline = _forceOffline || forceOffline;
            connect2.core.getUpstream().onDownstream(connect2.DisasterRecoveryEvents.SET_OFFLINE, function(data) {
              connect2.ifMaster(
                connect2.MasterTopics.FAILOVER,
                function() {
                  connect2.core.forceOffline(data && data.softFailover);
                }
              );
            });
            connect2.core.getUpstream().onUpstream(connect2.DisasterRecoveryEvents.FORCE_OFFLINE, function(data) {
              connect2.ifMaster(
                connect2.MasterTopics.FAILOVER,
                function() {
                  connect2.core.forceOffline(data && data.softFailover, data && data.nextActiveArn);
                }
              );
            });
            connect2.ifMaster(
              connect2.MasterTopics.FAILOVER,
              function() {
                log2.info("[Disaster Recovery] Initializing region %s as part of a Disaster Recovery fleet", connect2.core.region).sendInternalLogToServer();
              },
              function() {
                log2.info("[Disaster Recovery] %s already part of a Disaster Recovery fleet", connect2.core.region).sendInternalLogToServer();
              }
            );
            if (params.pollForFailover && connect2.DisasterRecoveryEvents.INIT_DR_POLLING) {
              connect2.core.getUpstream().sendUpstream(connect2.DisasterRecoveryEvents.INIT_DR_POLLING, { instanceArn: params.instanceArn, otherArn: params.otherArn, authToken: params.authToken });
            } else if (!params.isPrimary) {
              connect2.core.suppressContacts(true);
              connect2.core.forceOffline();
              log2.info("[Disaster Recovery] %s instance is set to stand-by", connect2.core.region).sendInternalLogToServer();
            } else {
              connect2.core.suppressContacts(false);
              log2.info("[Disaster Recovery] %s instance is set to primary", connect2.core.region).sendInternalLogToServer();
            }
          };
          connect2.core.init = function(params) {
            connect2.core.eventBus = new connect2.EventBus();
            connect2.core.agentDataProvider = new AgentDataProvider(connect2.core.getEventBus());
            connect2.core.initClient(params);
            connect2.core.initAgentAppClient(params);
            connect2.core.initTaskTemplatesClient(params);
            connect2.core.initialized = true;
          };
          connect2.core.initClient = function(params) {
            connect2.assertNotNull(params, "params");
            var authToken = connect2.assertNotNull(params.authToken, "params.authToken");
            var region = connect2.assertNotNull(params.region, "params.region");
            var endpoint = params.endpoint || null;
            connect2.core.client = new connect2.AWSClient(authToken, region, endpoint);
          };
          connect2.core.initAgentAppClient = function(params) {
            connect2.assertNotNull(params, "params");
            var authToken = connect2.assertNotNull(params.authToken, "params.authToken");
            var authCookieName = connect2.assertNotNull(params.authCookieName, "params.authCookieName");
            var endpoint = connect2.assertNotNull(params.agentAppEndpoint, "params.agentAppEndpoint");
            connect2.core.agentAppClient = new connect2.AgentAppClient(authCookieName, authToken, endpoint);
          };
          connect2.core.initTaskTemplatesClient = function(params) {
            connect2.assertNotNull(params, "params");
            var endpoint = params.taskTemplatesEndpoint || params.endpoint;
            connect2.assertNotNull(endpoint, "taskTemplatesEndpoint");
            connect2.core.taskTemplatesClient = new connect2.TaskTemplatesClient(endpoint);
          };
          connect2.core.terminate = function() {
            connect2.core.client = new connect2.NullClient();
            connect2.core.apiProxyClient = new connect2.NullClient();
            connect2.core.agentAppClient = new connect2.NullClient();
            connect2.core.taskTemplatesClient = new connect2.NullClient();
            connect2.core.masterClient = new connect2.NullClient();
            var bus = connect2.core.getEventBus();
            if (bus)
              bus.unsubscribeAll();
            connect2.core.bus = new connect2.EventBus();
            connect2.core.agentDataProvider = null;
            connect2.core.softphoneManager = null;
            connect2.core.upstream = null;
            connect2.core.keepaliveManager = null;
            connect2.storageAccess.resetStorageAccessState();
            connect2.agent.initialized = false;
            connect2.core.initialized = false;
          };
          connect2.core.softphoneUserMediaStream = null;
          connect2.core.setSoftphoneUserMediaStream = function(stream) {
            connect2.core.softphoneUserMediaStream = stream;
          };
          connect2.core.initRingtoneEngines = function(params, _setRingerDevice) {
            connect2.getLog().info("[Ringtone Engine] initRingtoneEngine started").withObject({ params }).sendInternalLogToServer();
            connect2.assertNotNull(params, "params");
            const setRingerDeviceFunc = _setRingerDevice || setRingerDevice;
            var setupRingtoneEngines = function(ringtoneSettings) {
              connect2.assertNotNull(ringtoneSettings, "ringtoneSettings");
              connect2.assertNotNull(ringtoneSettings.voice, "ringtoneSettings.voice");
              connect2.assertTrue(ringtoneSettings.voice.ringtoneUrl || ringtoneSettings.voice.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.voice.disabled must be true");
              connect2.assertNotNull(ringtoneSettings.queue_callback, "ringtoneSettings.queue_callback");
              connect2.assertTrue(ringtoneSettings.queue_callback.ringtoneUrl || ringtoneSettings.queue_callback.disabled, "ringtoneSettings.voice.ringtoneUrl must be provided or ringtoneSettings.queue_callback.disabled must be true");
              connect2.core.ringtoneEngines = {};
              connect2.agent(function(agent) {
                agent.onRefresh(function() {
                  connect2.ifMaster(connect2.MasterTopics.RINGTONE, function() {
                    let isInitializedAnyEngine = false;
                    if (!ringtoneSettings.voice.disabled && !connect2.core.ringtoneEngines.voice) {
                      connect2.core.ringtoneEngines.voice = new connect2.VoiceRingtoneEngine(ringtoneSettings.voice);
                      isInitializedAnyEngine = true;
                      connect2.getLog().info("VoiceRingtoneEngine initialized.").sendInternalLogToServer();
                    }
                    if (!ringtoneSettings.chat.disabled && !connect2.core.ringtoneEngines.chat) {
                      connect2.core.ringtoneEngines.chat = new connect2.ChatRingtoneEngine(ringtoneSettings.chat);
                      isInitializedAnyEngine = true;
                      connect2.getLog().info("ChatRingtoneEngine initialized.").sendInternalLogToServer();
                    }
                    if (!ringtoneSettings.task.disabled && !connect2.core.ringtoneEngines.task) {
                      connect2.core.ringtoneEngines.task = new connect2.TaskRingtoneEngine(ringtoneSettings.task);
                      isInitializedAnyEngine = true;
                      connect2.getLog().info("TaskRingtoneEngine initialized.").sendInternalLogToServer();
                    }
                    if (!ringtoneSettings.queue_callback.disabled && !connect2.core.ringtoneEngines.queue_callback) {
                      connect2.core.ringtoneEngines.queue_callback = new connect2.QueueCallbackRingtoneEngine(ringtoneSettings.queue_callback);
                      isInitializedAnyEngine = true;
                      connect2.getLog().info("QueueCallbackRingtoneEngine initialized.").sendInternalLogToServer();
                    }
                    if (isInitializedAnyEngine && connect2.core._ringerDeviceId) {
                      setRingerDeviceFunc({ deviceId: connect2.core._ringerDeviceId });
                    }
                  });
                });
              });
              handleRingerDeviceChange();
            };
            var mergeParams = function(params2, otherParams) {
              params2.ringtone = params2.ringtone || {};
              params2.ringtone.voice = params2.ringtone.voice || {};
              params2.ringtone.queue_callback = params2.ringtone.queue_callback || {};
              params2.ringtone.chat = params2.ringtone.chat || { disabled: true };
              params2.ringtone.task = params2.ringtone.task || { disabled: true };
              if (otherParams.softphone) {
                if (otherParams.softphone.disableRingtone) {
                  params2.ringtone.voice.disabled = true;
                  params2.ringtone.queue_callback.disabled = true;
                }
                if (otherParams.softphone.ringtoneUrl) {
                  params2.ringtone.voice.ringtoneUrl = otherParams.softphone.ringtoneUrl;
                  params2.ringtone.queue_callback.ringtoneUrl = otherParams.softphone.ringtoneUrl;
                }
              }
              if (otherParams.chat) {
                if (otherParams.chat.disableRingtone) {
                  params2.ringtone.chat.disabled = true;
                }
                if (otherParams.chat.ringtoneUrl) {
                  params2.ringtone.chat.ringtoneUrl = otherParams.chat.ringtoneUrl;
                }
              }
              if (otherParams.task) {
                if (otherParams.task.disableRingtone) {
                  params2.ringtone.task.disabled = true;
                }
                if (otherParams.task.ringtoneUrl) {
                  params2.ringtone.task.ringtoneUrl = otherParams.task.ringtoneUrl;
                }
              }
              if (otherParams.ringtone) {
                params2.ringtone.voice = connect2.merge(
                  params2.ringtone.voice,
                  otherParams.ringtone.voice || {}
                );
                params2.ringtone.queue_callback = connect2.merge(
                  params2.ringtone.queue_callback,
                  otherParams.ringtone.voice || {}
                );
                params2.ringtone.chat = connect2.merge(
                  params2.ringtone.chat,
                  otherParams.ringtone.chat || {}
                );
                params2.ringtone.task = connect2.merge(
                  params2.ringtone.task,
                  otherParams.ringtone.task || {}
                );
              }
            };
            mergeParams(params, params);
            if (connect2.isFramed()) {
              let configureMessageTimer;
              var bus = connect2.core.getEventBus();
              bus.subscribe(connect2.EventType.CONFIGURE, function(data) {
                global.clearTimeout(configureMessageTimer);
                connect2.getLog().info("[Ringtone Engine] Configure event handler executed").sendInternalLogToServer();
                this.unsubscribe();
                mergeParams(params, data);
                ringtoneParamsStorage.set(params.ringtone);
                setupRingtoneEngines(params.ringtone);
              });
              const ringtoneParamsFromLocalStorage = ringtoneParamsStorage.get();
              if (ringtoneParamsFromLocalStorage) {
                connect2.core.getUpstream().onUpstream(connect2.EventType.ACKNOWLEDGE, function(args) {
                  const ackFromSharedWorker = args && args.id;
                  if (ackFromSharedWorker) {
                    connect2.getLog().info("[RingtoneEngine] Embedded CCP is refreshed successfully and waiting for configure Message handler to execute").sendInternalLogToServer();
                    this.unsubscribe();
                    configureMessageTimer = global.setTimeout(() => {
                      connect2.getLog().info("[RingtoneEngine] Embedded CCP is refreshed without configure message & Initializing setupRingtoneEngines (Ringtone Engine) from localStorage ringtone params. ").withObject({ ringtone: ringtoneParamsFromLocalStorage }).sendInternalLogToServer();
                      setupRingtoneEngines(ringtoneParamsFromLocalStorage);
                    }, 100);
                  }
                });
              }
            } else {
              setupRingtoneEngines(params.ringtone);
            }
          };
          var handleRingerDeviceChange = function() {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.ConfigurationEvents.SET_RINGER_DEVICE, setRingerDevice);
          };
          var setRingerDevice = function(data = {}) {
            const deviceId = data.deviceId || "";
            connect2.getLog().info(`[Audio Device Settings] Attempting to set ringer device ${deviceId}`).sendInternalLogToServer();
            if (connect2.keys(connect2.core.ringtoneEngines).length === 0) {
              connect2.getLog().info("[Audio Device Settings] setRingerDevice called before ringtone engine is initialized").sendInternalLogToServer();
              if (deviceId) {
                connect2.core._ringerDeviceId = deviceId;
                connect2.getLog().warn("[Audio Device Settings] stored device Id for later use, once ringtone engine is up.").sendInternalLogToServer();
                connect2.publishMetric({
                  name: CSM_SET_RINGER_DEVICE_BEFORE_INIT,
                  data: { count: 1 }
                });
              }
              return;
            }
            if (!deviceId) {
              connect2.getLog().warn("[Audio Device Settings] Setting ringer device cancelled due to missing deviceId").sendInternalLogToServer();
              return;
            }
            for (let ringtoneType in connect2.core.ringtoneEngines) {
              connect2.core.ringtoneEngines[ringtoneType].setOutputDevice(deviceId).then(function(res) {
                connect2.getLog().info(`[Audio Device Settings] ringtoneType ${ringtoneType} successfully set to deviceid ${res}`).sendInternalLogToServer();
              }).catch(function(err) {
                connect2.getLog().error(err);
              });
            }
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ConfigurationEvents.RINGER_DEVICE_CHANGED,
              data: { deviceId }
            });
          };
          connect2.core.initSoftphoneManager = function(paramsIn) {
            var params = paramsIn || {};
            connect2.getLog().info("[Softphone Manager] initSoftphoneManager started").sendInternalLogToServer();
            var competeForMasterOnAgentUpdate = function(softphoneParamsIn) {
              var softphoneParams = connect2.merge(params.softphone || {}, softphoneParamsIn);
              connect2.getLog().info("[Softphone Manager] competeForMasterOnAgentUpdate executed").withObject({ softphoneParams }).sendInternalLogToServer();
              connect2.agent(function(agent) {
                if (!agent.getChannelConcurrency(connect2.ChannelType.VOICE)) {
                  return;
                }
                agent.onRefresh(function() {
                  var sub = this;
                  connect2.getLog().info("[Softphone Manager] agent refresh handler executed").sendInternalLogToServer();
                  connect2.ifMaster(connect2.MasterTopics.SOFTPHONE, function() {
                    connect2.getLog().info("[Softphone Manager] confirmed as softphone master topic").sendInternalLogToServer();
                    if (!connect2.core.softphoneManager && agent.isSoftphoneEnabled()) {
                      connect2.becomeMaster(connect2.MasterTopics.SEND_LOGS);
                      connect2.core.softphoneManager = new connect2.SoftphoneManager(softphoneParams);
                      sub.unsubscribe();
                    }
                  });
                });
              });
            };
            if (connect2.isFramed() && connect2.isCCP()) {
              let configureMessageTimer;
              var bus = connect2.core.getEventBus();
              bus.subscribe(connect2.EventType.CONFIGURE, function(data) {
                global.clearTimeout(configureMessageTimer);
                connect2.getLog().info("[Softphone Manager] Configure event handler executed").withObject({ data }).sendInternalLogToServer();
                softphoneParamsStorage.set(data.softphone);
                if (data.softphone && data.softphone.allowFramedSoftphone) {
                  this.unsubscribe();
                  competeForMasterOnAgentUpdate(data.softphone);
                }
                setupEventListenersForMultiTabUseInFirefox(data.softphone);
              });
              let softphoneParamsFromLocalStorage = softphoneParamsStorage.get();
              if (softphoneParamsFromLocalStorage) {
                connect2.core.getUpstream().onUpstream(connect2.EventType.ACKNOWLEDGE, function(args) {
                  let ackFromSharedWorker = args && args.id;
                  if (ackFromSharedWorker) {
                    connect2.getLog().info("[Softphone Manager] Embedded CCP is refreshed successfully and waiting for configure Message handler to execute").sendInternalLogToServer();
                    this.unsubscribe();
                    configureMessageTimer = global.setTimeout(() => {
                      connect2.getLog().info("[Softphone Manager] Embedded CCP is refreshed without configure message handler execution").withObject({ softphoneParamsFromLocalStorage }).sendInternalLogToServer();
                      connect2.publishMetric({
                        name: "EmbeddedCCPRefreshedWithoutInitCCP",
                        data: { count: 1 }
                      });
                      setupEventListenersForMultiTabUseInFirefox(softphoneParamsFromLocalStorage);
                      if (softphoneParamsFromLocalStorage.allowFramedSoftphone) {
                        connect2.getLog().info("[Softphone Manager] Embedded CCP is refreshed & Initializing competeForMasterOnAgentUpdate (Softphone manager) from localStorage softphone params").sendInternalLogToServer();
                        competeForMasterOnAgentUpdate(softphoneParamsFromLocalStorage);
                      }
                    }, 100);
                  }
                });
              }
            } else {
              competeForMasterOnAgentUpdate(params);
              setupEventListenersForMultiTabUseInFirefox(params);
            }
            connect2.agent(function(agent) {
              if (agent.isSoftphoneEnabled() && agent.getChannelConcurrency(connect2.ChannelType.VOICE)) {
                connect2.core.getUpstream().sendUpstream(
                  connect2.EventType.BROADCAST,
                  {
                    event: connect2.EventType.MUTE
                  }
                );
              }
            });
            function setupEventListenersForMultiTabUseInFirefox(softphoneParamsIn) {
              var softphoneParams = connect2.merge(params.softphone || {}, softphoneParamsIn);
              connect2.core.softphoneParams = softphoneParams;
              if (connect2.isFirefoxBrowser()) {
                connect2.core.getUpstream().onUpstream(connect2.EventType.MASTER_RESPONSE, function(res) {
                  if (res.data && res.data.topic === connect2.MasterTopics.SOFTPHONE && res.data.takeOver && res.data.masterId !== connect2.core.portStreamId) {
                    if (connect2.core.softphoneManager) {
                      connect2.core.softphoneManager.onInitContactSub.unsubscribe();
                      delete connect2.core.softphoneManager;
                    }
                  }
                });
                connect2.core.getEventBus().subscribe(connect2.ConnectionEvents.READY_TO_START_SESSION, function() {
                  connect2.ifMaster(connect2.MasterTopics.SOFTPHONE, function() {
                    if (connect2.core.softphoneManager) {
                      connect2.core.softphoneManager.startSession();
                    }
                  }, function() {
                    connect2.becomeMaster(connect2.MasterTopics.SOFTPHONE, function() {
                      connect2.agent(function(agent) {
                        if (!connect2.core.softphoneManager && agent.isSoftphoneEnabled()) {
                          connect2.becomeMaster(connect2.MasterTopics.SEND_LOGS);
                          connect2.core.softphoneManager = new connect2.SoftphoneManager(softphoneParams);
                          connect2.core.softphoneManager.startSession();
                        }
                      });
                    });
                  });
                });
                connect2.contact(function(c) {
                  connect2.agent(function(agent) {
                    c.onRefresh(function(contact) {
                      if (connect2.hasOtherConnectedCCPs() && document.visibilityState === "visible" && (contact.getStatus().type === connect2.ContactStatusType.CONNECTING || contact.getStatus().type === connect2.ContactStatusType.INCOMING)) {
                        var isOutBoundCall = contact.isSoftphoneCall() && !contact.isInbound();
                        var isAutoAcceptEnabled = contact.isSoftphoneCall() && agent.getConfiguration().softphoneAutoAccept;
                        var isQueuedCallback = contact.getType() === connect2.ContactType.QUEUE_CALLBACK;
                        if (isOutBoundCall || isAutoAcceptEnabled || isQueuedCallback) {
                          connect2.core.triggerReadyToStartSessionEvent();
                        }
                      }
                    });
                  });
                });
              }
            }
          };
          connect2.core.triggerReadyToStartSessionEvent = function() {
            var allowFramedSoftphone = connect2.core.softphoneParams && connect2.core.softphoneParams.allowFramedSoftphone;
            if (connect2.isCCP()) {
              if (allowFramedSoftphone) {
                connect2.core.getEventBus().trigger(connect2.ConnectionEvents.READY_TO_START_SESSION);
              } else {
                if (connect2.isFramed()) {
                  connect2.core.getUpstream().sendDownstream(connect2.ConnectionEvents.READY_TO_START_SESSION);
                } else {
                  connect2.core.getEventBus().trigger(connect2.ConnectionEvents.READY_TO_START_SESSION);
                }
              }
            } else {
              if (allowFramedSoftphone) {
                connect2.core.getUpstream().sendUpstream(connect2.ConnectionEvents.READY_TO_START_SESSION);
              } else {
                connect2.core.getEventBus().trigger(connect2.ConnectionEvents.READY_TO_START_SESSION);
              }
            }
          };
          connect2.core.initPageOptions = function(params) {
            connect2.assertNotNull(params, "params");
            if (connect2.isFramed()) {
              var bus = connect2.core.getEventBus();
              bus.subscribe(connect2.EventType.CONFIGURE, function(data) {
                connect2.core.getUpstream().sendUpstream(
                  connect2.EventType.BROADCAST,
                  {
                    event: connect2.ConfigurationEvents.CONFIGURE,
                    data
                  }
                );
              });
              bus.subscribe(connect2.EventType.MEDIA_DEVICE_REQUEST, function() {
                function sendDevices(devices2) {
                  connect2.core.getUpstream().sendDownstream(connect2.EventType.MEDIA_DEVICE_RESPONSE, devices2);
                }
                if (navigator && navigator.mediaDevices) {
                  navigator.mediaDevices.enumerateDevices().then(function(devicesIn) {
                    devices = devicesIn || [];
                    devices = devices.map(function(d) {
                      return d.toJSON();
                    });
                    sendDevices(devices);
                  }).catch(function(err) {
                    sendDevices({ error: err.message });
                  });
                } else {
                  sendDevices({ error: "No navigator or navigator.mediaDevices object found" });
                }
              });
            }
          };
          connect2.core.initApiProxyService = function() {
            connect2.core.apiProxyClient = new connect2.ApiProxyClient();
            if (connect2.isFramed()) {
              connect2.core.handleApiProxyRequest = function(request) {
                if (!(request == null ? void 0 : request.method))
                  return;
                const successCB = function(data) {
                  const response = { data, requestId: request.requestId };
                  connect2.core.getUpstream().sendDownstream(connect2.EventType.API_RESPONSE, response);
                };
                const failureCB = function(err) {
                  const response = { err, requestId: request.requestId };
                  connect2.core.getUpstream().sendDownstream(connect2.EventType.API_RESPONSE, response);
                };
                const client = connect2.core.getApiProxyClient();
                client.call(request.method, request.params, { success: successCB, failure: failureCB });
              };
            }
          };
          connect2.core.getFrameMediaDevices = function(timeoutIn) {
            var sub = null;
            var timeout = timeoutIn || 1e3;
            var timeoutPromise = new Promise(function(resolve, reject) {
              setTimeout(function() {
                reject(new Error("Timeout exceeded"));
              }, timeout);
            });
            var mediaDevicesPromise = new Promise(function(resolve, reject) {
              if (connect2.isCCP()) {
                if (navigator && navigator.mediaDevices) {
                  navigator.mediaDevices.enumerateDevices().then(function(devicesIn) {
                    devices = devicesIn || [];
                    devices = devices.map(function(d) {
                      return d.toJSON();
                    });
                    resolve(devices);
                  });
                } else {
                  reject(new Error("No navigator or navigator.mediaDevices object found"));
                }
              } else {
                var bus = connect2.core.getEventBus();
                sub = bus.subscribe(connect2.EventType.MEDIA_DEVICE_RESPONSE, function(data) {
                  if (data.error) {
                    reject(new Error(data.error));
                  } else {
                    resolve(data);
                  }
                });
                connect2.core.getUpstream().sendUpstream(connect2.EventType.MEDIA_DEVICE_REQUEST);
              }
            });
            return Promise.race([mediaDevicesPromise, timeoutPromise]).finally(function() {
              if (sub) {
                sub.unsubscribe();
              }
            });
          };
          connect2.core.authorize = function(endpoint) {
            var options = {
              credentials: "include"
            };
            var authorizeEndpoint = endpoint;
            if (!authorizeEndpoint) {
              authorizeEndpoint = connect2.core.isLegacyDomain() ? LEGACY_AUTHORIZE_ENDPOINT : AUTHORIZE_ENDPOINT;
            }
            return connect2.fetch(authorizeEndpoint, options, AUTHORIZE_RETRY_INTERVAL, AUTHORIZE_MAX_RETRY);
          };
          connect2.core.verifyDomainAccess = function(authToken, endpoint) {
            connect2.getLog().warn("This API will be deprecated in the next major version release");
            if (!connect2.isFramed()) {
              return Promise.resolve();
            }
            var options = {
              headers: {
                "X-Amz-Bearer": authToken
              }
            };
            var whitelistedOriginsEndpoint = null;
            if (endpoint) {
              whitelistedOriginsEndpoint = endpoint;
            } else {
              whitelistedOriginsEndpoint = connect2.core.isLegacyDomain() ? LEGACY_WHITELISTED_ORIGINS_ENDPOINT : WHITELISTED_ORIGINS_ENDPOINT;
            }
            return connect2.fetch(whitelistedOriginsEndpoint, options, WHITELISTED_ORIGINS_RETRY_INTERVAL, WHITELISTED_ORIGINS_MAX_RETRY).then(function(response) {
              var topDomain = sanitizeDomain(window.document.referrer);
              var isAllowed = response.whitelistedOrigins.some(function(origin) {
                return topDomain === sanitizeDomain(origin);
              });
              return isAllowed ? Promise.resolve() : Promise.reject();
            });
          };
          connect2.core.isLegacyDomain = function(url) {
            url = url || window.location.href;
            return url.includes(".awsapps.com");
          };
          connect2.core.initSharedWorker = function(params) {
            connect2.core.checkNotInitialized();
            if (connect2.core.initialized) {
              return;
            }
            connect2.assertNotNull(params, "params");
            var sharedWorkerUrl = connect2.assertNotNull(params.sharedWorkerUrl, "params.sharedWorkerUrl");
            var authToken = connect2.assertNotNull(params.authToken, "params.authToken");
            var refreshToken = connect2.assertNotNull(params.refreshToken, "params.refreshToken");
            var authTokenExpiration = connect2.assertNotNull(params.authTokenExpiration, "params.authTokenExpiration");
            var region = connect2.assertNotNull(params.region, "params.region");
            var endpoint = params.endpoint || null;
            var authorizeEndpoint = params.authorizeEndpoint;
            if (!authorizeEndpoint) {
              authorizeEndpoint = connect2.core.isLegacyDomain() ? LEGACY_AUTHORIZE_ENDPOINT : AUTHORIZE_ENDPOINT;
            }
            var agentAppEndpoint = params.agentAppEndpoint || null;
            var taskTemplatesEndpoint = params.taskTemplatesEndpoint || null;
            var authCookieName = params.authCookieName || null;
            try {
              connect2.core.eventBus = new connect2.EventBus({ logEvents: true });
              connect2.core.agentDataProvider = new AgentDataProvider(connect2.core.getEventBus());
              connect2.core.mediaFactory = new connect2.MediaFactory(params);
              var worker = new SharedWorker(sharedWorkerUrl, "ConnectSharedWorker");
              var conduit = new connect2.Conduit(
                "ConnectSharedWorkerConduit",
                new connect2.PortStream(worker.port),
                new connect2.WindowIOStream(window, parent)
              );
              connect2.core.upstream = conduit;
              connect2.core.webSocketProvider = new WebSocketProvider();
              global.onunload = function() {
                conduit.sendUpstream(connect2.EventType.CLOSE);
                worker.port.close();
              };
              connect2.getLog().scheduleUpstreamLogPush(conduit);
              connect2.getLog().scheduleDownstreamClientSideLogsPush();
              conduit.onAllUpstream(connect2.core.getEventBus().bridge());
              conduit.onAllUpstream(conduit.passDownstream());
              if (connect2.isFramed()) {
                conduit.onAllDownstream(connect2.core.getEventBus().bridge());
                conduit.onAllDownstream(function(data, eventName) {
                  if (eventName === connect2.EventType.API_REQUEST && connect2.containsValue(connect2.ApiProxyClientMethods, data == null ? void 0 : data.method)) {
                    connect2.core.handleApiProxyRequest(data);
                  } else
                    conduit.passUpstream()(data, eventName);
                });
              }
              conduit.sendUpstream(connect2.EventType.CONFIGURE, {
                authToken,
                authTokenExpiration,
                endpoint,
                refreshToken,
                region,
                authorizeEndpoint,
                agentAppEndpoint,
                taskTemplatesEndpoint,
                authCookieName,
                longPollingOptions: params.longPollingOptions || void 0
              });
              conduit.onUpstream(connect2.EventType.ACKNOWLEDGE, function(data) {
                connect2.getLog().info("Acknowledged by the ConnectSharedWorker!").sendInternalLogToServer();
                connect2.core.initialized = true;
                connect2.core._setTabId();
                connect2.core.portStreamId = data.id;
                this.unsubscribe();
              });
              conduit.onUpstream(connect2.EventType.LOG, function(logEntry) {
                if (logEntry.loggerId !== connect2.getLog().getLoggerId()) {
                  connect2.getLog().addLogEntry(connect2.LogEntry.fromObject(logEntry));
                }
              });
              conduit.onUpstream(connect2.EventType.SERVER_BOUND_INTERNAL_LOG, function(logEntry) {
                connect2.getLog().sendInternalLogEntryToServer(connect2.LogEntry.fromObject(logEntry));
              });
              conduit.onDownstream(connect2.EventType.SERVER_BOUND_INTERNAL_LOG, function(logs) {
                if (connect2.isFramed() && Array.isArray(logs)) {
                  logs.forEach(function(log2) {
                    connect2.getLog().sendInternalLogEntryToServer(connect2.LogEntry.fromObject(log2));
                  });
                }
              });
              conduit.onDownstream(connect2.EventType.LOG, function(log2) {
                if (connect2.isFramed() && log2.loggerId !== connect2.getLog().getLoggerId()) {
                  connect2.getLog().addLogEntry(connect2.LogEntry.fromObject(log2));
                }
              });
              connect2.core.onAuthFail(connect2.hitch(connect2.core, connect2.core._handleAuthFail, params.loginEndpoint || null, authorizeEndpoint));
              connect2.core.onAuthorizeSuccess(connect2.hitch(connect2.core, connect2.core._handleAuthorizeSuccess));
              connect2.getLog().info("User Agent: " + navigator.userAgent).sendInternalLogToServer();
              connect2.getLog().info("isCCPv2: true").sendInternalLogToServer();
              connect2.getLog().info("isFramed: " + connect2.isFramed()).sendInternalLogToServer();
              connect2.core.upstream.onDownstream(connect2.EventType.OUTER_CONTEXT_INFO, function(data) {
                var streamsVersion = data.streamsVersion || null;
                connect2.getLog().info("StreamsJS Version: " + streamsVersion).sendInternalLogToServer();
                connect2.outerContextStreamsVersion = streamsVersion;
              });
              conduit.onUpstream(connect2.EventType.UPDATE_CONNECTED_CCPS, function(data) {
                connect2.getLog().info("Number of connected CCPs updated: " + data.length).sendInternalLogToServer();
                connect2.numberOfConnectedCCPs = data.length;
                if (data[connect2.core.tabId] && !isNaN(data[connect2.core.tabId].length)) {
                  if (connect2.numberOfConnectedCCPsInThisTab !== data[connect2.core.tabId].length) {
                    connect2.numberOfConnectedCCPsInThisTab = data[connect2.core.tabId].length;
                    if (connect2.numberOfConnectedCCPsInThisTab > 1) {
                      connect2.getLog().warn("There are " + connect2.numberOfConnectedCCPsInThisTab + " connected CCPs in this tab. Please adjust your implementation to avoid complications. If you are embedding CCP, please do so exclusively with initCCP. InitCCP will not let you embed more than one CCP.").sendInternalLogToServer();
                    }
                    connect2.publishMetric({
                      name: CONNECTED_CCPS_SINGLE_TAB,
                      data: { count: connect2.numberOfConnectedCCPsInThisTab }
                    });
                  }
                }
                if (data.tabId && data.streamsTabsAcrossBrowser) {
                  connect2.ifMaster(
                    connect2.MasterTopics.METRICS,
                    () => connect2.agent(() => connect2.publishMetric({
                      name: CCP_TABS_ACROSS_BROWSER_COUNT,
                      data: { tabId: data.tabId, count: data.streamsTabsAcrossBrowser }
                    }))
                  );
                }
              });
              connect2.core.client = new connect2.UpstreamConduitClient(conduit);
              connect2.core.masterClient = new connect2.UpstreamConduitMasterClient(conduit);
              connect2.core.getEventBus().subscribe(
                connect2.EventType.TERMINATE,
                conduit.passUpstream()
              );
              connect2.core.getEventBus().subscribe(connect2.EventType.TERMINATED, function() {
                window.location.reload(true);
              });
              worker.port.start();
              conduit.onUpstream(connect2.VoiceIdEvents.UPDATE_DOMAIN_ID, function(data) {
                if (data && data.domainId) {
                  connect2.core.voiceIdDomainId = data.domainId;
                }
              });
              connect2.agent(function() {
                var voiceId = new connect2.VoiceId();
                voiceId.getDomainId().then(function(domainId) {
                  connect2.getLog().info("voiceId domainId successfully fetched at agent initialization: " + domainId).sendInternalLogToServer();
                }).catch(function(err) {
                  connect2.getLog().info("voiceId domainId not fetched at agent initialization").withObject({ err }).sendInternalLogToServer();
                });
              });
              var nm = connect2.core.getNotificationManager();
              nm.requestPermission();
              conduit.onDownstream(connect2.DisasterRecoveryEvents.INIT_DISASTER_RECOVERY, function(params2) {
                connect2.core.initDisasterRecovery(params2);
              });
            } catch (e) {
              connect2.getLog().error("Failed to initialize the API shared worker, we're dead!").withException(e).sendInternalLogToServer();
            }
          };
          connect2.core._setTabId = function() {
            try {
              connect2.core.tabId = window.sessionStorage.getItem(connect2.SessionStorageKeys.TAB_ID);
              if (!connect2.core.tabId) {
                connect2.core.tabId = connect2.randomId();
                window.sessionStorage.setItem(connect2.SessionStorageKeys.TAB_ID, connect2.core.tabId);
              }
              connect2.core.upstream.sendUpstream(connect2.EventType.TAB_ID, { tabId: connect2.core.tabId });
            } catch (e) {
              connect2.getLog().error("[Tab Id] There was an issue setting the tab Id").withException(e).sendInternalLogToServer();
            }
          };
          connect2.core.initCCP = function(containerDiv, paramsIn) {
            var _a;
            connect2.core.checkNotInitialized();
            if (connect2.core.initialized) {
              return;
            }
            connect2.getLog().info("Iframe initialization started").sendInternalLogToServer();
            var initStartTime = Date.now();
            try {
              if (connect2.core._getCCPIframe()) {
                connect2.getLog().error("Attempted to call initCCP when an iframe generated by initCCP already exists").sendInternalLogToServer();
                return;
              }
            } catch (e) {
              connect2.getLog().error("Error while checking if initCCP has already been called").withException(e).sendInternalLogToServer();
            }
            var params = {};
            if (typeof paramsIn === "string") {
              params.ccpUrl = paramsIn;
            } else {
              params = paramsIn;
            }
            connect2.assertNotNull(containerDiv, "containerDiv");
            connect2.assertNotNull(params.ccpUrl, "params.ccpUrl");
            if (!((_a = params.softphone) == null ? void 0 : _a.disableStoringParamsInLocalStorage)) {
              softphoneParamsStorage.clean();
              ringtoneParamsStorage.clean();
            }
            connect2.storageAccess.init(params.ccpUrl, containerDiv, params.storageAccess || {});
            var iframe = connect2.core._createCCPIframe(containerDiv, params);
            var conduit = new connect2.IFrameConduit(params.ccpUrl, window, iframe);
            connect2.core.upstream = conduit;
            connect2.core.eventBus = new connect2.EventBus({ logEvents: false });
            if (connect2.storageAccess.canRequest()) {
              connect2.storageAccess.setupRequestHandlers({ onGrant: setupInitCCP });
            } else {
              setupInitCCP();
            }
            function setupInitCCP() {
              connect2.core.agentDataProvider = new AgentDataProvider(connect2.core.getEventBus());
              connect2.core.mediaFactory = new connect2.MediaFactory(params);
              connect2.core._sendIframeStyleDataUpstreamAfterReasonableWaitTime(iframe, conduit);
              connect2.core.webSocketProvider = new WebSocketProvider();
              conduit.onAllUpstream(connect2.core.getEventBus().bridge());
              connect2.core.keepaliveManager = new KeepaliveManager(
                conduit,
                connect2.core.getEventBus(),
                params.ccpSynTimeout || CCP_SYN_TIMEOUT,
                params.ccpAckTimeout || CCP_ACK_TIMEOUT
              );
              connect2.core.iframeRefreshTimeout = null;
              connect2.core.ccpLoadTimeoutInstance = global.setTimeout(function() {
                connect2.core.ccpLoadTimeoutInstance = null;
                connect2.core.getEventBus().trigger(connect2.EventType.ACK_TIMEOUT);
                connect2.getLog().info("CCP LoadTimeout triggered").sendInternalLogToServer();
              }, params.ccpLoadTimeout || CCP_LOAD_TIMEOUT);
              connect2.getLog().scheduleUpstreamOuterContextCCPLogsPush(conduit);
              connect2.getLog().scheduleUpstreamOuterContextCCPserverBoundLogsPush(conduit);
              conduit.onUpstream(connect2.EventType.ACKNOWLEDGE, function(data) {
                connect2.getLog().info("Acknowledged by the CCP!").sendInternalLogToServer();
                connect2.core.client = new connect2.UpstreamConduitClient(conduit);
                connect2.core.masterClient = new connect2.UpstreamConduitMasterClient(conduit);
                connect2.core.portStreamId = data.id;
                if (params.softphone || params.chat || params.task || params.pageOptions || params.shouldAddNamespaceToLogs || params.disasterRecoveryOn) {
                  conduit.sendUpstream(connect2.EventType.CONFIGURE, {
                    softphone: params.softphone,
                    chat: params.chat,
                    task: params.task,
                    pageOptions: params.pageOptions,
                    shouldAddNamespaceToLogs: params.shouldAddNamespaceToLogs,
                    disasterRecoveryOn: params.disasterRecoveryOn
                  });
                }
                if (params.disasterRecoveryOn) {
                  connect2.core.region = params.region;
                  connect2.core.suppressContacts = suppressContacts;
                  connect2.core.forceOffline = function(data2) {
                    conduit.sendUpstream(connect2.DisasterRecoveryEvents.SET_OFFLINE, data2);
                  };
                  conduit.sendUpstream(connect2.DisasterRecoveryEvents.INIT_DISASTER_RECOVERY, params);
                }
                if (connect2.core.ccpLoadTimeoutInstance) {
                  global.clearTimeout(connect2.core.ccpLoadTimeoutInstance);
                  connect2.core.ccpLoadTimeoutInstance = null;
                }
                conduit.sendUpstream(connect2.EventType.OUTER_CONTEXT_INFO, { streamsVersion: connect2.version });
                connect2.core.keepaliveManager.start();
                this.unsubscribe();
                connect2.core.initialized = true;
                connect2.core.getEventBus().trigger(connect2.EventType.INIT);
                if (initStartTime) {
                  var initTime = Date.now() - initStartTime;
                  var refreshAttempts = connect2.core.iframeRefreshAttempt || 0;
                  connect2.getLog().info("Iframe initialization succeeded").sendInternalLogToServer();
                  connect2.getLog().info(`Iframe initialization time ${initTime}`).sendInternalLogToServer();
                  connect2.getLog().info(`Iframe refresh attempts ${refreshAttempts}`).sendInternalLogToServer();
                  setTimeout(() => {
                    connect2.publishMetric({
                      name: CSM_IFRAME_REFRESH_ATTEMPTS,
                      data: { count: refreshAttempts }
                    });
                    connect2.publishMetric({
                      name: CSM_IFRAME_INITIALIZATION_SUCCESS,
                      data: { count: 1 }
                    });
                    connect2.publishMetric({
                      name: CSM_IFRAME_INITIALIZATION_TIME,
                      data: { count: initTime }
                    });
                    if (params.disasterRecoveryOn) {
                      connect2.publishMetric({
                        name: CSM_IFRAME_REFRESH_ATTEMPTS_DR,
                        data: { count: refreshAttempts }
                      });
                      connect2.publishMetric({
                        name: CSM_IFRAME_INITIALIZATION_SUCCESS_DR,
                        data: { count: 1 }
                      });
                      connect2.publishMetric({
                        name: CSM_IFRAME_INITIALIZATION_TIME_DR,
                        data: { count: initTime }
                      });
                    }
                    initStartTime = null;
                  }, 1e3);
                }
              });
              conduit.onUpstream(connect2.EventType.LOG, function(logEntry) {
                if (logEntry.loggerId !== connect2.getLog().getLoggerId()) {
                  connect2.getLog().addLogEntry(connect2.LogEntry.fromObject(logEntry));
                }
              });
              connect2.core.getEventBus().subscribe(connect2.EventType.ACK_TIMEOUT, function() {
                if (params.loginPopup !== false) {
                  try {
                    var loginUrl = getLoginUrl(params);
                    connect2.getLog().warn("ACK_TIMEOUT occurred, attempting to pop the login page if not already open.").sendInternalLogToServer();
                    connect2.core.loginWindow = connect2.core.getPopupManager().open(loginUrl, connect2.MasterTopics.LOGIN_POPUP, params.loginOptions);
                  } catch (e) {
                    connect2.getLog().error("ACK_TIMEOUT occurred but we are unable to open the login popup.").withException(e).sendInternalLogToServer();
                  }
                }
                if (connect2.core.iframeRefreshTimeout == null) {
                  try {
                    conduit.onUpstream(connect2.EventType.ACKNOWLEDGE, function() {
                      this.unsubscribe();
                      global.clearTimeout(connect2.core.iframeRefreshTimeout);
                      connect2.core.iframeRefreshTimeout = null;
                      if ((params.loginPopupAutoClose || params.loginOptions && params.loginOptions.autoClose) && connect2.core.loginWindow) {
                        connect2.core.loginWindow.close();
                        connect2.core.loginWindow = null;
                      }
                    });
                    connect2.core._refreshIframeOnTimeout(params, containerDiv);
                  } catch (e) {
                    connect2.getLog().error("Error occurred while refreshing iframe").withException(e).sendInternalLogToServer();
                  }
                }
              });
              if (params.onViewContact) {
                connect2.core.onViewContact(params.onViewContact);
              }
              conduit.onUpstream(connect2.EventType.UPDATE_CONNECTED_CCPS, function(data) {
                connect2.numberOfConnectedCCPs = data.length;
              });
              conduit.onUpstream(connect2.VoiceIdEvents.UPDATE_DOMAIN_ID, function(data) {
                if (data && data.domainId) {
                  connect2.core.voiceIdDomainId = data.domainId;
                }
              });
              connect2.core.getEventBus().subscribe(connect2.EventType.IFRAME_RETRIES_EXHAUSTED, function() {
                if (initStartTime) {
                  var refreshAttempts = connect2.core.iframeRefreshAttempt - 1;
                  connect2.getLog().info("Iframe initialization failed").sendInternalLogToServer();
                  connect2.getLog().info(`Time after iframe initialization started ${Date.now() - initStartTime}`).sendInternalLogToServer();
                  connect2.getLog().info(`Iframe refresh attempts ${refreshAttempts}`).sendInternalLogToServer();
                  connect2.publishMetric({
                    name: CSM_IFRAME_REFRESH_ATTEMPTS,
                    data: { count: refreshAttempts }
                  });
                  connect2.publishMetric({
                    name: CSM_IFRAME_INITIALIZATION_SUCCESS,
                    data: { count: 0 }
                  });
                  if (params.disasterRecoveryOn) {
                    connect2.publishMetric({
                      name: CSM_IFRAME_REFRESH_ATTEMPTS_DR,
                      data: { count: refreshAttempts }
                    });
                    connect2.publishMetric({
                      name: CSM_IFRAME_INITIALIZATION_SUCCESS_DR,
                      data: { count: 0 }
                    });
                  }
                  initStartTime = null;
                }
              });
              connect2.core.softphoneParams = params.softphone;
            }
            ;
          };
          connect2.core.onIframeRetriesExhausted = function(f) {
            connect2.core.getEventBus().subscribe(connect2.EventType.IFRAME_RETRIES_EXHAUSTED, f);
          };
          connect2.core._refreshIframeOnTimeout = function(initCCPParams, containerDiv) {
            connect2.assertNotNull(initCCPParams, "initCCPParams");
            connect2.assertNotNull(containerDiv, "containerDiv");
            var ccpIframeRefreshInterval = initCCPParams.ccpLoadTimeout ? initCCPParams.ccpLoadTimeout : initCCPParams.disasterRecoveryOn ? CCP_DR_IFRAME_REFRESH_INTERVAL : CCP_IFRAME_REFRESH_INTERVAL;
            global.clearTimeout(connect2.core.iframeRefreshTimeout);
            connect2.core.iframeRefreshTimeout = global.setTimeout(function() {
              connect2.core.iframeRefreshAttempt = (connect2.core.iframeRefreshAttempt || 0) + 1;
              if (connect2.core.iframeRefreshAttempt <= CCP_IFRAME_REFRESH_LIMIT) {
                try {
                  var iframe = connect2.core._getCCPIframe();
                  if (iframe) {
                    iframe.parentNode.removeChild(iframe);
                  }
                  var newIframe = connect2.core._createCCPIframe(containerDiv, initCCPParams);
                  connect2.core.upstream.upstream.output = newIframe.contentWindow;
                  connect2.core._sendIframeStyleDataUpstreamAfterReasonableWaitTime(newIframe, connect2.core.upstream);
                } catch (e) {
                  connect2.getLog().error("Error while checking for, and recreating, the CCP IFrame").withException(e).sendInternalLogToServer();
                }
                connect2.core._refreshIframeOnTimeout(initCCPParams, containerDiv);
              } else {
                connect2.core.getEventBus().trigger(connect2.EventType.IFRAME_RETRIES_EXHAUSTED);
                global.clearTimeout(connect2.core.iframeRefreshTimeout);
              }
            }, ccpIframeRefreshInterval);
          };
          connect2.core._getCCPIframe = function() {
            for (var iframe of window.document.getElementsByTagName("iframe")) {
              if (iframe.name === CCP_IFRAME_NAME) {
                return iframe;
              }
            }
            return null;
          };
          connect2.core._createCCPIframe = function(containerDiv, initCCPParams) {
            connect2.assertNotNull(initCCPParams, "initCCPParams");
            connect2.assertNotNull(containerDiv, "containerDiv");
            var iframe = document.createElement("iframe");
            iframe.src = initCCPParams.ccpUrl;
            iframe.allow = "microphone; camera; autoplay; clipboard-write; identity-credentials-get";
            iframe.style = initCCPParams.style || "width: 100%; height: 100%";
            iframe.title = initCCPParams.iframeTitle || CCP_IFRAME_NAME;
            iframe.name = CCP_IFRAME_NAME;
            if (connect2.storageAccess.canRequest()) {
              iframe.src = connect2.storageAccess.getRequestStorageAccessUrl();
              iframe.addEventListener("load", connect2.storageAccess.request);
            }
            containerDiv.appendChild(iframe);
            return iframe;
          };
          connect2.core._sendIframeStyleDataUpstreamAfterReasonableWaitTime = function(iframe, conduit) {
            connect2.assertNotNull(iframe, "iframe");
            connect2.assertNotNull(conduit, "conduit");
            setTimeout(function() {
              var style = window.getComputedStyle(iframe, null);
              var data = {
                display: style.display,
                offsetWidth: iframe.offsetWidth,
                offsetHeight: iframe.offsetHeight,
                clientRectsLength: iframe.getClientRects().length
              };
              conduit.sendUpstream(connect2.EventType.IFRAME_STYLE, data);
            }, 1e4);
          };
          var KeepaliveManager = function(conduit, eventBus, synTimeout, ackTimeout) {
            this.conduit = conduit;
            this.eventBus = eventBus;
            this.synTimeout = synTimeout;
            this.ackTimeout = ackTimeout;
            this.ackTimer = null;
            this.synTimer = null;
            this.ackSub = null;
          };
          KeepaliveManager.prototype.start = function() {
            var self2 = this;
            this.conduit.sendUpstream(connect2.EventType.SYNCHRONIZE);
            this.ackSub = this.conduit.onUpstream(connect2.EventType.ACKNOWLEDGE, function() {
              this.unsubscribe();
              global.clearTimeout(self2.ackTimer);
              self2._deferStart();
            });
            this.ackTimer = global.setTimeout(function() {
              self2.ackSub.unsubscribe();
              self2.eventBus.trigger(connect2.EventType.ACK_TIMEOUT);
              self2._deferStart();
            }, this.ackTimeout);
          };
          KeepaliveManager.prototype._deferStart = function() {
            this.synTimer = global.setTimeout(connect2.hitch(this, this.start), this.synTimeout);
          };
          KeepaliveManager.prototype.deferStart = function() {
            if (this.synTimer == null) {
              this.synTimer = global.setTimeout(connect2.hitch(this, this.start), this.synTimeout);
            }
          };
          var WebSocketProvider = function() {
            var callbacks = {
              initFailure: /* @__PURE__ */ new Set(),
              subscriptionUpdate: /* @__PURE__ */ new Set(),
              subscriptionFailure: /* @__PURE__ */ new Set(),
              topic: /* @__PURE__ */ new Map(),
              allMessage: /* @__PURE__ */ new Set(),
              connectionGain: /* @__PURE__ */ new Set(),
              connectionLost: /* @__PURE__ */ new Set(),
              connectionOpen: /* @__PURE__ */ new Set(),
              connectionClose: /* @__PURE__ */ new Set()
            };
            var invokeCallbacks = function(callbacks2, response) {
              callbacks2.forEach(function(callback) {
                callback(response);
              });
            };
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.INIT_FAILURE, function() {
              invokeCallbacks(callbacks.initFailure);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.CONNECTION_OPEN, function(response) {
              invokeCallbacks(callbacks.connectionOpen, response);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.CONNECTION_CLOSE, function(response) {
              invokeCallbacks(callbacks.connectionClose, response);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.CONNECTION_GAIN, function() {
              invokeCallbacks(callbacks.connectionGain);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.CONNECTION_LOST, function(response) {
              invokeCallbacks(callbacks.connectionLost, response);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.SUBSCRIPTION_UPDATE, function(response) {
              invokeCallbacks(callbacks.subscriptionUpdate, response);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.SUBSCRIPTION_FAILURE, function(response) {
              invokeCallbacks(callbacks.subscriptionFailure, response);
            });
            connect2.core.getUpstream().onUpstream(connect2.WebSocketEvents.ALL_MESSAGE, function(response) {
              invokeCallbacks(callbacks.allMessage, response);
              if (callbacks.topic.has(response.topic)) {
                invokeCallbacks(callbacks.topic.get(response.topic), response);
              }
            });
            this.sendMessage = function(webSocketPayload) {
              connect2.core.getUpstream().sendUpstream(connect2.WebSocketEvents.SEND, webSocketPayload);
            };
            this.onInitFailure = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.initFailure.add(cb);
              return function() {
                return callbacks.initFailure.delete(cb);
              };
            };
            this.onConnectionOpen = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.connectionOpen.add(cb);
              return function() {
                return callbacks.connectionOpen.delete(cb);
              };
            };
            this.onConnectionClose = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.connectionClose.add(cb);
              return function() {
                return callbacks.connectionClose.delete(cb);
              };
            };
            this.onConnectionGain = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.connectionGain.add(cb);
              return function() {
                return callbacks.connectionGain.delete(cb);
              };
            };
            this.onConnectionLost = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.connectionLost.add(cb);
              return function() {
                return callbacks.connectionLost.delete(cb);
              };
            };
            this.onSubscriptionUpdate = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.subscriptionUpdate.add(cb);
              return function() {
                return callbacks.subscriptionUpdate.delete(cb);
              };
            };
            this.onSubscriptionFailure = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.subscriptionFailure.add(cb);
              return function() {
                return callbacks.subscriptionFailure.delete(cb);
              };
            };
            this.subscribeTopics = function(topics) {
              connect2.assertNotNull(topics, "topics");
              connect2.assertTrue(connect2.isArray(topics), "topics must be a array");
              connect2.core.getUpstream().sendUpstream(connect2.WebSocketEvents.SUBSCRIBE, topics);
            };
            this.onMessage = function(topicName, cb) {
              connect2.assertNotNull(topicName, "topicName");
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              if (callbacks.topic.has(topicName)) {
                callbacks.topic.get(topicName).add(cb);
              } else {
                callbacks.topic.set(topicName, /* @__PURE__ */ new Set([cb]));
              }
              return function() {
                return callbacks.topic.get(topicName).delete(cb);
              };
            };
            this.onAllMessage = function(cb) {
              connect2.assertTrue(connect2.isFunction(cb), "method must be a function");
              callbacks.allMessage.add(cb);
              return function() {
                return callbacks.allMessage.delete(cb);
              };
            };
          };
          var AgentDataProvider = function(bus) {
            var agentData = null;
            this.bus = bus;
            this.bus.subscribe(connect2.AgentEvents.UPDATE, connect2.hitch(this, this.updateAgentData));
          };
          AgentDataProvider.prototype.updateAgentData = function(agentData) {
            var oldAgentData = this.agentData;
            this.agentData = agentData;
            try {
              const newAgentSnapshotTimestamp = Date.parse(agentData.snapshot.snapshotTimestamp);
              if (!oldAgentData || newAgentSnapshotTimestamp !== Date.parse(oldAgentData.snapshot.snapshotTimestamp)) {
                const snapshotDetectedLatency = (/* @__PURE__ */ new Date()).getTime() - newAgentSnapshotTimestamp;
                publishSnapshotMetric(SNAPSHOT_RECEIVED_BY_CLIENT, snapshotDetectedLatency, {
                  ContentLengthInBytes: connect2.core._calculateSnapshotSizingBucket(agentData.snapshot),
                  IsCCPLayer: connect2.isCCP()
                });
              }
            } catch (e) {
              connect2.getLog().error("[Metrics] Failed to send metrics.").withException(e).sendInternalLogToServer();
            }
            if (oldAgentData == null) {
              connect2.agent.initialized = true;
              this.bus.trigger(connect2.AgentEvents.INIT, new connect2.Agent());
            }
            this.bus.trigger(connect2.AgentEvents.REFRESH, new connect2.Agent());
            this._fireAgentUpdateEvents(oldAgentData);
          };
          AgentDataProvider.prototype.getAgentData = function() {
            if (this.agentData == null) {
              throw new connect2.StateError("No agent data is available yet!");
            }
            return this.agentData;
          };
          AgentDataProvider.prototype.getContactData = function(contactId) {
            var agentData = this.getAgentData();
            var contactData = connect2.find(agentData.snapshot.contacts, function(ctdata) {
              return ctdata.contactId === contactId;
            });
            if (contactData == null) {
              throw new connect2.StateError("Contact %s no longer exists.", contactId);
            }
            return contactData;
          };
          AgentDataProvider.prototype.getConnectionData = function(contactId, connectionId) {
            var contactData = this.getContactData(contactId);
            var connectionData = connect2.find(contactData.connections, function(cdata) {
              return cdata.connectionId === connectionId;
            });
            if (connectionData == null) {
              throw new connect2.StateError("Connection %s for contact %s no longer exists.", connectionId, contactId);
            }
            return connectionData;
          };
          AgentDataProvider.prototype.getInstanceId = function() {
            return this.getAgentData().configuration.routingProfile.routingProfileId.match(/instance\/([0-9a-fA-F|-]+)\//)[1];
          };
          AgentDataProvider.prototype.getAWSAccountId = function() {
            return this.getAgentData().configuration.routingProfile.routingProfileId.match(/:([0-9]+):instance/)[1];
          };
          AgentDataProvider.prototype._diffContacts = function(oldAgentData) {
            var diff = {
              added: {},
              removed: {},
              common: {},
              oldMap: connect2.index(oldAgentData == null ? [] : oldAgentData.snapshot.contacts, function(contact) {
                return contact.contactId;
              }),
              newMap: connect2.index(this.agentData.snapshot.contacts, function(contact) {
                return contact.contactId;
              }),
              endTime: 0
            };
            connect2.keys(diff.oldMap).forEach(function(contactId) {
              if (connect2.contains(diff.newMap, contactId)) {
                diff.common[contactId] = diff.newMap[contactId];
              } else {
                diff.removed[contactId] = diff.oldMap[contactId];
              }
            });
            connect2.keys(diff.newMap).forEach(function(contactId) {
              if (!connect2.contains(diff.oldMap, contactId)) {
                diff.added[contactId] = diff.newMap[contactId];
              }
            });
            diff.endTime = performance.now();
            return diff;
          };
          AgentDataProvider.prototype._fireAgentUpdateEvents = function(oldAgentData) {
            var self2 = this;
            var diff = null;
            var oldAgentState = oldAgentData == null ? connect2.AgentAvailStates.INIT : oldAgentData.snapshot.state.name;
            var newAgentState = this.agentData.snapshot.state.name;
            var oldRoutingState = oldAgentData == null ? connect2.AgentStateType.INIT : oldAgentData.snapshot.state.type;
            var newRoutingState = this.agentData.snapshot.state.type;
            if (oldRoutingState !== newRoutingState) {
              connect2.core.getAgentRoutingEventGraph().getAssociations(this, oldRoutingState, newRoutingState).forEach(function(event) {
                self2.bus.trigger(event, new connect2.Agent());
              });
            }
            if (oldAgentState !== newAgentState) {
              this.bus.trigger(connect2.AgentEvents.STATE_CHANGE, {
                agent: new connect2.Agent(),
                oldState: oldAgentState,
                newState: newAgentState
              });
              connect2.core.getAgentStateEventGraph().getAssociations(this, oldAgentState, newAgentState).forEach(function(event) {
                self2.bus.trigger(event, new connect2.Agent());
              });
            }
            var oldNextState = oldAgentData && oldAgentData.snapshot.nextState ? oldAgentData.snapshot.nextState.name : null;
            var newNextState = this.agentData.snapshot.nextState ? this.agentData.snapshot.nextState.name : null;
            if (oldNextState !== newNextState && newNextState) {
              self2.bus.trigger(connect2.AgentEvents.ENQUEUED_NEXT_STATE, new connect2.Agent());
            }
            const processingStart = performance.now();
            if (oldAgentData !== null) {
              diff = this._diffContacts(oldAgentData);
            } else {
              diff = {
                added: connect2.index(this.agentData.snapshot.contacts, function(contact) {
                  return contact.contactId;
                }),
                removed: {},
                common: {},
                oldMap: {},
                newMap: connect2.index(this.agentData.snapshot.contacts, function(contact) {
                  return contact.contactId;
                }),
                endTime: performance.now()
              };
            }
            const eventTriggerStart = performance.now();
            connect2.values(diff.added).forEach(function(contactData) {
              self2.bus.trigger(connect2.ContactEvents.INIT, new connect2.Contact(contactData.contactId));
              self2._fireContactUpdateEvents(contactData.contactId, connect2.ContactStateType.INIT, contactData.state.type);
            });
            connect2.values(diff.removed).forEach(function(contactData) {
              self2.bus.trigger(connect2.ContactEvents.DESTROYED, new connect2.ContactSnapshot(contactData));
              self2.bus.trigger(connect2.core.getContactEventName(connect2.ContactEvents.DESTROYED, contactData.contactId), new connect2.ContactSnapshot(contactData));
              self2._unsubAllContactEventsForContact(contactData.contactId);
            });
            connect2.keys(diff.common).forEach(function(contactId) {
              self2._fireContactUpdateEvents(contactId, diff.oldMap[contactId].state.type, diff.newMap[contactId].state.type);
            });
            const processingEnd = performance.now();
            const optionalDimensions = {
              ContentLengthInBytes: connect2.core._calculateSnapshotSizingBucket(this.agentData.snapshot),
              IsCCPLayer: connect2.isCCP()
            };
            try {
              publishSnapshotMetric(SNAPSHOT_COMPARISON_STEP_TIME, diff.endTime - processingStart, optionalDimensions);
              publishSnapshotMetric(SNAPSHOT_EVENT_TRIGGER_STEP_TIME, processingEnd - eventTriggerStart, optionalDimensions);
              publishSnapshotMetric(SNAPSHOT_TOTAL_PROCESSING_TIME, processingEnd - processingStart, optionalDimensions);
            } catch (e) {
              connect2.getLog().error("[Metrics] Failed to send metrics.").withException(e).sendInternalLogToServer();
            }
          };
          let publishSnapshotMetric = (metricName, value, optionalDimensions) => {
            connect2.publishMetric({
              name: metricName,
              data: {
                latency: value,
                optionalDimensions
              }
            });
          };
          connect2.core._calculateSnapshotSizingBucket = function(agentSnapshot) {
            if (agentSnapshot && agentSnapshot.hasOwnProperty("contentLength")) {
              const contentLength = parseInt(agentSnapshot.contentLength);
              for (const rangeKey of Object.keys(sizingBucket)) {
                const [min, max] = sizingBucket[rangeKey];
                if (contentLength >= min && contentLength <= max) {
                  return rangeKey;
                }
              }
            }
            return "undefined";
          };
          AgentDataProvider.prototype._fireContactUpdateEvents = function(contactId, oldContactState, newContactState) {
            var self2 = this;
            if (oldContactState !== newContactState) {
              connect2.core.getContactEventGraph().getAssociations(this, oldContactState, newContactState).forEach(function(event) {
                self2.bus.trigger(event, new connect2.Contact(contactId));
                self2.bus.trigger(connect2.core.getContactEventName(event, contactId), new connect2.Contact(contactId));
              });
            }
            self2.bus.trigger(connect2.ContactEvents.REFRESH, new connect2.Contact(contactId));
            self2.bus.trigger(connect2.core.getContactEventName(connect2.ContactEvents.REFRESH, contactId), new connect2.Contact(contactId));
          };
          AgentDataProvider.prototype._unsubAllContactEventsForContact = function(contactId) {
            var self2 = this;
            connect2.values(connect2.ContactEvents).forEach(function(eventName) {
              self2.bus.getSubscriptions(connect2.core.getContactEventName(eventName, contactId)).map(function(sub) {
                sub.unsubscribe();
              });
            });
          };
          connect2.core.onViewContact = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ContactEvents.VIEW, f);
          };
          connect2.core.viewContact = function(contactId) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ContactEvents.VIEW,
              data: {
                contactId
              }
            });
          };
          connect2.core.onActivateChannelWithViewType = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ChannelViewEvents.ACTIVATE_CHANNEL_WITH_VIEW_TYPE, f);
          };
          connect2.core.activateChannelWithViewType = function(viewType, mediaType, source, caseId) {
            const data = { viewType, mediaType };
            if (source) {
              data.source = source;
            }
            if (caseId) {
              data.caseId = caseId;
            }
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.ChannelViewEvents.ACTIVATE_CHANNEL_WITH_VIEW_TYPE,
              data
            });
          };
          connect2.core.triggerTaskCreated = function(data) {
            connect2.core.getUpstream().upstreamBus.trigger(connect2.TaskEvents.CREATED, data);
          };
          connect2.core.onAccessDenied = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.EventType.ACCESS_DENIED, f);
          };
          connect2.core.onAuthFail = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.EventType.AUTH_FAIL, f);
          };
          connect2.core.onAuthorizeSuccess = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.EventType.AUTHORIZE_SUCCESS, f);
          };
          connect2.core._handleAuthorizeSuccess = function() {
            window.sessionStorage.setItem(connect2.SessionStorageKeys.AUTHORIZE_RETRY_COUNT, 0);
          };
          connect2.core._handleAuthFail = function(loginUrl, authorizeEndpoint, authFailData) {
            if (authFailData && authFailData.authorize) {
              connect2.core._handleAuthorizeFail(loginUrl);
            } else {
              connect2.core._handleCTIAuthFail(authorizeEndpoint);
            }
          };
          connect2.core._handleAuthorizeFail = function(loginUrl) {
            let authRetryCount = connect2.core._getAuthRetryCount();
            if (!connect2.core.authorizeTimeoutId) {
              if (authRetryCount < connect2.core.MAX_AUTHORIZE_RETRY_COUNT_FOR_SESSION) {
                connect2.core._incrementAuthRetryCount();
                let retryDelay = AWS.util.calculateRetryDelay(authRetryCount + 1 || 0, { base: 2e3 });
                connect2.core.authorizeTimeoutId = setTimeout(() => {
                  connect2.core._redirectToLogin(loginUrl);
                }, retryDelay);
              } else {
                connect2.getLog().warn("We have exhausted our authorization retries due to 401s from the authorize api. No more retries will be attempted in this session until the authorize api returns 200.").sendInternalLogToServer();
                connect2.core.getEventBus().trigger(connect2.EventType.AUTHORIZE_RETRIES_EXHAUSTED);
              }
            }
          };
          connect2.core._redirectToLogin = function(loginUrl) {
            if (typeof loginUrl === "string") {
              location.assign(loginUrl);
            } else {
              location.reload();
            }
          };
          connect2.core._handleCTIAuthFail = function(authorizeEndpoint) {
            if (!connect2.core.ctiTimeoutId) {
              if (connect2.core.ctiAuthRetryCount < connect2.core.MAX_CTI_AUTH_RETRY_COUNT) {
                connect2.core.ctiAuthRetryCount++;
                let retryDelay = AWS.util.calculateRetryDelay(connect2.core.ctiAuthRetryCount || 0, { base: 500 });
                connect2.core.ctiTimeoutId = setTimeout(() => {
                  connect2.core.authorize(authorizeEndpoint).then(connect2.core._triggerAuthorizeSuccess.bind(connect2.core)).catch(connect2.core._triggerAuthFail.bind(connect2.core, { authorize: true }));
                  connect2.core.ctiTimeoutId = null;
                }, retryDelay);
              } else {
                connect2.getLog().warn("We have exhausted our authorization retries due to 401s from the CTI service. No more retries will be attempted until the page is refreshed.").sendInternalLogToServer();
                connect2.core.getEventBus().trigger(connect2.EventType.CTI_AUTHORIZE_RETRIES_EXHAUSTED);
              }
            }
          };
          connect2.core._triggerAuthorizeSuccess = function() {
            connect2.core.getUpstream().upstreamBus.trigger(connect2.EventType.AUTHORIZE_SUCCESS);
          };
          connect2.core._triggerAuthFail = function(data) {
            connect2.core.getUpstream().upstreamBus.trigger(connect2.EventType.AUTH_FAIL, data);
          };
          connect2.core._getAuthRetryCount = function() {
            let item = window.sessionStorage.getItem(connect2.SessionStorageKeys.AUTHORIZE_RETRY_COUNT);
            if (item !== null) {
              if (!isNaN(parseInt(item))) {
                return parseInt(item);
              } else {
                throw new connect2.StateError("The session storage value for auth retry count was NaN");
              }
            } else {
              window.sessionStorage.setItem(connect2.SessionStorageKeys.AUTHORIZE_RETRY_COUNT, 0);
              return 0;
            }
          };
          connect2.core._incrementAuthRetryCount = function() {
            window.sessionStorage.setItem(connect2.SessionStorageKeys.AUTHORIZE_RETRY_COUNT, (connect2.core._getAuthRetryCount() + 1).toString());
          };
          connect2.core.onAuthorizeRetriesExhausted = function(f) {
            connect2.core.getEventBus().subscribe(connect2.EventType.AUTHORIZE_RETRIES_EXHAUSTED, f);
          };
          connect2.core.onCTIAuthorizeRetriesExhausted = function(f) {
            connect2.core.getEventBus().subscribe(connect2.EventType.CTI_AUTHORIZE_RETRIES_EXHAUSTED, f);
          };
          connect2.core.onSoftphoneSessionInit = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConnectionEvents.SESSION_INIT, f);
          };
          connect2.core.onConfigure = function(f) {
            connect2.core.getUpstream().onUpstream(connect2.ConfigurationEvents.CONFIGURE, f);
          };
          connect2.core.onInitialized = function(f) {
            var bus = connect2.core.getEventBus();
            bus.subscribe(connect2.EventType.INIT, f);
          };
          connect2.core.getContactEventName = function(eventName, contactId) {
            connect2.assertNotNull(eventName, "eventName");
            connect2.assertNotNull(contactId, "contactId");
            if (!connect2.contains(connect2.values(connect2.ContactEvents), eventName)) {
              throw new connect2.ValueError("%s is not a valid contact event.", eventName);
            }
            return connect2.sprintf("%s::%s", eventName, contactId);
          };
          connect2.core.getEventBus = function() {
            return connect2.core.eventBus;
          };
          connect2.core.getWebSocketManager = function() {
            return connect2.core.webSocketProvider;
          };
          connect2.core.getAgentDataProvider = function() {
            return connect2.core.agentDataProvider;
          };
          connect2.core.getLocalTimestamp = function() {
            return connect2.core.getAgentDataProvider().getAgentData().snapshot.localTimestamp;
          };
          connect2.core.getSkew = function() {
            return connect2.core.getAgentDataProvider().getAgentData().snapshot.skew;
          };
          connect2.core.getAgentRoutingEventGraph = function() {
            return connect2.core.agentRoutingEventGraph;
          };
          connect2.core.agentRoutingEventGraph = new connect2.EventGraph().assoc(
            connect2.EventGraph.ANY,
            connect2.AgentStateType.ROUTABLE,
            connect2.AgentEvents.ROUTABLE
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.AgentStateType.NOT_ROUTABLE,
            connect2.AgentEvents.NOT_ROUTABLE
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.AgentStateType.OFFLINE,
            connect2.AgentEvents.OFFLINE
          );
          connect2.core.getAgentStateEventGraph = function() {
            return connect2.core.agentStateEventGraph;
          };
          connect2.core.agentStateEventGraph = new connect2.EventGraph().assoc(
            connect2.EventGraph.ANY,
            connect2.values(connect2.AgentErrorStates),
            connect2.AgentEvents.ERROR
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.AgentAvailStates.AFTER_CALL_WORK,
            connect2.AgentEvents.ACW
          );
          connect2.core.getContactEventGraph = function() {
            return connect2.core.contactEventGraph;
          };
          connect2.core.contactEventGraph = new connect2.EventGraph().assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.INCOMING,
            connect2.ContactEvents.INCOMING
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.PENDING,
            connect2.ContactEvents.PENDING
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.CONNECTING,
            connect2.ContactEvents.CONNECTING
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.CONNECTED,
            connect2.ContactEvents.CONNECTED
          ).assoc(
            connect2.ContactStateType.CONNECTING,
            connect2.ContactStateType.ERROR,
            connect2.ContactEvents.MISSED
          ).assoc(
            connect2.ContactStateType.INCOMING,
            connect2.ContactStateType.ERROR,
            connect2.ContactEvents.MISSED
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.ENDED,
            connect2.ContactEvents.ACW
          ).assoc(
            connect2.values(connect2.CONTACT_ACTIVE_STATES),
            connect2.values(connect2.relativeComplement(connect2.CONTACT_ACTIVE_STATES, connect2.ContactStateType)),
            connect2.ContactEvents.ENDED
          ).assoc(
            connect2.EventGraph.ANY,
            connect2.ContactStateType.ERROR,
            connect2.ContactEvents.ERROR
          ).assoc(
            connect2.ContactStateType.CONNECTING,
            connect2.ContactStateType.MISSED,
            connect2.ContactEvents.MISSED
          ).assoc(
            connect2.ContactStateType.INCOMING,
            connect2.ContactStateType.MISSED,
            connect2.ContactEvents.MISSED
          ).assoc(
            connect2.ContactStateType.CONNECTING,
            connect2.ContactStateType.REJECTED,
            connect2.ContactEvents.MISSED
          ).assoc(
            connect2.ContactStateType.INCOMING,
            connect2.ContactStateType.REJECTED,
            connect2.ContactEvents.MISSED
          );
          connect2.core.getClient = function() {
            if (!connect2.core.client) {
              throw new connect2.StateError("The connect core has not been initialized!");
            }
            return connect2.core.client;
          };
          connect2.core.client = null;
          connect2.core.getApiProxyClient = function() {
            if (!connect2.core.apiProxyClient) {
              throw new connect2.StateError("The connect apiProxy Client has not been initialized!");
            }
            return connect2.core.apiProxyClient;
          };
          connect2.core.apiProxyClient = null;
          connect2.core.getAgentAppClient = function() {
            if (!connect2.core.agentAppClient) {
              throw new connect2.StateError("The connect AgentApp Client has not been initialized!");
            }
            return connect2.core.agentAppClient;
          };
          connect2.core.agentAppClient = null;
          connect2.core.getTaskTemplatesClient = function() {
            if (!connect2.core.taskTemplatesClient) {
              throw new connect2.StateError("The connect TaskTemplates Client has not been initialized!");
            }
            return connect2.core.taskTemplatesClient;
          };
          connect2.core.taskTemplatesClient = null;
          connect2.core.getMasterClient = function() {
            if (!connect2.core.masterClient) {
              throw new connect2.StateError("The connect master client has not been initialized!");
            }
            return connect2.core.masterClient;
          };
          connect2.core.masterClient = null;
          connect2.core.getSoftphoneManager = function() {
            return connect2.core.softphoneManager;
          };
          connect2.core.softphoneManager = null;
          connect2.core.getNotificationManager = function() {
            if (!connect2.core.notificationManager) {
              connect2.core.notificationManager = new connect2.NotificationManager();
            }
            return connect2.core.notificationManager;
          };
          connect2.core.notificationManager = null;
          connect2.core.getPopupManager = function() {
            return connect2.core.popupManager;
          };
          connect2.core.popupManager = new connect2.PopupManager();
          connect2.core.getUpstream = function() {
            if (!connect2.core.upstream) {
              throw new connect2.StateError("There is no upstream conduit!");
            }
            return connect2.core.upstream;
          };
          connect2.core.upstream = null;
          connect2.core.AgentDataProvider = AgentDataProvider;
        })();
      }
    ),
    /***/
    592: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          var ALL_EVENTS = "<<all>>";
          var EventType = connect2.makeEnum([
            "acknowledge",
            "ack_timeout",
            "init",
            "api_request",
            "api_response",
            "auth_fail",
            "access_denied",
            "close",
            "configure",
            "log",
            "master_request",
            "master_response",
            "synchronize",
            "terminate",
            "terminated",
            "send_logs",
            "reload_agent_configuration",
            "broadcast",
            "api_metric",
            "client_metric",
            "softphone_stats",
            "softphone_report",
            "client_side_logs",
            "server_bound_internal_log",
            "mute",
            "iframe_style",
            "iframe_retries_exhausted",
            "update_connected_ccps",
            "outer_context_info",
            "media_device_request",
            "media_device_response",
            "tab_id",
            "authorize_success",
            "authorize_retries_exhausted",
            "cti_authorize_retries_exhausted",
            "click_stream_data",
            "set_quick_get_agent_snapshot_flag",
            "api_proxy_request",
            "api_proxy_response"
          ]);
          var MasterTopics = connect2.makeNamespacedEnum("connect", [
            "loginPopup",
            "sendLogs",
            "softphone",
            "ringtone",
            "metrics",
            "failover"
          ]);
          var AgentEvents = connect2.makeNamespacedEnum("agent", [
            "init",
            "update",
            "refresh",
            "routable",
            "not_routable",
            "pending",
            "contact_pending",
            "offline",
            "error",
            "softphone_error",
            "websocket_connection_lost",
            "websocket_connection_gained",
            "state_change",
            "acw",
            "mute_toggle",
            "local_media_stream_created",
            "enqueued_next_state"
          ]);
          var WebSocketEvents = connect2.makeNamespacedEnum("webSocket", [
            "init_failure",
            "connection_open",
            "connection_close",
            "connection_error",
            "connection_gain",
            "connection_lost",
            "subscription_update",
            "subscription_failure",
            "all_message",
            "send",
            "subscribe"
          ]);
          var ContactEvents = connect2.makeNamespacedEnum("contact", [
            "init",
            "refresh",
            "destroyed",
            "incoming",
            "pending",
            "connecting",
            "connected",
            "missed",
            "acw",
            "view",
            "ended",
            "error",
            "accepted"
          ]);
          var ChannelViewEvents = connect2.makeNamespacedEnum("taskList", [
            "activate_channel_with_view_type"
          ]);
          var TaskEvents = connect2.makeNamespacedEnum("task", [
            "created"
          ]);
          var ConnectionEvents = connect2.makeNamespacedEnum("connection", [
            "session_init",
            "ready_to_start_session"
          ]);
          var ConfigurationEvents = connect2.makeNamespacedEnum("configuration", [
            "configure",
            "set_speaker_device",
            "set_microphone_device",
            "set_ringer_device",
            "speaker_device_changed",
            "microphone_device_changed",
            "ringer_device_changed",
            "camera_device_changed",
            "background_blur_changed"
          ]);
          var DisasterRecoveryEvents = connect2.makeNamespacedEnum("disasterRecovery", [
            "suppress",
            "force_offline",
            // letting the sharedworker know to force offline
            "set_offline",
            // iframe letting the native ccp to set offline
            "init_disaster_recovery",
            "failover",
            // used to propagate failover state to other windows
            "failover_pending",
            // signals that a soft failover will occur when current voice contact ends
            "init_dr_polling"
          ]);
          var VoiceIdEvents = connect2.makeNamespacedEnum("voiceId", [
            "update_domain_id"
          ]);
          var EventFactory = function() {
          };
          EventFactory.createRequest = function(type, method, params) {
            return {
              event: type,
              requestId: connect2.randomId(),
              method,
              params
            };
          };
          EventFactory.createResponse = function(type, request, data, err) {
            return {
              event: type,
              requestId: request.requestId,
              data,
              err: err || null
            };
          };
          var Subscription = function(subMap, eventName, f) {
            this.subMap = subMap;
            this.id = connect2.randomId();
            this.eventName = eventName;
            this.f = f;
          };
          Subscription.prototype.unsubscribe = function() {
            this.subMap.unsubscribe(this.eventName, this.id);
          };
          var SubscriptionMap = function() {
            this.subIdMap = {};
            this.subEventNameMap = {};
          };
          SubscriptionMap.prototype.subscribe = function(eventName, f) {
            var sub = new Subscription(this, eventName, f);
            this.subIdMap[sub.id] = sub;
            var subList = this.subEventNameMap[eventName] || [];
            subList.push(sub);
            this.subEventNameMap[eventName] = subList;
            return sub;
          };
          SubscriptionMap.prototype.unsubscribe = function(eventName, subId) {
            if (connect2.contains(this.subEventNameMap, eventName)) {
              this.subEventNameMap[eventName] = this.subEventNameMap[eventName].filter(function(s) {
                return s.id !== subId;
              });
              if (this.subEventNameMap[eventName].length < 1) {
                delete this.subEventNameMap[eventName];
              }
            }
            if (connect2.contains(this.subIdMap, subId)) {
              delete this.subIdMap[subId];
            }
          };
          SubscriptionMap.prototype.getAllSubscriptions = function() {
            return connect2.values(this.subEventNameMap).reduce(function(a, b) {
              return a.concat(b);
            }, []);
          };
          SubscriptionMap.prototype.getSubscriptions = function(eventName) {
            return this.subEventNameMap[eventName] || [];
          };
          var EventBus = function(paramsIn) {
            var params = paramsIn || {};
            this.subMap = new SubscriptionMap();
            this.logEvents = params.logEvents || false;
          };
          EventBus.prototype.subscribe = function(eventName, f) {
            connect2.assertNotNull(eventName, "eventName");
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.subMap.subscribe(eventName, f);
          };
          EventBus.prototype.subscribeAll = function(f) {
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.subMap.subscribe(ALL_EVENTS, f);
          };
          EventBus.prototype.getSubscriptions = function(eventName) {
            return this.subMap.getSubscriptions(eventName);
          };
          EventBus.prototype.trigger = function(eventName, data) {
            connect2.assertNotNull(eventName, "eventName");
            var self2 = this;
            var allEventSubs = this.subMap.getSubscriptions(ALL_EVENTS);
            var eventSubs = this.subMap.getSubscriptions(eventName);
            if (this.logEvents && eventName !== connect2.EventType.LOG && eventName !== connect2.EventType.MASTER_RESPONSE && eventName !== connect2.EventType.API_METRIC && eventName !== connect2.EventType.SERVER_BOUND_INTERNAL_LOG) {
              connect2.getLog().trace("Publishing event: %s", eventName).sendInternalLogToServer();
            }
            if (eventName.startsWith(connect2.ContactEvents.ACCEPTED) && data && data.contactId && !(data instanceof connect2.Contact)) {
              data = new connect2.Contact(data.contactId);
            }
            allEventSubs.concat(eventSubs).forEach(function(sub) {
              try {
                sub.f(data || null, eventName, self2);
              } catch (e) {
                connect2.getLog().error("'%s' event handler failed.", eventName).withException(e).sendInternalLogToServer();
              }
            });
          };
          EventBus.prototype.bridge = function() {
            var self2 = this;
            return function(data, event) {
              self2.trigger(event, data);
            };
          };
          EventBus.prototype.unsubscribeAll = function() {
            this.subMap.getAllSubscriptions().forEach(function(sub) {
              sub.unsubscribe();
            });
          };
          connect2.EventBus = EventBus;
          connect2.EventFactory = EventFactory;
          connect2.EventType = EventType;
          connect2.AgentEvents = AgentEvents;
          connect2.ConfigurationEvents = ConfigurationEvents;
          connect2.ConnectionEvents = ConnectionEvents;
          connect2.ConnnectionEvents = ConnectionEvents;
          connect2.ContactEvents = ContactEvents;
          connect2.ChannelViewEvents = ChannelViewEvents;
          connect2.TaskEvents = TaskEvents;
          connect2.VoiceIdEvents = VoiceIdEvents;
          connect2.WebSocketEvents = WebSocketEvents;
          connect2.MasterTopics = MasterTopics;
          connect2.DisasterRecoveryEvents = DisasterRecoveryEvents;
        })();
      }
    ),
    /***/
    286: (
      /***/
      () => {
        !function(e) {
          var n = {};
          function t(o) {
            if (n[o])
              return n[o].exports;
            var r = n[o] = { i: o, l: false, exports: {} };
            return e[o].call(r.exports, r, r.exports, t), r.l = true, r.exports;
          }
          t.m = e, t.c = n, t.d = function(e2, n2, o) {
            t.o(e2, n2) || Object.defineProperty(e2, n2, { enumerable: true, get: o });
          }, t.r = function(e2) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e2, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(e2, "__esModule", { value: true });
          }, t.t = function(e2, n2) {
            if (1 & n2 && (e2 = t(e2)), 8 & n2)
              return e2;
            if (4 & n2 && "object" == typeof e2 && e2 && e2.__esModule)
              return e2;
            var o = /* @__PURE__ */ Object.create(null);
            if (t.r(o), Object.defineProperty(o, "default", { enumerable: true, value: e2 }), 2 & n2 && "string" != typeof e2)
              for (var r in e2)
                t.d(o, r, (function(n3) {
                  return e2[n3];
                }).bind(null, r));
            return o;
          }, t.n = function(e2) {
            var n2 = e2 && e2.__esModule ? function() {
              return e2.default;
            } : function() {
              return e2;
            };
            return t.d(n2, "a", n2), n2;
          }, t.o = function(e2, n2) {
            return Object.prototype.hasOwnProperty.call(e2, n2);
          }, t.p = "", t(t.s = 2);
        }([function(e, n, t) {
          "use strict";
          var o = t(1), r = "NULL", i = "CLIENT_LOGGER", c = "DEBUG", a = 2e3, s = "AMZ_WEB_SOCKET_MANAGER:", u = "Network offline", l = "Network online, connecting to WebSocket server", f = "Network offline, ignoring this getWebSocketConnConfig request", d = "Heartbeat response not received", p = "Heartbeat response received", g = "Sending heartbeat", b = "Failed to send heartbeat since WebSocket is not open", y = "WebSocket connection established!", m = "WebSocket connection is closed", v = "WebSocketManager Error, error_event: ", S = "Scheduling WebSocket reinitialization, after delay ", h = "WebSocket URL cannot be used to establish connection", k = "WebSocket Initialization failed - Terminating and cleaning subscriptions", w = "Terminating WebSocket Manager", C = "Fetching new WebSocket connection configuration", L = "Successfully fetched webSocket connection configuration", T = "Failed to fetch webSocket connection configuration", O = "Retrying fetching new WebSocket connection configuration", W = "Initializing Websocket Manager", I = "Initializing Websocket Manager Failed!", N = "Websocket connection open", _ = "Websocket connection close", E = "Websocket connection gain", F = "Websocket connection lost", A = "Websocket subscription failure", R = "Reset Websocket state", x = "WebSocketManager Message Error", D = "Message received for topic ", j = "Invalid incoming message", M = "WebsocketManager invoke callbacks for topic success ", G = "aws/subscribe", z = "aws/unsubscribe", P = "aws/heartbeat", H = "connected", U = "disconnected";
          function q(e2) {
            return (q = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
              return typeof e3;
            } : function(e3) {
              return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
            })(e2);
          }
          var J = { assertTrue: function(e2, n2) {
            if (!e2)
              throw new Error(n2);
          }, assertNotNull: function(e2, n2) {
            return J.assertTrue(null !== e2 && void 0 !== q(e2), Object(o.sprintf)("%s must be provided", n2 || "A value")), e2;
          }, isNonEmptyString: function(e2) {
            return "string" == typeof e2 && e2.length > 0;
          }, assertIsList: function(e2, n2) {
            if (!Array.isArray(e2))
              throw new Error(n2 + " is not an array");
          }, isFunction: function(e2) {
            return !!(e2 && e2.constructor && e2.call && e2.apply);
          }, isObject: function(e2) {
            return !("object" !== q(e2) || null === e2);
          }, isString: function(e2) {
            return "string" == typeof e2;
          }, isNumber: function(e2) {
            return "number" == typeof e2;
          } }, B = new RegExp("^(wss://)\\w*");
          J.validWSUrl = function(e2) {
            return B.test(e2);
          }, J.getSubscriptionResponse = function(e2, n2, t2) {
            return { topic: e2, content: { status: n2 ? "success" : "failure", topics: t2 } };
          }, J.assertIsObject = function(e2, n2) {
            if (!J.isObject(e2))
              throw new Error(n2 + " is not an object!");
          }, J.addJitter = function(e2) {
            var n2 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1;
            n2 = Math.min(n2, 1);
            var t2 = Math.random() > 0.5 ? 1 : -1;
            return Math.floor(e2 + t2 * e2 * Math.random() * n2);
          }, J.isNetworkOnline = function() {
            return navigator.onLine;
          }, J.isNetworkFailure = function(e2) {
            return !(!e2._debug || !e2._debug.type) && "NetworkingError" === e2._debug.type;
          };
          var V = J;
          function X(e2, n2) {
            return !n2 || "object" !== Z(n2) && "function" != typeof n2 ? function(e3) {
              if (void 0 === e3)
                throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
              return e3;
            }(e2) : n2;
          }
          function $(e2) {
            return ($ = Object.setPrototypeOf ? Object.getPrototypeOf : function(e3) {
              return e3.__proto__ || Object.getPrototypeOf(e3);
            })(e2);
          }
          function K(e2, n2) {
            return (K = Object.setPrototypeOf || function(e3, n3) {
              return e3.__proto__ = n3, e3;
            })(e2, n2);
          }
          function Z(e2) {
            return (Z = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(e3) {
              return typeof e3;
            } : function(e3) {
              return e3 && "function" == typeof Symbol && e3.constructor === Symbol && e3 !== Symbol.prototype ? "symbol" : typeof e3;
            })(e2);
          }
          function Q(e2, n2) {
            if (!(e2 instanceof n2))
              throw new TypeError("Cannot call a class as a function");
          }
          function Y(e2, n2) {
            for (var t2 = 0; t2 < n2.length; t2++) {
              var o2 = n2[t2];
              o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
            }
          }
          function ee(e2, n2, t2) {
            return n2 && Y(e2.prototype, n2), t2 && Y(e2, t2), e2;
          }
          var ne = function() {
            function e2() {
              Q(this, e2);
            }
            return ee(e2, [{ key: "debug", value: function(e3) {
            } }, { key: "info", value: function(e3) {
            } }, { key: "warn", value: function(e3) {
            } }, { key: "error", value: function(e3) {
            } }, { key: "advancedLog", value: function(e3) {
            } }]), e2;
          }(), te = s, oe = { DEBUG: 10, INFO: 20, WARN: 30, ERROR: 40, ADVANCED_LOG: 50 }, re = function() {
            function e2() {
              Q(this, e2), this.updateLoggerConfig(), this.consoleLoggerWrapper = ae();
            }
            return ee(e2, [{ key: "writeToClientLogger", value: function(e3, n2) {
              if (this.hasClientLogger())
                switch (e3) {
                  case oe.DEBUG:
                    return this._clientLogger.debug(n2) || n2;
                  case oe.INFO:
                    return this._clientLogger.info(n2) || n2;
                  case oe.WARN:
                    return this._clientLogger.warn(n2) || n2;
                  case oe.ERROR:
                    return this._clientLogger.error(n2) || n2;
                  case oe.ADVANCED_LOG:
                    return this._advancedLogWriter ? this._clientLogger[this._advancedLogWriter](n2) || n2 : "";
                }
            } }, { key: "isLevelEnabled", value: function(e3) {
              return e3 >= this._level;
            } }, { key: "hasClientLogger", value: function() {
              return null !== this._clientLogger;
            } }, { key: "getLogger", value: function(e3) {
              var n2 = e3.prefix || te;
              return this._logsDestination === c ? this.consoleLoggerWrapper : new ce(n2);
            } }, { key: "updateLoggerConfig", value: function(e3) {
              var n2 = e3 || {};
              this._level = n2.level || oe.INFO, this._advancedLogWriter = "warn", n2.advancedLogWriter && (this._advancedLogWriter = n2.advancedLogWriter), n2.customizedLogger && "object" === Z(n2.customizedLogger) && (this.useClientLogger = true), this._clientLogger = n2.logger || this.selectLogger(n2), this._logsDestination = r, n2.debug && (this._logsDestination = c), n2.logger && (this._logsDestination = i);
            } }, { key: "selectLogger", value: function(e3) {
              return e3.customizedLogger && "object" === Z(e3.customizedLogger) ? e3.customizedLogger : e3.useDefaultLogger ? (this.consoleLoggerWrapper = ae(), this.consoleLoggerWrapper) : null;
            } }]), e2;
          }(), ie = function() {
            function e2() {
              Q(this, e2);
            }
            return ee(e2, [{ key: "debug", value: function() {
            } }, { key: "info", value: function() {
            } }, { key: "warn", value: function() {
            } }, { key: "error", value: function() {
            } }, { key: "advancedLog", value: function() {
            } }]), e2;
          }(), ce = function(e2) {
            function n2(e3) {
              var t2;
              return Q(this, n2), (t2 = X(this, $(n2).call(this))).prefix = e3 || te, t2;
            }
            return function(e3, n3) {
              if ("function" != typeof n3 && null !== n3)
                throw new TypeError("Super expression must either be null or a function");
              e3.prototype = Object.create(n3 && n3.prototype, { constructor: { value: e3, writable: true, configurable: true } }), n3 && K(e3, n3);
            }(n2, ie), ee(n2, [{ key: "debug", value: function() {
              for (var e3 = arguments.length, n3 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n3[t2] = arguments[t2];
              return this._log(oe.DEBUG, n3);
            } }, { key: "info", value: function() {
              for (var e3 = arguments.length, n3 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n3[t2] = arguments[t2];
              return this._log(oe.INFO, n3);
            } }, { key: "warn", value: function() {
              for (var e3 = arguments.length, n3 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n3[t2] = arguments[t2];
              return this._log(oe.WARN, n3);
            } }, { key: "error", value: function() {
              for (var e3 = arguments.length, n3 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n3[t2] = arguments[t2];
              return this._log(oe.ERROR, n3);
            } }, { key: "advancedLog", value: function() {
              for (var e3 = arguments.length, n3 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n3[t2] = arguments[t2];
              return this._log(oe.ADVANCED_LOG, n3);
            } }, { key: "_shouldLog", value: function(e3) {
              return se.hasClientLogger() && se.isLevelEnabled(e3);
            } }, { key: "_writeToClientLogger", value: function(e3, n3) {
              return se.writeToClientLogger(e3, n3);
            } }, { key: "_log", value: function(e3, n3) {
              if (this._shouldLog(e3)) {
                var t2 = se.useClientLogger ? n3 : this._convertToSingleStatement(n3, e3);
                return this._writeToClientLogger(e3, t2);
              }
            } }, { key: "_convertToSingleStatement", value: function(e3, n3) {
              var t2 = new Date(Date.now()).toISOString(), o2 = this._getLogLevelByValue(n3), r2 = "[".concat(t2, "][").concat(o2, "]");
              this.prefix && (r2 += this.prefix + " "), this.options && (this.options.prefix ? r2 += " " + this.options.prefix + ":" : r2 += "", this.options.logMetaData ? r2 += " Meta data: " + JSON.stringify(this.options.logMetaData) : r2 += "");
              for (var i2 = 0; i2 < e3.length; i2++) {
                var c2 = e3[i2];
                r2 += this._convertToString(c2) + " ";
              }
              return r2;
            } }, { key: "_getLogLevelByValue", value: function(e3) {
              switch (e3) {
                case 10:
                  return "DEBUG";
                case 20:
                  return "INFO";
                case 30:
                  return "WARN";
                case 40:
                  return "ERROR";
                case 50:
                  return "ADVANCED_LOG";
              }
            } }, { key: "_convertToString", value: function(e3) {
              try {
                if (!e3)
                  return "";
                if (V.isString(e3))
                  return e3;
                if (V.isObject(e3) && V.isFunction(e3.toString)) {
                  var n3 = e3.toString();
                  if ("[object Object]" !== n3)
                    return n3;
                }
                return JSON.stringify(e3);
              } catch (n4) {
                return console.error("Error while converting argument to string", e3, n4), "";
              }
            } }]), n2;
          }(), ae = function() {
            var e2 = new ie();
            return e2.debug = function() {
              for (var e3 = arguments.length, n2 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n2[t2] = arguments[t2];
              return console.debug.apply(window.console, [].concat(n2));
            }, e2.info = function() {
              for (var e3 = arguments.length, n2 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n2[t2] = arguments[t2];
              return console.info.apply(window.console, [].concat(n2));
            }, e2.warn = function() {
              for (var e3 = arguments.length, n2 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n2[t2] = arguments[t2];
              return console.warn.apply(window.console, [].concat(n2));
            }, e2.error = function() {
              for (var e3 = arguments.length, n2 = new Array(e3), t2 = 0; t2 < e3; t2++)
                n2[t2] = arguments[t2];
              return console.error.apply(window.console, [].concat(n2));
            }, e2;
          }, se = new re();
          function ue(e2, n2) {
            for (var t2 = 0; t2 < n2.length; t2++) {
              var o2 = n2[t2];
              o2.enumerable = o2.enumerable || false, o2.configurable = true, "value" in o2 && (o2.writable = true), Object.defineProperty(e2, o2.key, o2);
            }
          }
          var le = function() {
            function e2(n3) {
              var t3 = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : a;
              !function(e3, n4) {
                if (!(e3 instanceof n4))
                  throw new TypeError("Cannot call a class as a function");
              }(this, e2), this.numAttempts = 0, this.executor = n3, this.hasActiveReconnection = false, this.defaultRetry = t3;
            }
            var n2, t2, o2;
            return n2 = e2, (t2 = [{ key: "retry", value: function() {
              var e3 = this;
              this.hasActiveReconnection || (this.hasActiveReconnection = true, setTimeout(function() {
                e3._execute();
              }, this._getDelay()));
            } }, { key: "_execute", value: function() {
              this.hasActiveReconnection = false, this.executor(), this.numAttempts++;
            } }, { key: "connected", value: function() {
              this.numAttempts = 0;
            } }, { key: "_getDelay", value: function() {
              var e3 = Math.pow(2, this.numAttempts) * this.defaultRetry;
              return e3 <= 3e4 ? e3 : 3e4;
            } }, { key: "getIsConnected", value: function() {
              return !this.numAttempts;
            } }]) && ue(n2.prototype, t2), o2 && ue(n2, o2), e2;
          }();
          t.d(n, "a", function() {
            return de;
          });
          var fe = function() {
            var e2 = se.getLogger({ prefix: s }), n2 = V.isNetworkOnline(), t2 = { primary: null, secondary: null }, o2 = { reconnectWebSocket: true, websocketInitFailed: false, exponentialBackOffTime: 1e3, exponentialTimeoutHandle: null, lifeTimeTimeoutHandle: null, webSocketInitCheckerTimeoutId: null, connState: null }, r2 = { connectWebSocketRetryCount: 0, connectionAttemptStartTime: null, noOpenConnectionsTimestamp: null }, i2 = { pendingResponse: false, intervalHandle: null }, c2 = { initFailure: /* @__PURE__ */ new Set(), getWebSocketTransport: null, subscriptionUpdate: /* @__PURE__ */ new Set(), subscriptionFailure: /* @__PURE__ */ new Set(), topic: /* @__PURE__ */ new Map(), allMessage: /* @__PURE__ */ new Set(), connectionGain: /* @__PURE__ */ new Set(), connectionLost: /* @__PURE__ */ new Set(), connectionOpen: /* @__PURE__ */ new Set(), connectionClose: /* @__PURE__ */ new Set() }, a2 = { connConfig: null, promiseHandle: null, promiseCompleted: true }, q2 = { subscribed: /* @__PURE__ */ new Set(), pending: /* @__PURE__ */ new Set(), subscriptionHistory: /* @__PURE__ */ new Set() }, J2 = { responseCheckIntervalId: null, requestCompleted: true, reSubscribeIntervalId: null, consecutiveFailedSubscribeAttempts: 0, consecutiveNoResponseRequest: 0 }, B2 = new le(function() {
              he();
            }), X2 = /* @__PURE__ */ new Set([G, z, P]), $2 = setInterval(function() {
              if (n2 !== V.isNetworkOnline()) {
                if (!(n2 = V.isNetworkOnline()))
                  return e2.advancedLog(u), void Ce(e2.info(u));
                var t3 = te2();
                n2 && (!t3 || Y2(t3, WebSocket.CLOSING) || Y2(t3, WebSocket.CLOSED)) && (e2.advancedLog(l), Ce(e2.info(l)), he());
              }
            }, 250), K2 = function(n3, t3) {
              n3.forEach(function(n4) {
                try {
                  n4(t3);
                } catch (n5) {
                  Ce(e2.error("Error executing callback", n5));
                }
              });
            }, Z2 = function(e3) {
              if (null === e3)
                return "NULL";
              switch (e3.readyState) {
                case WebSocket.CONNECTING:
                  return "CONNECTING";
                case WebSocket.OPEN:
                  return "OPEN";
                case WebSocket.CLOSING:
                  return "CLOSING";
                case WebSocket.CLOSED:
                  return "CLOSED";
                default:
                  return "UNDEFINED";
              }
            }, Q2 = function() {
              var n3 = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "";
              Ce(e2.debug("[" + n3 + "] Primary WebSocket: " + Z2(t2.primary) + " | Secondary WebSocket: " + Z2(t2.secondary)));
            }, Y2 = function(e3, n3) {
              return e3 && e3.readyState === n3;
            }, ee2 = function(e3) {
              return Y2(e3, WebSocket.OPEN);
            }, ne2 = function(e3) {
              return null === e3 || void 0 === e3.readyState || Y2(e3, WebSocket.CLOSED);
            }, te2 = function() {
              return null !== t2.secondary ? t2.secondary : t2.primary;
            }, oe2 = function() {
              return ee2(te2());
            }, re2 = function() {
              if (i2.pendingResponse)
                return e2.advancedLog(d), Ce(e2.warn(d)), clearInterval(i2.intervalHandle), i2.pendingResponse = false, void he();
              oe2() ? (Ce(e2.debug(g)), te2().send(ve(P)), i2.pendingResponse = true) : (e2.advancedLog(b), Ce(e2.warn(b)), Q2("sendHeartBeat"), he());
            }, ie2 = function() {
              e2.advancedLog(R), o2.exponentialBackOffTime = 1e3, i2.pendingResponse = false, o2.reconnectWebSocket = true, clearTimeout(o2.lifeTimeTimeoutHandle), clearInterval(i2.intervalHandle), clearTimeout(o2.exponentialTimeoutHandle), clearTimeout(o2.webSocketInitCheckerTimeoutId);
            }, ce2 = function() {
              J2.consecutiveFailedSubscribeAttempts = 0, J2.consecutiveNoResponseRequest = 0, clearInterval(J2.responseCheckIntervalId), clearInterval(J2.reSubscribeIntervalId);
            }, ae2 = function() {
              r2.connectWebSocketRetryCount = 0, r2.connectionAttemptStartTime = null, r2.noOpenConnectionsTimestamp = null;
            }, ue2 = function() {
              B2.connected();
              try {
                e2.advancedLog(y), Ce(e2.info(y)), Q2("webSocketOnOpen"), null !== o2.connState && o2.connState !== U || K2(c2.connectionGain), o2.connState = H;
                var n3 = Date.now();
                K2(c2.connectionOpen, { connectWebSocketRetryCount: r2.connectWebSocketRetryCount, connectionAttemptStartTime: r2.connectionAttemptStartTime, noOpenConnectionsTimestamp: r2.noOpenConnectionsTimestamp, connectionEstablishedTime: n3, timeToConnect: n3 - r2.connectionAttemptStartTime, timeWithoutConnection: r2.noOpenConnectionsTimestamp ? n3 - r2.noOpenConnectionsTimestamp : null }), ae2(), ie2(), te2().openTimestamp = Date.now(), 0 === q2.subscribed.size && ee2(t2.secondary) && ge(t2.primary, "[Primary WebSocket] Closing WebSocket"), (q2.subscribed.size > 0 || q2.pending.size > 0) && (ee2(t2.secondary) && Ce(e2.info("Subscribing secondary websocket to topics of primary websocket")), q2.subscribed.forEach(function(e3) {
                  q2.subscriptionHistory.add(e3), q2.pending.add(e3);
                }), q2.subscribed.clear(), pe()), re2(), i2.intervalHandle = setInterval(re2, 1e4);
                var s2 = 1e3 * a2.connConfig.webSocketTransport.transportLifeTimeInSeconds;
                Ce(e2.debug("Scheduling WebSocket manager reconnection, after delay " + s2 + " ms")), o2.lifeTimeTimeoutHandle = setTimeout(function() {
                  Ce(e2.debug("Starting scheduled WebSocket manager reconnection")), he();
                }, s2);
              } catch (n4) {
                Ce(e2.error("Error after establishing WebSocket connection", n4));
              }
            }, fe2 = function(n3) {
              Q2("webSocketOnError"), e2.advancedLog(v, JSON.stringify(n3)), Ce(e2.error(v, JSON.stringify(n3))), B2.getIsConnected() ? he() : B2.retry();
            }, de2 = function(n3) {
              var o3 = JSON.parse(n3.data);
              switch (o3.topic) {
                case G:
                  if (Ce(e2.debug("Subscription Message received from webSocket server", n3.data)), J2.requestCompleted = true, J2.consecutiveNoResponseRequest = 0, "success" === o3.content.status)
                    J2.consecutiveFailedSubscribeAttempts = 0, o3.content.topics.forEach(function(e3) {
                      q2.subscriptionHistory.delete(e3), q2.pending.delete(e3), q2.subscribed.add(e3);
                    }), 0 === q2.subscriptionHistory.size ? ee2(t2.secondary) && (Ce(e2.info("Successfully subscribed secondary websocket to all topics of primary websocket")), ge(t2.primary, "[Primary WebSocket] Closing WebSocket")) : pe(), K2(c2.subscriptionUpdate, o3);
                  else {
                    if (clearInterval(J2.reSubscribeIntervalId), ++J2.consecutiveFailedSubscribeAttempts, 5 === J2.consecutiveFailedSubscribeAttempts)
                      return K2(c2.subscriptionFailure, o3), void (J2.consecutiveFailedSubscribeAttempts = 0);
                    J2.reSubscribeIntervalId = setInterval(function() {
                      pe();
                    }, 500);
                  }
                  break;
                case P:
                  Ce(e2.debug(p)), i2.pendingResponse = false;
                  break;
                default:
                  if (o3.topic) {
                    if (e2.advancedLog(D, o3.topic), Ce(e2.debug(D + o3.topic)), ee2(t2.primary) && ee2(t2.secondary) && 0 === q2.subscriptionHistory.size && this === t2.primary)
                      return void Ce(e2.warn("Ignoring Message for Topic " + o3.topic + ", to avoid duplicates"));
                    if (0 === c2.allMessage.size && 0 === c2.topic.size)
                      return void Ce(e2.warn("No registered callback listener for Topic", o3.topic));
                    e2.advancedLog(M, o3.topic), K2(c2.allMessage, o3), c2.topic.has(o3.topic) && K2(c2.topic.get(o3.topic), o3);
                  } else
                    o3.message ? (e2.advancedLog(x, o3), Ce(e2.warn(x, o3))) : (e2.advancedLog(j, o3), Ce(e2.warn(j, o3)));
              }
            }, pe = function n3() {
              if (J2.consecutiveNoResponseRequest > 3)
                return Ce(e2.warn("Ignoring subscribePendingTopics since we have exhausted max subscription retries with no response")), void K2(c2.subscriptionFailure, V.getSubscriptionResponse(G, false, Array.from(q2.pending)));
              oe2() ? 0 !== Array.from(q2.pending).length && (clearInterval(J2.responseCheckIntervalId), te2().send(ve(G, { topics: Array.from(q2.pending) })), J2.requestCompleted = false, J2.responseCheckIntervalId = setInterval(function() {
                J2.requestCompleted || (++J2.consecutiveNoResponseRequest, n3());
              }, 1e3)) : Ce(e2.warn("Ignoring subscribePendingTopics call since Default WebSocket is not open"));
            }, ge = function(n3, t3) {
              Y2(n3, WebSocket.CONNECTING) || Y2(n3, WebSocket.OPEN) ? n3.close(1e3, t3) : Ce(e2.warn("Ignoring WebSocket Close request, WebSocket State: " + Z2(n3)));
            }, be = function(e3) {
              ge(t2.primary, "[Primary] WebSocket " + e3), ge(t2.secondary, "[Secondary] WebSocket " + e3);
            }, ye = function() {
              r2.connectWebSocketRetryCount++;
              var n3 = V.addJitter(o2.exponentialBackOffTime, 0.3);
              Date.now() + n3 <= a2.connConfig.urlConnValidTime ? (e2.advancedLog(S), Ce(e2.debug(S + n3 + " ms")), o2.exponentialTimeoutHandle = setTimeout(function() {
                return ke();
              }, n3), o2.exponentialBackOffTime *= 2) : (e2.advancedLog(h), Ce(e2.warn(h)), he());
            }, me = function(n3) {
              ie2(), ce2(), e2.advancedLog(k, n3), Ce(e2.error(k)), o2.websocketInitFailed = true, be(w), clearInterval($2), K2(c2.initFailure, { connectWebSocketRetryCount: r2.connectWebSocketRetryCount, connectionAttemptStartTime: r2.connectionAttemptStartTime, reason: n3 }), ae2();
            }, ve = function(e3, n3) {
              return JSON.stringify({ topic: e3, content: n3 });
            }, Se = function(n3) {
              return !!(V.isObject(n3) && V.isObject(n3.webSocketTransport) && V.isNonEmptyString(n3.webSocketTransport.url) && V.validWSUrl(n3.webSocketTransport.url) && 1e3 * n3.webSocketTransport.transportLifeTimeInSeconds >= 3e5) || (Ce(e2.error("Invalid WebSocket Connection Configuration", n3)), false);
            }, he = function() {
              if (!V.isNetworkOnline())
                return e2.advancedLog(f), void Ce(e2.info(f));
              if (o2.websocketInitFailed)
                Ce(e2.debug("WebSocket Init had failed, ignoring this getWebSocketConnConfig request"));
              else {
                if (a2.promiseCompleted)
                  return ie2(), e2.advancedLog(C), Ce(e2.info(C)), r2.connectionAttemptStartTime = r2.connectionAttemptStartTime || Date.now(), a2.promiseCompleted = false, a2.promiseHandle = c2.getWebSocketTransport(), a2.promiseHandle.then(function(n3) {
                    return a2.promiseCompleted = true, e2.advancedLog(L), Ce(e2.debug(L, n3)), Se(n3) ? (a2.connConfig = n3, a2.connConfig.urlConnValidTime = Date.now() + 85e3, ke()) : (me("Invalid WebSocket connection configuration: " + n3), { webSocketConnectionFailed: true });
                  }, function(n3) {
                    return a2.promiseCompleted = true, e2.advancedLog(T), Ce(e2.error(T, n3)), V.isNetworkFailure(n3) ? (e2.advancedLog(O + JSON.stringify(n3)), Ce(e2.info(O + JSON.stringify(n3))), B2.retry()) : me("Failed to fetch webSocket connection configuration: " + JSON.stringify(n3)), { webSocketConnectionFailed: true };
                  });
                Ce(e2.debug("There is an ongoing getWebSocketConnConfig request, this request will be ignored"));
              }
            }, ke = function() {
              if (o2.websocketInitFailed)
                return Ce(e2.info("web-socket initializing had failed, aborting re-init")), { webSocketConnectionFailed: true };
              if (!V.isNetworkOnline())
                return Ce(e2.warn("System is offline aborting web-socket init")), { webSocketConnectionFailed: true };
              e2.advancedLog(W), Ce(e2.info(W)), Q2("initWebSocket");
              try {
                if (Se(a2.connConfig)) {
                  var n3 = null;
                  return ee2(t2.primary) ? (Ce(e2.debug("Primary Socket connection is already open")), Y2(t2.secondary, WebSocket.CONNECTING) || (Ce(e2.debug("Establishing a secondary web-socket connection")), B2.numAttempts = 0, t2.secondary = we()), n3 = t2.secondary) : (Y2(t2.primary, WebSocket.CONNECTING) || (Ce(e2.debug("Establishing a primary web-socket connection")), t2.primary = we()), n3 = t2.primary), o2.webSocketInitCheckerTimeoutId = setTimeout(function() {
                    ee2(n3) || ye();
                  }, 1e3), { webSocketConnectionFailed: false };
                }
              } catch (n4) {
                return Ce(e2.error("Error Initializing web-socket-manager", n4)), me("Failed to initialize new WebSocket: " + n4.message), { webSocketConnectionFailed: true };
              }
            }, we = function() {
              var n3 = new WebSocket(a2.connConfig.webSocketTransport.url);
              return n3.addEventListener("open", ue2), n3.addEventListener("message", de2), n3.addEventListener("error", fe2), n3.addEventListener("close", function(i3) {
                return function(n4, i4) {
                  e2.advancedLog(m, JSON.stringify(n4)), Ce(e2.info(m, JSON.stringify(n4))), Q2("webSocketOnClose before-cleanup"), K2(c2.connectionClose, { openTimestamp: i4.openTimestamp, closeTimestamp: Date.now(), connectionDuration: Date.now() - i4.openTimestamp, code: n4.code, reason: n4.reason }), ne2(t2.primary) && (t2.primary = null), ne2(t2.secondary) && (t2.secondary = null), o2.reconnectWebSocket && (ee2(t2.primary) || ee2(t2.secondary) ? ne2(t2.primary) && ee2(t2.secondary) && (Ce(e2.info("[Primary] WebSocket Cleanly Closed")), t2.primary = t2.secondary, t2.secondary = null) : (Ce(e2.warn("Neither primary websocket and nor secondary websocket have open connections, attempting to re-establish connection")), o2.connState === U ? Ce(e2.info("Ignoring connectionLost callback invocation")) : (K2(c2.connectionLost, { openTimestamp: i4.openTimestamp, closeTimestamp: Date.now(), connectionDuration: Date.now() - i4.openTimestamp, code: n4.code, reason: n4.reason }), r2.noOpenConnectionsTimestamp = Date.now()), o2.connState = U, he()), Q2("webSocketOnClose after-cleanup"));
                }(i3, n3);
              }), n3;
            }, Ce = function(e3) {
              return e3 && "function" == typeof e3.sendInternalLogToServer && e3.sendInternalLogToServer(), e3;
            };
            this.init = function(n3) {
              if (V.assertTrue(V.isFunction(n3), "transportHandle must be a function"), null === c2.getWebSocketTransport)
                return c2.getWebSocketTransport = n3, he();
              Ce(e2.warn("Web Socket Manager was already initialized"));
            }, this.onInitFailure = function(n3) {
              return e2.advancedLog(I), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.initFailure.add(n3), o2.websocketInitFailed && n3(), function() {
                return c2.initFailure.delete(n3);
              };
            }, this.onConnectionOpen = function(n3) {
              return e2.advancedLog(N), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.connectionOpen.add(n3), function() {
                return c2.connectionOpen.delete(n3);
              };
            }, this.onConnectionClose = function(n3) {
              return e2.advancedLog(_), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.connectionClose.add(n3), function() {
                return c2.connectionClose.delete(n3);
              };
            }, this.onConnectionGain = function(n3) {
              return e2.advancedLog(E), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.connectionGain.add(n3), oe2() && n3(), function() {
                return c2.connectionGain.delete(n3);
              };
            }, this.onConnectionLost = function(n3) {
              return e2.advancedLog(F), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.connectionLost.add(n3), o2.connState === U && n3(), function() {
                return c2.connectionLost.delete(n3);
              };
            }, this.onSubscriptionUpdate = function(e3) {
              return V.assertTrue(V.isFunction(e3), "cb must be a function"), c2.subscriptionUpdate.add(e3), function() {
                return c2.subscriptionUpdate.delete(e3);
              };
            }, this.onSubscriptionFailure = function(n3) {
              return e2.advancedLog(A), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.subscriptionFailure.add(n3), function() {
                return c2.subscriptionFailure.delete(n3);
              };
            }, this.onMessage = function(e3, n3) {
              return V.assertNotNull(e3, "topicName"), V.assertTrue(V.isFunction(n3), "cb must be a function"), c2.topic.has(e3) ? c2.topic.get(e3).add(n3) : c2.topic.set(e3, /* @__PURE__ */ new Set([n3])), function() {
                return c2.topic.get(e3).delete(n3);
              };
            }, this.onAllMessage = function(e3) {
              return V.assertTrue(V.isFunction(e3), "cb must be a function"), c2.allMessage.add(e3), function() {
                return c2.allMessage.delete(e3);
              };
            }, this.subscribeTopics = function(e3) {
              V.assertNotNull(e3, "topics"), V.assertIsList(e3), e3.forEach(function(e4) {
                q2.subscribed.has(e4) || q2.pending.add(e4);
              }), J2.consecutiveNoResponseRequest = 0, pe();
            }, this.sendMessage = function(n3) {
              if (V.assertIsObject(n3, "payload"), void 0 === n3.topic || X2.has(n3.topic))
                Ce(e2.warn("Cannot send message, Invalid topic", n3));
              else {
                try {
                  n3 = JSON.stringify(n3);
                } catch (t3) {
                  return void Ce(e2.warn("Error stringify message", n3));
                }
                oe2() ? te2().send(n3) : Ce(e2.warn("Cannot send message, web socket connection is not open"));
              }
            }, this.closeWebSocket = function() {
              ie2(), ce2(), o2.reconnectWebSocket = false, clearInterval($2), be("User request to close WebSocket");
            }, this.terminateWebSocketManager = me;
          }, de = { create: function() {
            return new fe();
          }, setGlobalConfig: function(e2) {
            var n2 = e2 && e2.loggerConfig;
            se.updateLoggerConfig(n2);
          }, LogLevel: oe, Logger: ne };
        }, function(e, n, t) {
          var o;
          !function() {
            "use strict";
            var r = { not_string: /[^s]/, not_bool: /[^t]/, not_type: /[^T]/, not_primitive: /[^v]/, number: /[diefg]/, numeric_arg: /[bcdiefguxX]/, json: /[j]/, not_json: /[^j]/, text: /^[^\x25]+/, modulo: /^\x25{2}/, placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/, key: /^([a-z_][a-z_\d]*)/i, key_access: /^\.([a-z_][a-z_\d]*)/i, index_access: /^\[(\d+)\]/, sign: /^[+-]/ };
            function i(e2) {
              return function(e3, n2) {
                var t2, o2, c2, a2, s, u, l, f, d, p = 1, g = e3.length, b = "";
                for (o2 = 0; o2 < g; o2++)
                  if ("string" == typeof e3[o2])
                    b += e3[o2];
                  else if ("object" == typeof e3[o2]) {
                    if ((a2 = e3[o2]).keys)
                      for (t2 = n2[p], c2 = 0; c2 < a2.keys.length; c2++) {
                        if (null == t2)
                          throw new Error(i('[sprintf] Cannot access property "%s" of undefined value "%s"', a2.keys[c2], a2.keys[c2 - 1]));
                        t2 = t2[a2.keys[c2]];
                      }
                    else
                      t2 = a2.param_no ? n2[a2.param_no] : n2[p++];
                    if (r.not_type.test(a2.type) && r.not_primitive.test(a2.type) && t2 instanceof Function && (t2 = t2()), r.numeric_arg.test(a2.type) && "number" != typeof t2 && isNaN(t2))
                      throw new TypeError(i("[sprintf] expecting number but found %T", t2));
                    switch (r.number.test(a2.type) && (f = t2 >= 0), a2.type) {
                      case "b":
                        t2 = parseInt(t2, 10).toString(2);
                        break;
                      case "c":
                        t2 = String.fromCharCode(parseInt(t2, 10));
                        break;
                      case "d":
                      case "i":
                        t2 = parseInt(t2, 10);
                        break;
                      case "j":
                        t2 = JSON.stringify(t2, null, a2.width ? parseInt(a2.width) : 0);
                        break;
                      case "e":
                        t2 = a2.precision ? parseFloat(t2).toExponential(a2.precision) : parseFloat(t2).toExponential();
                        break;
                      case "f":
                        t2 = a2.precision ? parseFloat(t2).toFixed(a2.precision) : parseFloat(t2);
                        break;
                      case "g":
                        t2 = a2.precision ? String(Number(t2.toPrecision(a2.precision))) : parseFloat(t2);
                        break;
                      case "o":
                        t2 = (parseInt(t2, 10) >>> 0).toString(8);
                        break;
                      case "s":
                        t2 = String(t2), t2 = a2.precision ? t2.substring(0, a2.precision) : t2;
                        break;
                      case "t":
                        t2 = String(!!t2), t2 = a2.precision ? t2.substring(0, a2.precision) : t2;
                        break;
                      case "T":
                        t2 = Object.prototype.toString.call(t2).slice(8, -1).toLowerCase(), t2 = a2.precision ? t2.substring(0, a2.precision) : t2;
                        break;
                      case "u":
                        t2 = parseInt(t2, 10) >>> 0;
                        break;
                      case "v":
                        t2 = t2.valueOf(), t2 = a2.precision ? t2.substring(0, a2.precision) : t2;
                        break;
                      case "x":
                        t2 = (parseInt(t2, 10) >>> 0).toString(16);
                        break;
                      case "X":
                        t2 = (parseInt(t2, 10) >>> 0).toString(16).toUpperCase();
                    }
                    r.json.test(a2.type) ? b += t2 : (!r.number.test(a2.type) || f && !a2.sign ? d = "" : (d = f ? "+" : "-", t2 = t2.toString().replace(r.sign, "")), u = a2.pad_char ? "0" === a2.pad_char ? "0" : a2.pad_char.charAt(1) : " ", l = a2.width - (d + t2).length, s = a2.width && l > 0 ? u.repeat(l) : "", b += a2.align ? d + t2 + s : "0" === u ? d + s + t2 : s + d + t2);
                  }
                return b;
              }(function(e3) {
                if (a[e3])
                  return a[e3];
                var n2, t2 = e3, o2 = [], i2 = 0;
                for (; t2; ) {
                  if (null !== (n2 = r.text.exec(t2)))
                    o2.push(n2[0]);
                  else if (null !== (n2 = r.modulo.exec(t2)))
                    o2.push("%");
                  else {
                    if (null === (n2 = r.placeholder.exec(t2)))
                      throw new SyntaxError("[sprintf] unexpected placeholder");
                    if (n2[2]) {
                      i2 |= 1;
                      var c2 = [], s = n2[2], u = [];
                      if (null === (u = r.key.exec(s)))
                        throw new SyntaxError("[sprintf] failed to parse named argument key");
                      for (c2.push(u[1]); "" !== (s = s.substring(u[0].length)); )
                        if (null !== (u = r.key_access.exec(s)))
                          c2.push(u[1]);
                        else {
                          if (null === (u = r.index_access.exec(s)))
                            throw new SyntaxError("[sprintf] failed to parse named argument key");
                          c2.push(u[1]);
                        }
                      n2[2] = c2;
                    } else
                      i2 |= 2;
                    if (3 === i2)
                      throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
                    o2.push({ placeholder: n2[0], param_no: n2[1], keys: n2[2], sign: n2[3], pad_char: n2[4], align: n2[5], width: n2[6], precision: n2[7], type: n2[8] });
                  }
                  t2 = t2.substring(n2[0].length);
                }
                return a[e3] = o2;
              }(e2), arguments);
            }
            function c(e2, n2) {
              return i.apply(null, [e2].concat(n2 || []));
            }
            var a = /* @__PURE__ */ Object.create(null);
            n.sprintf = i, n.vsprintf = c, "undefined" != typeof window && (window.sprintf = i, window.vsprintf = c, void 0 === (o = (function() {
              return { sprintf: i, vsprintf: c };
            }).call(n, t, n, e)) || (e.exports = o));
          }();
        }, function(e, n, t) {
          "use strict";
          t.r(n), (function(e2) {
            t.d(n, "WebSocketManager", function() {
              return r;
            });
            var o = t(0);
            e2.connect = e2.connect || {}, connect.WebSocketManager = o.a;
            var r = o.a;
          }).call(this, t(3));
        }, function(e, n) {
          var t;
          t = /* @__PURE__ */ function() {
            return this;
          }();
          try {
            t = t || new Function("return this")();
          } catch (e2) {
            "object" == typeof window && (t = window);
          }
          e.exports = t;
        }]);
      }
    ),
    /***/
    151: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          var SOFTPHONE_LOG_REPORT_INTERVAL_MILLIS = 5e3;
          var LOGS_REPORT_INTERVAL_MILLIS = 5e3;
          var DEFAULT_LOG_ROLL_INTERVAL = 18e5;
          var OBFUSCATED_PREFIX = "[obfuscated value]";
          var LogLevel = {
            TEST: "TEST",
            TRACE: "TRACE",
            DEBUG: "DEBUG",
            INFO: "INFO",
            LOG: "LOG",
            WARN: "WARN",
            ERROR: "ERROR",
            CRITICAL: "CRITICAL"
          };
          var LogComponent = {
            CCP: "ccp",
            SOFTPHONE: "softphone",
            CHAT: "chat",
            TASK: "task"
          };
          var LogLevelOrder = {
            TEST: 0,
            TRACE: 10,
            DEBUG: 20,
            INFO: 30,
            LOG: 40,
            WARN: 50,
            ERROR: 100,
            CRITICAL: 200
          };
          var LogContextLayer = {
            CCP: "CCP",
            SHARED_WORKER: "SharedWorker",
            CRM: "CRM"
          };
          var CONSOLE_LOGGER_MAP = {
            TRACE: function(text) {
              console.info(text);
            },
            DEBUG: function(text) {
              console.info(text);
            },
            INFO: function(text) {
              console.info(text);
            },
            LOG: function(text) {
              console.log(text);
            },
            TEST: function(text) {
              console.log(text);
            },
            WARN: function(text) {
              console.warn(text);
            },
            ERROR: function(text) {
              console.error(text);
            },
            CRITICAL: function(text) {
              console.error(text);
            }
          };
          var isValidLogComponent = function(component) {
            return Object.values(LogComponent).indexOf(component) !== -1;
          };
          var extractLoggerArgs = function(loggerArgs) {
            var args = Array.prototype.slice.call(loggerArgs, 0);
            var firstArg = args.shift();
            var format;
            var component;
            if (isValidLogComponent(firstArg)) {
              component = firstArg;
              format = args.shift();
            } else {
              format = firstArg;
              component = LogComponent.CCP;
            }
            return {
              format,
              component,
              args
            };
          };
          var LogEntry = function(component, level, text, loggerId, tabId, contextLayer) {
            this.component = component;
            this.level = level;
            this.text = text;
            this.time = /* @__PURE__ */ new Date();
            this.tabId = tabId === null ? null : tabId ? tabId : connect2.core.tabId;
            this.exception = null;
            this.objects = [];
            this.line = 0;
            this.agentResourceId = null;
            try {
              if (connect2.agent.initialized) {
                this.agentResourceId = new connect2.Agent()._getResourceId();
              }
            } catch (e) {
              console.log("Issue finding agentResourceId: ", e);
            }
            this.loggerId = loggerId;
            if (contextLayer) {
              this.contextLayer = contextLayer;
            } else {
              if (connect2.isSharedWorker()) {
                this.contextLayer = LogContextLayer.SHARED_WORKER;
              } else if (connect2.isCRM()) {
                this.contextLayer = LogContextLayer.CRM;
              } else if (connect2.isCCP()) {
                this.contextLayer = LogContextLayer.CCP;
              }
            }
          };
          LogEntry.fromObject = function(obj) {
            var tabId = obj.tabId || null;
            var contextLayer = obj.contextLayer || null;
            var entry = new LogEntry(LogComponent.CCP, obj.level, obj.text, obj.loggerId, tabId, contextLayer);
            if (Object.prototype.toString.call(obj.time) === "[object Date]") {
              entry.time = new Date(obj.time.getTime());
            } else if (typeof obj.time === "number") {
              entry.time = new Date(obj.time);
            } else if (typeof obj.time === "string") {
              entry.time = Date.parse(obj.time);
            } else {
              entry.time = /* @__PURE__ */ new Date();
            }
            entry.exception = obj.exception;
            entry.objects = obj.objects;
            return entry;
          };
          var redactSensitiveInfo = function(data) {
            var authTokenRegex = /AuthToken.*\=/g;
            if (data && typeof data === "object") {
              Object.keys(data).forEach(function(key) {
                if (typeof data[key] === "object") {
                  redactSensitiveInfo(data[key]);
                } else if (typeof data[key] === "string") {
                  if (key === "url" || key === "text") {
                    data[key] = data[key].replace(authTokenRegex, "[redacted]");
                  } else if (["quickConnectName"].includes(key)) {
                    data[key] = "[redacted]";
                  } else if (["customerId", "CustomerId", "SpeakerId", "CustomerSpeakerId"].includes(key)) {
                    data[key] = `${OBFUSCATED_PREFIX} ${md5(data[key])}`;
                  }
                }
              });
            }
          };
          var LoggedException = function(e) {
            this.type = e instanceof Error ? e.name : e.code || Object.prototype.toString.call(e);
            this.message = e.message;
            this.stack = [];
            if (e.stack) {
              try {
                if (Array.isArray(e.stack)) {
                  this.stack = e.stack;
                } else if (typeof e.stack === "object") {
                  this.stack = [JSON.stringify(e.stack)];
                } else if (typeof e.stack === "string") {
                  this.stack = e.stack.split("\n");
                }
              } catch {
              }
            }
          };
          LogEntry.prototype.toString = function() {
            return connect2.sprintf(
              "[%s] [%s] [%s]: %s",
              this.getTime() && this.getTime().toISOString ? this.getTime().toISOString() : "???",
              this.getLevel(),
              this.getAgentResourceId(),
              this.getText()
            );
          };
          LogEntry.prototype.getTime = function() {
            return this.time;
          };
          LogEntry.prototype.getAgentResourceId = function() {
            return this.agentResourceId;
          };
          LogEntry.prototype.getTabId = function() {
            return this.tabId;
          };
          LogEntry.prototype.getContextLayer = function() {
            return this.contextLayer;
          };
          LogEntry.prototype.getLevel = function() {
            return this.level;
          };
          LogEntry.prototype.getText = function() {
            return this.text;
          };
          LogEntry.prototype.getComponent = function() {
            return this.component;
          };
          LogEntry.prototype.withException = function(e) {
            this.exception = new LoggedException(e);
            return this;
          };
          LogEntry.prototype.withObject = function(obj) {
            var copiedObj = connect2.deepcopy(obj);
            redactSensitiveInfo(copiedObj);
            this.objects.push(copiedObj);
            return this;
          };
          LogEntry.prototype.withCrossOriginEventObject = function(obj) {
            var copiedObj = connect2.deepcopyCrossOriginEvent(obj);
            redactSensitiveInfo(copiedObj);
            this.objects.push(copiedObj);
            return this;
          };
          LogEntry.prototype.sendInternalLogToServer = function() {
            connect2.getLog()._serverBoundInternalLogs.push(this);
            return this;
          };
          var Logger = function() {
            this._logs = [];
            this._rolledLogs = [];
            this._logsToPush = [];
            this._serverBoundInternalLogs = [];
            this._echoLevel = LogLevelOrder.INFO;
            this._logLevel = LogLevelOrder.INFO;
            this._lineCount = 0;
            this._logRollInterval = 0;
            this._logRollTimer = null;
            this._loggerId = (/* @__PURE__ */ new Date()).getTime() + "-" + Math.random().toString(36).slice(2);
            this.setLogRollInterval(DEFAULT_LOG_ROLL_INTERVAL);
            this._startLogIndexToPush = 0;
          };
          Logger.prototype.setLogRollInterval = function(interval) {
            var self2 = this;
            if (!this._logRollTimer || interval !== this._logRollInterval) {
              if (this._logRollTimer) {
                global.clearInterval(this._logRollTimer);
              }
              this._logRollInterval = interval;
              this._logRollTimer = global.setInterval(function() {
                self2._rolledLogs = self2._logs;
                self2._logs = [];
                self2._startLogIndexToPush = 0;
                self2.info("Log roll interval occurred.");
              }, this._logRollInterval);
            } else {
              this.warn("Logger is already set to the given interval: %d", this._logRollInterval);
            }
          };
          Logger.prototype.setLogLevel = function(level) {
            if (level in LogLevelOrder) {
              this._logLevel = LogLevelOrder[level];
            } else {
              throw new Error("Unknown logging level: " + level);
            }
          };
          Logger.prototype.setEchoLevel = function(level) {
            if (level in LogLevelOrder) {
              this._echoLevel = LogLevelOrder[level];
            } else {
              throw new Error("Unknown logging level: " + level);
            }
          };
          Logger.prototype.write = function(component, level, text) {
            var logEntry = new LogEntry(component, level, text, this.getLoggerId());
            redactSensitiveInfo(logEntry);
            this.addLogEntry(logEntry);
            return logEntry;
          };
          Logger.prototype.addLogEntry = function(logEntry) {
            redactSensitiveInfo(logEntry);
            this._logs.push(logEntry);
            if (LogComponent.SOFTPHONE === logEntry.component) {
              this._logsToPush.push(logEntry);
            }
            if (logEntry.level in LogLevelOrder && LogLevelOrder[logEntry.level] >= this._logLevel) {
              if (LogLevelOrder[logEntry.level] >= this._echoLevel) {
                CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());
              }
              logEntry.line = this._lineCount++;
            }
          };
          Logger.prototype.sendInternalLogEntryToServer = function(logEntry) {
            this._serverBoundInternalLogs.push(logEntry);
            if (logEntry.level in LogLevelOrder && LogLevelOrder[logEntry.level] >= this._logLevel) {
              if (LogLevelOrder[logEntry.level] >= this._echoLevel) {
                CONSOLE_LOGGER_MAP[logEntry.getLevel()](logEntry.toString());
              }
              logEntry.line = this._lineCount++;
            }
          };
          Logger.prototype.clearObjects = function() {
            for (var x = 0; x < this._logs.length; x++) {
              if (this._logs[x].objects) {
                delete this._logs[x].objects;
              }
            }
          };
          Logger.prototype.clearExceptions = function() {
            for (var x = 0; x < this._logs.length; x++) {
              if (this._logs[x].exception) {
                delete this._logs[x].exception;
              }
            }
          };
          Logger.prototype.trace = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.TRACE, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.debug = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.DEBUG, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.info = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.INFO, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.log = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.LOG, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.test = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.TEST, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.warn = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.WARN, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.error = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.ERROR, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.critical = function() {
            var logArgs = extractLoggerArgs(arguments);
            return this.write(logArgs.component, LogLevel.ERROR, connect2.vsprintf(logArgs.format, logArgs.args));
          };
          Logger.prototype.toString = function() {
            var lines = [];
            for (var x = 0; x < this._logs.length; x++) {
              lines.push(this._logs[x].toString());
            }
            return lines.join("\n");
          };
          Logger.prototype.download = function(options) {
            var logName = "agent-log";
            var filterByLogLevel = false;
            if (typeof options === "object") {
              logName = options.logName || logName;
              filterByLogLevel = options.filterByLogLevel || filterByLogLevel;
            } else if (typeof options === "string") {
              logName = options || logName;
            }
            var self2 = this;
            var logs = this._rolledLogs.concat(this._logs);
            if (filterByLogLevel) {
              logs = logs.filter(function(entry) {
                return LogLevelOrder[entry.level] >= self2._logLevel;
              });
            }
            var logBlob = new global.Blob([JSON.stringify(logs, void 0, 4)], ["text/plain"]);
            var downloadLink = document.createElement("a");
            var logName = logName || "agent-log";
            downloadLink.href = global.URL.createObjectURL(logBlob);
            downloadLink.download = logName + ".txt";
            document.body.appendChild(downloadLink);
            downloadLink.click();
            document.body.removeChild(downloadLink);
          };
          Logger.prototype.scheduleUpstreamLogPush = function(conduit) {
            if (!connect2.upstreamLogPushScheduled) {
              connect2.upstreamLogPushScheduled = true;
              global.setInterval(connect2.hitch(this, this.reportMasterLogsUpStream, conduit), SOFTPHONE_LOG_REPORT_INTERVAL_MILLIS);
            }
          };
          Logger.prototype.reportMasterLogsUpStream = function(conduit) {
            var logsToPush = this._logsToPush.slice();
            this._logsToPush = [];
            connect2.ifMaster(connect2.MasterTopics.SEND_LOGS, function() {
              if (logsToPush.length > 0) {
                conduit.sendUpstream(connect2.EventType.SEND_LOGS, logsToPush);
              }
            });
          };
          Logger.prototype.scheduleUpstreamOuterContextCCPserverBoundLogsPush = function(conduit) {
            global.setInterval(connect2.hitch(this, this.pushOuterContextCCPserverBoundLogsUpstream, conduit), 1e3);
          };
          Logger.prototype.scheduleUpstreamOuterContextCCPLogsPush = function(conduit) {
            global.setInterval(connect2.hitch(this, this.pushOuterContextCCPLogsUpstream, conduit), 1e3);
          };
          Logger.prototype.pushOuterContextCCPserverBoundLogsUpstream = function(conduit) {
            if (this._serverBoundInternalLogs.length > 0) {
              for (var i = 0; i < this._serverBoundInternalLogs.length; i++) {
                this._serverBoundInternalLogs[i].text = this._serverBoundInternalLogs[i].text;
              }
              conduit.sendUpstream(connect2.EventType.SERVER_BOUND_INTERNAL_LOG, this._serverBoundInternalLogs);
              this._serverBoundInternalLogs = [];
            }
          };
          Logger.prototype.pushOuterContextCCPLogsUpstream = function(conduit) {
            for (var i = this._startLogIndexToPush; i < this._logs.length; i++) {
              if (this._logs[i].loggerId !== this._loggerId) {
                continue;
              }
              conduit.sendUpstream(connect2.EventType.LOG, this._logs[i]);
            }
            this._startLogIndexToPush = this._logs.length;
          };
          Logger.prototype.getLoggerId = function() {
            return this._loggerId;
          };
          Logger.prototype.scheduleDownstreamClientSideLogsPush = function() {
            global.setInterval(connect2.hitch(this, this.pushClientSideLogsDownstream), LOGS_REPORT_INTERVAL_MILLIS);
          };
          Logger.prototype.pushClientSideLogsDownstream = function() {
            var logs = [];
            if (this._serverBoundInternalLogs.length < 50) {
              return;
            } else if (this._serverBoundInternalLogs.length > 500) {
              logs = this._serverBoundInternalLogs.splice(0, 500);
            } else {
              logs = this._serverBoundInternalLogs;
              this._serverBoundInternalLogs = [];
            }
            connect2.publishClientSideLogs(logs);
          };
          var DownstreamConduitLogger = function(conduit) {
            Logger.call(this);
            this.conduit = conduit;
            global.setInterval(
              connect2.hitch(this, this._pushLogsDownstream),
              DownstreamConduitLogger.LOG_PUSH_INTERVAL
            );
            global.clearInterval(this._logRollTimer);
            this._logRollTimer = null;
          };
          DownstreamConduitLogger.LOG_PUSH_INTERVAL = 1e3;
          DownstreamConduitLogger.prototype = Object.create(Logger.prototype);
          DownstreamConduitLogger.prototype.constructor = DownstreamConduitLogger;
          DownstreamConduitLogger.prototype.pushLogsDownstream = function(logs) {
            var self2 = this;
            logs.forEach(function(log2) {
              self2.conduit.sendDownstream(connect2.EventType.LOG, log2);
            });
          };
          DownstreamConduitLogger.prototype._pushLogsDownstream = function() {
            var self2 = this;
            this._logs.forEach(function(log2) {
              self2.conduit.sendDownstream(connect2.EventType.LOG, log2);
            });
            this._logs = [];
            for (var i = 0; i < this._serverBoundInternalLogs.length; i++) {
              this.conduit.sendDownstream(connect2.EventType.SERVER_BOUND_INTERNAL_LOG, this._serverBoundInternalLogs[i]);
            }
            this._serverBoundInternalLogs = [];
          };
          var tryCatchWrapperMethod = function(fn) {
            var wrappedfunction = function() {
              try {
                return fn.apply(this, arguments);
              } catch (e) {
                CONSOLE_LOGGER_MAP.ERROR(e);
              }
            };
            return wrappedfunction;
          };
          var tryCatchWrapperObject = function(obj) {
            for (var method in obj) {
              if (typeof obj[method] === "function") {
                obj[method] = tryCatchWrapperMethod(obj[method]);
              }
            }
          };
          connect2.rootLogger = new Logger();
          tryCatchWrapperObject(connect2.rootLogger);
          var getLog = function() {
            return connect2.rootLogger;
          };
          connect2 = connect2 || {};
          connect2.getLog = getLog;
          connect2.LogEntry = LogEntry;
          connect2.Logger = Logger;
          connect2.LogLevel = LogLevel;
          connect2.LogComponent = LogComponent;
          connect2.DownstreamConduitLogger = DownstreamConduitLogger;
        })();
      }
    ),
    /***/
    163: (
      /***/
      function() {
        ;
        (function($) {
          var ctx = this || globalThis;
          function safeAdd(x, y) {
            var lsw = (x & 65535) + (y & 65535);
            var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
            return msw << 16 | lsw & 65535;
          }
          function bitRotateLeft(num, cnt) {
            return num << cnt | num >>> 32 - cnt;
          }
          function md5cmn(q, a, b, x, s, t) {
            return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
          }
          function md5ff(a, b, c, d, x, s, t) {
            return md5cmn(b & c | ~b & d, a, b, x, s, t);
          }
          function md5gg(a, b, c, d, x, s, t) {
            return md5cmn(b & d | c & ~d, a, b, x, s, t);
          }
          function md5hh(a, b, c, d, x, s, t) {
            return md5cmn(b ^ c ^ d, a, b, x, s, t);
          }
          function md5ii(a, b, c, d, x, s, t) {
            return md5cmn(c ^ (b | ~d), a, b, x, s, t);
          }
          function binlMD5(x, len) {
            x[len >> 5] |= 128 << len % 32;
            x[(len + 64 >>> 9 << 4) + 14] = len;
            var i;
            var olda;
            var oldb;
            var oldc;
            var oldd;
            var a = 1732584193;
            var b = -271733879;
            var c = -1732584194;
            var d = 271733878;
            for (i = 0; i < x.length; i += 16) {
              olda = a;
              oldb = b;
              oldc = c;
              oldd = d;
              a = md5ff(a, b, c, d, x[i], 7, -680876936);
              d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
              c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
              b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
              a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
              d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
              c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
              b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
              a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
              d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
              c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
              b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
              a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
              d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
              c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
              b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
              a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
              d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
              c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
              b = md5gg(b, c, d, a, x[i], 20, -373897302);
              a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
              d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
              c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
              b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
              a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
              d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
              c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
              b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
              a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
              d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
              c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
              b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
              a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
              d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
              c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
              b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
              a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
              d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
              c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
              b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
              a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
              d = md5hh(d, a, b, c, x[i], 11, -358537222);
              c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
              b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
              a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
              d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
              c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
              b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
              a = md5ii(a, b, c, d, x[i], 6, -198630844);
              d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
              c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
              b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
              a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
              d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
              c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
              b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
              a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
              d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
              c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
              b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
              a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
              d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
              c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
              b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
              a = safeAdd(a, olda);
              b = safeAdd(b, oldb);
              c = safeAdd(c, oldc);
              d = safeAdd(d, oldd);
            }
            return [a, b, c, d];
          }
          function binl2rstr(input) {
            var i;
            var output = "";
            var length32 = input.length * 32;
            for (i = 0; i < length32; i += 8) {
              output += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
            }
            return output;
          }
          function rstr2binl(input) {
            var i;
            var output = [];
            output[(input.length >> 2) - 1] = void 0;
            for (i = 0; i < output.length; i += 1) {
              output[i] = 0;
            }
            var length8 = input.length * 8;
            for (i = 0; i < length8; i += 8) {
              output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
            }
            return output;
          }
          function rstrMD5(s) {
            return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
          }
          function rstrHMACMD5(key, data) {
            var i;
            var bkey = rstr2binl(key);
            var ipad = [];
            var opad = [];
            var hash;
            ipad[15] = opad[15] = void 0;
            if (bkey.length > 16) {
              bkey = binlMD5(bkey, key.length * 8);
            }
            for (i = 0; i < 16; i += 1) {
              ipad[i] = bkey[i] ^ 909522486;
              opad[i] = bkey[i] ^ 1549556828;
            }
            hash = binlMD5(ipad.concat(rstr2binl(data)), 512 + data.length * 8);
            return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
          }
          function rstr2hex(input) {
            var hexTab = "0123456789abcdef";
            var output = "";
            var x;
            var i;
            for (i = 0; i < input.length; i += 1) {
              x = input.charCodeAt(i);
              output += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
            }
            return output;
          }
          function str2rstrUTF8(input) {
            return unescape(encodeURIComponent(input));
          }
          function rawMD5(s) {
            return rstrMD5(str2rstrUTF8(s));
          }
          function hexMD5(s) {
            return rstr2hex(rawMD5(s));
          }
          function rawHMACMD5(k, d) {
            return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
          }
          function hexHMACMD5(k, d) {
            return rstr2hex(rawHMACMD5(k, d));
          }
          function md52(string, key, raw) {
            if (!key) {
              if (!raw) {
                return hexMD5(string);
              }
              return rawMD5(string);
            }
            if (!raw) {
              return hexHMACMD5(key, string);
            }
            return rawHMACMD5(key, string);
          }
          ctx.md5 = md52;
        })(this);
      }
    ),
    /***/
    439: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          connect2.ChatMediaController = function(mediaInfo, metadata) {
            var logger = connect2.getLog();
            var logComponent = connect2.LogComponent.CHAT;
            var createMediaInstance = function() {
              publishTelemetryEvent("Chat media controller init", mediaInfo.contactId);
              logger.info(logComponent, "Chat media controller init").withObject(mediaInfo).sendInternalLogToServer();
              connect2.ChatSession.setGlobalConfig({
                loggerConfig: {
                  logger
                },
                region: metadata.region
              });
              var controller = connect2.ChatSession.create({
                chatDetails: mediaInfo,
                type: "AGENT",
                websocketManager: connect2.core.getWebSocketManager()
              });
              trackChatConnectionStatus(controller);
              return controller.connect().then(function(data) {
                logger.info(logComponent, "Chat Session Successfully established for contactId %s", mediaInfo.contactId).sendInternalLogToServer();
                publishTelemetryEvent("Chat Session Successfully established", mediaInfo.contactId);
                return controller;
              }).catch(function(error) {
                logger.error(logComponent, "Chat Session establishement failed for contact %s", mediaInfo.contactId).withException(error).sendInternalLogToServer();
                publishTelemetryEvent("Chat Session establishement failed", mediaInfo.contactId, error);
                throw error;
              });
            };
            var publishTelemetryEvent = function(eventName, data) {
              connect2.publishMetric({
                name: eventName,
                contactId: mediaInfo.contactId,
                data: data || mediaInfo
              });
            };
            var trackChatConnectionStatus = function(controller) {
              controller.onConnectionBroken(function(data) {
                logger.error(logComponent, "Chat Session connection broken").withException(data).sendInternalLogToServer();
                publishTelemetryEvent("Chat Session connection broken", data);
              });
              controller.onConnectionEstablished(function(data) {
                logger.info(logComponent, "Chat Session connection established").withObject(data).sendInternalLogToServer();
                publishTelemetryEvent("Chat Session connection established", data);
              });
            };
            return {
              get: function() {
                return createMediaInstance();
              }
            };
          };
        })();
      }
    ),
    /***/
    279: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          connect2.MediaFactory = function(params) {
            var mediaControllers = {};
            var toBeDestroyed = /* @__PURE__ */ new Set();
            var logger = connect2.getLog();
            var logComponent = connect2.LogComponent.CHAT;
            var metadata = connect2.merge({}, params) || {};
            metadata.region = metadata.region || "us-west-2";
            var getMediaController = function(connectionObj) {
              var connectionId = connectionObj.getConnectionId();
              var mediaInfo = connectionObj.getMediaInfo();
              if (!mediaInfo) {
                logger.error(logComponent, "Media info does not exist for a media type %s", connectionObj.getMediaType()).withObject(connectionObj).sendInternalLogToServer();
                return Promise.reject("Media info does not exist for this connection");
              }
              if (!mediaControllers[connectionId]) {
                logger.info(logComponent, "media controller of type %s init", connectionObj.getMediaType()).withObject(connectionObj).sendInternalLogToServer();
                switch (connectionObj.getMediaType()) {
                  case connect2.MediaType.CHAT:
                    return mediaControllers[connectionId] = new connect2.ChatMediaController(
                      connectionObj.getMediaInfo(),
                      metadata
                    ).get();
                  case connect2.MediaType.SOFTPHONE:
                    return mediaControllers[connectionId] = new connect2.SoftphoneMediaController(
                      connectionObj.getMediaInfo()
                    ).get();
                  case connect2.MediaType.TASK:
                    return mediaControllers[connectionId] = new connect2.TaskMediaController(
                      connectionObj.getMediaInfo()
                    ).get();
                  default:
                    logger.error(logComponent, "Unrecognized media type %s ", connectionObj.getMediaType()).sendInternalLogToServer();
                    return Promise.reject();
                }
              } else {
                return mediaControllers[connectionId];
              }
            };
            var ifConnectionActive = function(connectionObj) {
              return connectionObj.isActive();
            };
            var get = function(connectionObj) {
              if (ifConnectionActive(connectionObj)) {
                return getMediaController(connectionObj);
              } else {
                destroy(connectionObj.getConnectionId());
                return Promise.reject("Media Controller is no longer available for this connection");
              }
            };
            var destroy = function(connectionId) {
              if (mediaControllers[connectionId] && !toBeDestroyed.has(connectionId)) {
                logger.info(logComponent, "Destroying mediaController for %s", connectionId);
                toBeDestroyed.add(connectionId);
                mediaControllers[connectionId].then(function(controller) {
                  if (typeof controller.cleanUp === "function")
                    controller.cleanUp();
                  delete mediaControllers[connectionId];
                  toBeDestroyed.delete(connectionId);
                }).catch(function() {
                  delete mediaControllers[connectionId];
                  toBeDestroyed.delete(connectionId);
                });
              }
            };
            return {
              get,
              destroy
            };
          };
        })();
      }
    ),
    /***/
    418: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          connect2.SoftphoneMediaController = function(mediaInfo) {
            return {
              get: function() {
                return Promise.resolve(mediaInfo);
              }
            };
          };
        })();
      }
    ),
    /***/
    187: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          connect2.TaskMediaController = function(mediaInfo) {
            var logger = connect2.getLog();
            var logComponent = connect2.LogComponent.TASK;
            var createMediaInstance = function() {
              publishTelemetryEvent("Task media controller init", mediaInfo.contactId);
              logger.info(logComponent, "Task media controller init").withObject(mediaInfo);
              var controller = connect2.TaskSession.create({
                contactId: mediaInfo.contactId,
                initialContactId: mediaInfo.initialContactId,
                websocketManager: connect2.core.getWebSocketManager()
              });
              trackTaskConnectionStatus(controller);
              return controller.connect().then(function() {
                logger.info(logComponent, "Task Session Successfully established for contactId %s", mediaInfo.contactId);
                publishTelemetryEvent("Task Session Successfully established", mediaInfo.contactId);
                return controller;
              }).catch(function(error) {
                logger.error(logComponent, "Task Session establishement failed for contact %s", mediaInfo.contactId).withException(error);
                publishTelemetryEvent("Chat Session establishement failed", mediaInfo.contactId, error);
                throw error;
              });
            };
            var publishTelemetryEvent = function(eventName, data) {
              connect2.publishMetric({
                name: eventName,
                contactId: mediaInfo.contactId,
                data: data || mediaInfo
              });
            };
            var trackTaskConnectionStatus = function(controller) {
              controller.onConnectionBroken(function(data) {
                logger.error(logComponent, "Task Session connection broken").withException(data);
                publishTelemetryEvent("Task Session connection broken", data);
              });
              controller.onConnectionEstablished(function(data) {
                logger.info(logComponent, "Task Session connection established").withObject(data);
                publishTelemetryEvent("Task Session connection established", data);
              });
            };
            return {
              get: function() {
                return createMediaInstance();
              }
            };
          };
        })();
      }
    ),
    /***/
    161: (
      /***/
      () => {
        (function() {
          const global = this || globalThis;
          const connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          const requestStorageAccessPath = "/request-storage-access";
          const defaultStorageAccessParams = {
            /* Config which controls the opt out/in - we expect customers to explicitely opt out. */
            canRequest: true,
            /* ["custom", "default"] - decides the rsa page view */
            mode: "default",
            custom: {
              hideCCP: true
              // only applicable in custom mode
              /**
               * Only applicable for custom type RSA page and these messages should be localized by customers
               *
               * title: 'Cookie Notice',
               * header: 'Please provide access'
               *
               */
            }
          };
          let storageParams = {};
          let originalCCPUrl = "";
          let rsaContainer = null;
          let onGrantCallbackInvoked = false;
          let requesthandlerUnsubscriber;
          const storageAccessEvents = {
            INIT: "storageAccess::init",
            GRANTED: "storageAccess::granted",
            DENIED: "storageAccess::denied",
            REQUEST: "storageAccess::request"
          };
          const initStorageParams = (params = {}) => {
            params.custom = params.custom || {};
            storageParams = {
              ...defaultStorageAccessParams,
              ...params,
              custom: {
                ...defaultStorageAccessParams.custom,
                ...params.custom
              }
            };
            storageParams.canRequest = !(storageParams.canRequest === "false" || storageParams.canRequest === false);
          };
          const resetStorageAccessState = () => {
            storageParams = {};
            originalCCPUrl = "";
            rsaContainer = null;
            onGrantCallbackInvoked = false;
          };
          const getRSAContainer = () => ({
            show: () => {
              rsaContainer.style.display = "block";
            },
            hide: () => {
              rsaContainer.style.display = "none";
            }
          });
          const isCustomRequestAccessMode = () => storageParams && storageParams.mode === "custom";
          const hideCCP = () => {
            var _a;
            return (_a = storageParams == null ? void 0 : storageParams.custom) == null ? void 0 : _a.hideCCP;
          };
          const isConnectDomain = (origin) => origin.match(/.connect.aws.a2z.com|.my.connect.aws|.govcloud.connect.aws|.awsapps.com/);
          const getRsaUrlWithprefix = (url) => {
            const { origin, pathname } = new URL(url);
            if (origin.match(/.awsapps.com/)) {
              let prefix = "connect";
              if (pathname.startsWith("/connect-gamma")) {
                prefix = "connect-gamma";
              }
              return `${origin}/${prefix}${requestStorageAccessPath}`;
            } else {
              return `${origin}${requestStorageAccessPath}`;
            }
          };
          const isLocalhost = (url) => url.match(/^https?:\/\/localhost/);
          const getlandAtPath = () => {
            if (!originalCCPUrl) {
              throw new Error("[StorageAccess] [getlandAtPath] Invoke connect.storageAccess.init first");
            }
            if (isConnectDomain(originalCCPUrl) || isLocalhost(originalCCPUrl)) {
              const { pathname } = new URL(originalCCPUrl);
              return pathname;
            }
            return "/connect/ccp-v2";
          };
          const getRequestStorageAccessUrl = () => {
            if (!originalCCPUrl) {
              throw new Error("[StorageAccess] [getRequestStorageAccessUrl] Invoke connect.storageAccess.init first");
            }
            if (isConnectDomain(originalCCPUrl)) {
              return getRsaUrlWithprefix(originalCCPUrl);
            } else if (isLocalhost(originalCCPUrl)) {
              connect2.getLog().info(`[StorageAccess] [CCP] Local testing`);
              return `${originalCCPUrl}${requestStorageAccessPath}`;
            } else if (storageParams.instanceUrl && isConnectDomain(storageParams.instanceUrl)) {
              connect2.getLog().info(
                `[StorageAccess] [getRequestStorageAccessUrl] Customer has provided storageParams.instanceUrl ${storageParams.instanceUrl}`
              );
              return getRsaUrlWithprefix(storageParams.instanceUrl);
            } else if (storageParams.instanceUrl && isLocalhost(storageParams.instanceUrl)) {
              connect2.getLog().info(`[StorageAccess] [getRequestStorageAccessUrl] Local testing`);
              return `${storageParams.instanceUrl}${requestStorageAccessPath}`;
            } else {
              connect2.getLog().error(
                `[StorageAccess] [getRequestStorageAccessUrl] Invalid Connect instance/CCP URL provided, please pass the correct ccpUrl or storageAccess.instanceUrl parameters`
              );
              throw new Error(
                `[StorageAccess] [getRequestStorageAccessUrl] Invalid Connect instance/CCP URL provided, please pass the valid Connect CCP URL or in case CCP URL is configured to be the SSO URL then use storageAccess.instanceUrl and pass the Connect CCP URL`
              );
            }
          };
          const onRequestHandler = ({ onInit, onDeny, onGrant }) => {
            function handleUpstreamMessages({ data, source }) {
              const iframeContainer = connect2.core._getCCPIframe();
              if (iframeContainer.contentWindow !== source) {
                return false;
              }
              if (connect2.core.initialized) {
                window.removeEventListener("message", handleUpstreamMessages);
              }
              switch (data.event) {
                case storageAccessEvents.INIT: {
                  connect2.getLog().info(`[StorageAccess][INIT] message recieved`).withObject(data);
                  if (onInit) {
                    onInit(data);
                  }
                  break;
                }
                case storageAccessEvents.GRANTED: {
                  connect2.getLog().info(`[StorageAccess][GRANTED] message recieved`).withObject(data);
                  if (onGrant) {
                    onGrant(data);
                  }
                  break;
                }
                case storageAccessEvents.DENIED: {
                  connect2.getLog().info(`[StorageAccess][DENIED] message recieved`).withObject(data);
                  if (onDeny) {
                    onDeny(data);
                  }
                  break;
                }
                default: {
                  if (connect2.core.initialized) {
                    window.removeEventListener("message", handleUpstreamMessages);
                  }
                  break;
                }
              }
            }
            if (storageParams.canRequest) {
              window.addEventListener("message", handleUpstreamMessages);
            }
            return {
              unsubscribe: () => {
                window.removeEventListener("message", handleUpstreamMessages);
              }
            };
          };
          const setupRequestHandlers = ({ onGrant: onGrantCallback }) => {
            if (requesthandlerUnsubscriber) {
              requesthandlerUnsubscriber.unsubscribe();
            }
            requesthandlerUnsubscriber = onRequestHandler({
              onInit: (messageData) => {
                console.log("%c[StorageAccess][INIT]", "background:yellow; color:black; font-size:large");
                connect2.getLog().info(`[StorageAccess][onInit] callback executed`).withObject(messageData == null ? void 0 : messageData.data);
                if (!(messageData == null ? void 0 : messageData.data.hasAccess) && isCustomRequestAccessMode()) {
                  getRSAContainer().show();
                }
              },
              onDeny: () => {
                console.log("%c[StorageAccess][DENIED]", "background:red; color:black; font-size:large");
                connect2.getLog().info(`[StorageAccess][onDeny] callback executed`);
                if (isCustomRequestAccessMode()) {
                  getRSAContainer().show();
                }
              },
              onGrant: () => {
                console.log("%c[StorageAccess][GRANTED]", "background:lime; color:black; font-size:large");
                connect2.getLog().info(`[StorageAccess][onGrant] callback executed`);
                if (isCustomRequestAccessMode() && hideCCP()) {
                  getRSAContainer().hide();
                }
                if (!onGrantCallbackInvoked) {
                  onGrantCallback();
                  onGrantCallbackInvoked = true;
                }
              }
            });
          };
          connect2.storageAccess = Object.freeze({
            /**
             * Checks wther user has opted out for storage Access checks or not
             * @returns {boolean}
             */
            canRequest: () => storageParams.canRequest,
            /**
             * Mainly used by Tests, by default storage access is enabled for all
             */
            optOutFromRequestAccess: () => {
              defaultStorageAccessParams.canRequest = false;
            },
            /**
             * Mainly used by Tests
             */
            optInForRequestAccess: () => {
              defaultStorageAccessParams.canRequest = true;
            },
            /**
             * Method which inits the Storage Access module with Customer paramters.
             * and generates request storage access URL and apply customization to the default paramters
             * @param {*} params -  storage access params
             * @param {*} container - Container where CCP is being shown
             * @returns {{canRequest, requestAccessPageurl}}
             */
            init: (ccpUrl, containerDiv, params = {}) => {
              connect2.assertNotNull(ccpUrl, "ccpUrl");
              connect2.assertNotNull(containerDiv, "container");
              rsaContainer = containerDiv;
              originalCCPUrl = ccpUrl;
              initStorageParams(params);
              connect2.getLog().info(
                `[StorageAccess][init] Request Storage Acccess init called with ccpUrl - ${ccpUrl} - ${!storageParams.canRequest ? "user has opted out, skipping request storage access" : "Proceeding with requesting storage access"}`
              ).withObject(storageParams);
            },
            setupRequestHandlers,
            getRequestStorageAccessUrl,
            storageAccessEvents,
            resetStorageAccessState,
            getOnGrantCallbackInvoked: () => onGrantCallbackInvoked,
            getStorageAccessParams: () => storageParams,
            onRequest: onRequestHandler,
            request: () => {
              const iframeContainer = connect2.core._getCCPIframe();
              iframeContainer.contentWindow.postMessage(
                {
                  event: storageAccessEvents.REQUEST,
                  data: { ...storageParams, landat: getlandAtPath() }
                },
                "*"
              );
            }
          });
        })();
      }
    ),
    /***/
    743: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          var RingtoneEngineBase = function(ringtoneConfig) {
            var self2 = this;
            this._prevContactId = null;
            connect2.assertNotNull(ringtoneConfig, "ringtoneConfig");
            if (!ringtoneConfig.ringtoneUrl) {
              throw new Error("ringtoneUrl is required!");
            }
            if (global.Audio && typeof global.Promise !== "undefined") {
              this._playableAudioPromise = new Promise(function(resolve, reject) {
                self2._audio = new Audio(ringtoneConfig.ringtoneUrl);
                self2._audio.loop = true;
                self2._audio.addEventListener("canplay", function() {
                  connect2.getLog().info("Ringtone is ready to play: ", +ringtoneConfig.ringtoneUrl).sendInternalLogToServer();
                  self2._audioPlayable = true;
                  resolve(self2._audio);
                });
              });
            } else {
              this._audio = null;
              connect2.getLog().error("Unable to provide a ringtone.").sendInternalLogToServer();
            }
            self2._driveRingtone();
          };
          RingtoneEngineBase.prototype._driveRingtone = function() {
            throw new Error("Not implemented.");
          };
          RingtoneEngineBase.prototype._startRingtone = function(contact) {
            var self2 = this;
            if (this._audio) {
              this._audio.play().then(function() {
                self2._publishTelemetryEvent("Ringtone Start", contact);
                connect2.getLog().info("Ringtone Start").sendInternalLogToServer();
              }).catch(function(e) {
                self2._publishTelemetryEvent("Ringtone Playback Failure", contact);
                connect2.getLog().error("Ringtone Playback Failure").withException(e).withObject({ currentSrc: self2._audio.currentSrc, sinkId: self2._audio.sinkId, volume: self2._audio.volume }).sendInternalLogToServer();
              });
              connect2.getLog().info(`Attempting to start ringtone to device ${this._audio.sinkId || "''"}`).sendInternalLogToServer();
            }
          };
          RingtoneEngineBase.prototype._stopRingtone = function(contact) {
            if (this._audio) {
              this._audio.pause();
              this._audio.currentTime = 0;
              this._publishTelemetryEvent("Ringtone Stop", contact);
              connect2.getLog().info("Ringtone Stop").sendInternalLogToServer();
            }
          };
          RingtoneEngineBase.prototype.stopRingtone = function() {
            this._stopRingtone();
          };
          RingtoneEngineBase.prototype._ringtoneSetup = function(contact) {
            var self2 = this;
            connect2.ifMaster(connect2.MasterTopics.RINGTONE, function() {
              self2._startRingtone(contact);
              self2._prevContactId = contact.getContactId();
              contact.onConnected(lily.hitch(self2, self2._stopRingtone));
              contact.onAccepted(lily.hitch(self2, self2._stopRingtone));
              contact.onEnded(lily.hitch(self2, self2._stopRingtone));
              contact.onRefresh(function(contact2) {
                if (contact2.getStatus().type !== connect2.ContactStatusType.CONNECTING && contact2.getStatus().type !== connect2.ContactStatusType.INCOMING) {
                  self2._stopRingtone();
                }
              });
            });
          };
          RingtoneEngineBase.prototype._publishTelemetryEvent = function(eventName, contact) {
            if (contact && contact.getContactId()) {
              connect2.publishMetric({
                name: eventName,
                contactId: contact.getContactId()
              });
            }
          };
          RingtoneEngineBase.prototype.setOutputDevice = function(deviceId) {
            if (this._playableAudioPromise) {
              var playableAudioWithTimeout = Promise.race([
                this._playableAudioPromise,
                new Promise(function(resolve, reject) {
                  global.setTimeout(
                    function() {
                      reject("Timed out waiting for playable audio");
                    },
                    3e3
                    /*ms*/
                  );
                })
              ]);
              return playableAudioWithTimeout.then(function(audio) {
                if (audio && audio.setSinkId) {
                  return audio.setSinkId(deviceId).then(function() {
                    return Promise.resolve(deviceId);
                  }).catch(function(err) {
                    return Promise.reject(`RingtoneEngineBase.setOutputDevice failed: audio.setSinkId() failed with error ${err}`);
                  });
                } else {
                  return Promise.reject(`RingtoneEngineBase.setOutputDevice failed: ${audio ? "audio" : "audio.setSinkId"} not found.`);
                }
              });
            }
            if (global.Promise) {
              return Promise.reject("Not eligible ringtone owner");
            }
          };
          var VoiceRingtoneEngine = function(ringtoneConfig) {
            RingtoneEngineBase.call(this, ringtoneConfig);
          };
          VoiceRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
          VoiceRingtoneEngine.prototype.constructor = VoiceRingtoneEngine;
          VoiceRingtoneEngine.prototype._driveRingtone = function() {
            var self2 = this;
            var onContactConnect = function(contact) {
              if (contact.getType() === lily.ContactType.VOICE && contact.isSoftphoneCall() && contact.isInbound()) {
                self2._ringtoneSetup(contact);
                self2._publishTelemetryEvent("Ringtone Connecting", contact);
                connect2.getLog().info("Ringtone Connecting").sendInternalLogToServer();
              }
            };
            connect2.contact(function(contact) {
              contact.onConnecting(onContactConnect);
            });
            new connect2.Agent().getContacts().forEach(function(contact) {
              if (contact.getStatus().type === connect2.ContactStatusType.CONNECTING) {
                onContactConnect(contact);
              }
            });
          };
          var ChatRingtoneEngine = function(ringtoneConfig) {
            RingtoneEngineBase.call(this, ringtoneConfig);
          };
          ChatRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
          ChatRingtoneEngine.prototype.constructor = ChatRingtoneEngine;
          ChatRingtoneEngine.prototype._driveRingtone = function() {
            var self2 = this;
            var onContactConnect = function(contact) {
              if (contact.getType() === lily.ContactType.CHAT && contact.isInbound()) {
                var supervisorConnection = contact.getConnections().filter((conn) => conn.getType() === connect2.ConnectionType.AGENT && conn.isSilentMonitor());
                if (supervisorConnection.length === 0) {
                  self2._ringtoneSetup(contact);
                  self2._publishTelemetryEvent("Chat Ringtone Connecting", contact);
                  connect2.getLog().info("Chat Ringtone Connecting").sendInternalLogToServer();
                }
              }
            };
            connect2.contact(function(contact) {
              contact.onConnecting(onContactConnect);
            });
          };
          var TaskRingtoneEngine = function(ringtoneConfig) {
            RingtoneEngineBase.call(this, ringtoneConfig);
          };
          TaskRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
          TaskRingtoneEngine.prototype.constructor = TaskRingtoneEngine;
          TaskRingtoneEngine.prototype._driveRingtone = function() {
            var self2 = this;
            var onContactConnect = function(contact) {
              if (contact.getType() === lily.ContactType.TASK && contact.isInbound()) {
                self2._ringtoneSetup(contact);
                self2._publishTelemetryEvent("Task Ringtone Connecting", contact);
                connect2.getLog().info("Task Ringtone Connecting").sendInternalLogToServer();
              }
            };
            connect2.contact(function(contact) {
              contact.onConnecting(onContactConnect);
            });
          };
          var QueueCallbackRingtoneEngine = function(ringtoneConfig) {
            RingtoneEngineBase.call(this, ringtoneConfig);
          };
          QueueCallbackRingtoneEngine.prototype = Object.create(RingtoneEngineBase.prototype);
          QueueCallbackRingtoneEngine.prototype.constructor = QueueCallbackRingtoneEngine;
          QueueCallbackRingtoneEngine.prototype._driveRingtone = function() {
            var self2 = this;
            connect2.contact(function(contact) {
              contact.onIncoming(function() {
                if (contact.getType() === lily.ContactType.QUEUE_CALLBACK) {
                  self2._ringtoneSetup(contact);
                  self2._publishTelemetryEvent("Callback Ringtone Connecting", contact);
                  connect2.getLog().info("Callback Ringtone Connecting").sendInternalLogToServer();
                }
              });
            });
          };
          connect2.VoiceRingtoneEngine = VoiceRingtoneEngine;
          connect2.ChatRingtoneEngine = ChatRingtoneEngine;
          connect2.TaskRingtoneEngine = TaskRingtoneEngine;
          connect2.QueueCallbackRingtoneEngine = QueueCallbackRingtoneEngine;
        })();
      }
    ),
    /***/
    642: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          global.ccpVersion = "V2";
          const VDIPlatformType = {
            CITRIX: "CITRIX"
          };
          var RTPJobIntervalMs = 1e3;
          var statsReportingJobIntervalMs = 3e4;
          var streamBufferSize = 500;
          var CallTypeMap = {};
          CallTypeMap[connect2.SoftphoneCallType.AUDIO_ONLY] = "Audio";
          CallTypeMap[connect2.SoftphoneCallType.VIDEO_ONLY] = "Video";
          CallTypeMap[connect2.SoftphoneCallType.AUDIO_VIDEO] = "AudioVideo";
          CallTypeMap[connect2.SoftphoneCallType.NONE] = "None";
          var AUDIO_INPUT = "audio_input";
          var AUDIO_OUTPUT = "audio_output";
          var MediaTypeMap = {};
          MediaTypeMap[connect2.ContactType.VOICE] = "Voice";
          var UNKNOWN_MEDIA_TYPE = "Unknown";
          var timeSeriesStreamStatsBuffer = [];
          var MAX_RTP_STREAM_STATS_BUFFER_SIZE = 10800;
          var inputRTPStreamStatsBuffer = [];
          var outputRTPStreamStatsBuffer = [];
          var aggregatedUserAudioStats = {};
          var aggregatedRemoteAudioStats = {};
          var LOW_AUDIO_LEVEL_THRESHOLD = 1;
          var consecutiveNoAudioInputPackets = 0;
          var consecutiveLowInputAudioLevel = 0;
          var consecutiveNoAudioOutputPackets = 0;
          var consecutiveLowOutputAudioLevel = 0;
          var audioInputConnectedDurationSeconds = 0;
          var rtpStatsJob = null;
          var reportStatsJob = null;
          var logger = null;
          var SoftphoneErrorTypes = connect2.SoftphoneErrorTypes;
          var HANG_UP_MULTIPLE_SESSIONS_EVENT = "MultiSessionHangUp";
          var MULTIPLE_SESSIONS_EVENT = "MultiSessions";
          var ECHO_CANCELLATION_CHECK = "echoCancellationCheck";
          var localMediaStream = {};
          var softphoneClientId = connect2.randomId();
          var requestIceAccess = function(transport) {
            return new Promise(function(resolve, reject) {
              connect2.core.getClient().call(connect2.ClientMethods.CREATE_TRANSPORT, transport, {
                success: function(data) {
                  resolve(data.softphoneTransport.softphoneMediaConnections);
                },
                failure: function(reason) {
                  if (reason.message && reason.message.includes("SoftphoneConnectionLimitBreachedException")) {
                    publishError("multiple_softphone_active_sessions", "Number of active sessions are more then allowed limit.", "");
                  }
                  reject(Error("requestIceAccess failed"));
                },
                authFailure: function() {
                  reject(Error("Authentication failed while requestIceAccess"));
                },
                accessDenied: function() {
                  reject(Error("Access Denied while requestIceAccess"));
                }
              });
            });
          };
          var SoftphoneManager = function(softphoneParams = {}) {
            var self2 = this;
            logger = new SoftphoneLogger(connect2.getLog());
            logger.info("[Softphone Manager] softphone manager initialization has begun").sendInternalLogToServer();
            logger.info(`[SoftphoneManager] Client Provided Strategy: ${softphoneParams.VDIPlatform}`).sendInternalLogToServer();
            let rtcJsStrategy;
            if (softphoneParams.VDIPlatform) {
              try {
                if (softphoneParams.VDIPlatform === VDIPlatformType.CITRIX) {
                  rtcJsStrategy = new connect2.CitrixVDIStrategy();
                  logger.info(`[SoftphoneManager] Strategy constructor retrieved: ${rtcJsStrategy}`).sendInternalLogToServer();
                } else {
                  throw new Error("VDI Strategy not supported");
                }
              } catch (error) {
                if (error.message === "VDI Strategy not supported") {
                  publishError(SoftphoneErrorTypes.VDI_STRATEGY_NOT_SUPPORTED, error.message, "");
                  throw error;
                } else if (error.message === "Citrix WebRTC redirection feature is NOT supported!") {
                  publishError(SoftphoneErrorTypes.VDI_REDIR_NOT_SUPPORTED, error.message, "");
                  throw error;
                } else {
                  publishError(SoftphoneErrorTypes.OTHER, error.message, "");
                  throw error;
                }
              }
            }
            var rtcPeerConnectionFactory;
            if (connect2.RtcPeerConnectionFactory) {
              if (rtcJsStrategy) {
                rtcPeerConnectionFactory = new connect2.RtcPeerConnectionFactory(
                  logger,
                  connect2.core.getWebSocketManager(),
                  softphoneClientId,
                  connect2.hitch(self2, requestIceAccess, {
                    transportType: "softphone",
                    softphoneClientId
                  }),
                  connect2.hitch(self2, publishError),
                  rtcJsStrategy
                );
              } else {
                rtcPeerConnectionFactory = new connect2.RtcPeerConnectionFactory(
                  logger,
                  connect2.core.getWebSocketManager(),
                  softphoneClientId,
                  connect2.hitch(self2, requestIceAccess, {
                    transportType: "softphone",
                    softphoneClientId
                  }),
                  connect2.hitch(self2, publishError)
                );
              }
            }
            if (!SoftphoneManager.isBrowserSoftPhoneSupported()) {
              publishError(
                SoftphoneErrorTypes.UNSUPPORTED_BROWSER,
                "Connect does not support this browser. Some functionality may not work. ",
                ""
              );
            }
            var gumPromise = fetchUserMedia({
              success: function(stream) {
                publishTelemetryEvent(
                  "ConnectivityCheckResult",
                  null,
                  {
                    connectivityCheckType: "MicrophonePermission",
                    status: "granted"
                  }
                );
              },
              failure: function(err) {
                publishError(err, "Your microphone is not enabled in your browser. ", "");
                publishTelemetryEvent(
                  "ConnectivityCheckResult",
                  null,
                  {
                    connectivityCheckType: "MicrophonePermission",
                    status: "denied"
                  }
                );
              }
            });
            const onMuteSub = handleSoftPhoneMuteToggle();
            const onSetSpeakerDeviceSub = handleSpeakerDeviceChange();
            const onSetMicrophoneDeviceSub = handleMicrophoneDeviceChange(!softphoneParams.disableEchoCancellation);
            monitorMicrophonePermission();
            this.ringtoneEngine = null;
            var rtcSessions = {};
            var callsDetected = {};
            var isSessionPending = false;
            var pendingContact = null;
            var pendingAgentConnectionId = null;
            var postponeStartingSession = function(contact, agentConnectionId) {
              isSessionPending = true;
              pendingContact = contact;
              pendingAgentConnectionId = agentConnectionId;
            };
            var cancelPendingSession = function() {
              isSessionPending = false;
              pendingContact = null;
              pendingAgentConnectionId = null;
            };
            this.getSession = function(connectionId) {
              return rtcSessions[connectionId];
            };
            this.replaceLocalMediaTrack = function(connectionId, track) {
              var stream = localMediaStream[connectionId].stream;
              if (stream) {
                var oldTrack = stream.getAudioTracks()[0];
                track.enabled = oldTrack.enabled;
                oldTrack.enabled = false;
                stream.removeTrack(oldTrack);
                stream.addTrack(track);
              }
            };
            var isContactTerminated = function(contact) {
              return contact.getStatus().type === connect2.ContactStatusType.ENDED || contact.getStatus().type === connect2.ContactStatusType.ERROR || contact.getStatus().type === connect2.ContactStatusType.MISSED;
            };
            var destroySession = function(agentConnectionId) {
              if (rtcSessions.hasOwnProperty(agentConnectionId)) {
                var session = rtcSessions[agentConnectionId];
                new Promise(function(resolve, reject) {
                  delete rtcSessions[agentConnectionId];
                  delete callsDetected[agentConnectionId];
                  session.hangup();
                }).catch(function(err) {
                  lily.getLog().warn("Clean up the session locally " + agentConnectionId, err.message).sendInternalLogToServer();
                });
              }
            };
            var sanityCheckActiveSessions = function(rtcSessions2) {
              if (Object.keys(rtcSessions2).length > 0) {
                for (var connectionId in rtcSessions2) {
                  if (rtcSessions2.hasOwnProperty(connectionId)) {
                    publishMultipleSessionsEvent(HANG_UP_MULTIPLE_SESSIONS_EVENT, rtcSessions2[connectionId].callId, connectionId);
                    destroySession(connectionId);
                  }
                }
                throw new Error("duplicate session detected, refusing to setup new connection");
              }
            };
            this.startSession = function(_contact, _agentConnectionId) {
              var contact = isSessionPending ? pendingContact : _contact;
              var agentConnectionId = isSessionPending ? pendingAgentConnectionId : _agentConnectionId;
              if (!contact || !agentConnectionId) {
                return;
              }
              cancelPendingSession();
              callsDetected[agentConnectionId] = true;
              logger.info("Softphone call detected:", "contactId " + contact.getContactId(), "agent connectionId " + agentConnectionId).sendInternalLogToServer();
              sanityCheckActiveSessions(rtcSessions);
              if (contact.getStatus().type === connect2.ContactStatusType.CONNECTING) {
                publishTelemetryEvent("Softphone Connecting", contact.getContactId());
              }
              initializeParams();
              var softphoneInfo = contact.getAgentConnection().getSoftphoneMediaInfo();
              var callConfig = parseCallConfig(softphoneInfo.callConfigJson);
              var webSocketProvider;
              if (callConfig.useWebSocketProvider) {
                webSocketProvider = connect2.core.getWebSocketManager();
              }
              var session;
              if (rtcJsStrategy) {
                session = new connect2.RTCSession(
                  callConfig.signalingEndpoint,
                  callConfig.iceServers,
                  softphoneInfo.callContextToken,
                  logger,
                  contact.getContactId(),
                  agentConnectionId,
                  webSocketProvider,
                  rtcJsStrategy
                );
              } else {
                session = new connect2.RTCSession(
                  callConfig.signalingEndpoint,
                  callConfig.iceServers,
                  softphoneInfo.callContextToken,
                  logger,
                  contact.getContactId(),
                  agentConnectionId,
                  webSocketProvider
                );
              }
              session.echoCancellation = !softphoneParams.disableEchoCancellation;
              rtcSessions[agentConnectionId] = session;
              connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
                event: connect2.ConnectionEvents.SESSION_INIT,
                data: {
                  connectionId: agentConnectionId
                }
              });
              session.onSessionFailed = function(rtcSession, reason) {
                delete rtcSessions[agentConnectionId];
                delete callsDetected[agentConnectionId];
                publishSoftphoneFailureLogs(rtcSession, reason);
                publishSessionFailureTelemetryEvent(contact.getContactId(), reason);
                stopJobsAndReport(contact, rtcSession.sessionReport);
              };
              session.onSessionConnected = function(rtcSession) {
                publishTelemetryEvent("Softphone Session Connected", contact.getContactId());
                connect2.becomeMaster(connect2.MasterTopics.SEND_LOGS);
                startStatsCollectionJob(rtcSession);
                startStatsReportingJob(contact);
                fireContactAcceptedEvent(contact);
              };
              session.onSessionCompleted = function(rtcSession) {
                publishTelemetryEvent("Softphone Session Completed", contact.getContactId());
                delete rtcSessions[agentConnectionId];
                delete callsDetected[agentConnectionId];
                stopJobsAndReport(contact, rtcSession.sessionReport);
                deleteLocalMediaStream(agentConnectionId);
              };
              session.onLocalStreamAdded = function(rtcSession, stream) {
                localMediaStream[agentConnectionId] = {
                  stream
                };
                connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
                  event: connect2.AgentEvents.LOCAL_MEDIA_STREAM_CREATED,
                  data: {
                    connectionId: agentConnectionId
                  }
                });
              };
              session.remoteAudioElement = document.getElementById("remote-audio") || window.parent.parent.document.getElementById("remote-audio");
              if (rtcPeerConnectionFactory) {
                session.connect(rtcPeerConnectionFactory.get(callConfig.iceServers));
              } else {
                session.connect();
              }
            };
            var onDestroyContact = function(agentConnectionId) {
              if (rtcSessions[agentConnectionId]) {
                destroySession(agentConnectionId);
              }
            };
            var onRefreshContact = function(contact, agentConnectionId) {
              if (rtcSessions[agentConnectionId] && isContactTerminated(contact)) {
                destroySession(agentConnectionId);
                cancelPendingSession();
              }
              if (contact.isSoftphoneCall() && !callsDetected[agentConnectionId] && (contact.getStatus().type === connect2.ContactStatusType.CONNECTING || contact.getStatus().type === connect2.ContactStatusType.INCOMING)) {
                if (connect2.isFirefoxBrowser() && connect2.hasOtherConnectedCCPs()) {
                  postponeStartingSession(contact, agentConnectionId);
                } else {
                  self2.startSession(contact, agentConnectionId);
                }
              }
            };
            var onInitContact = function(contact) {
              var agentConnectionId = contact.getAgentConnection().connectionId;
              logger.info("Contact detected:", "contactId " + contact.getContactId(), "agent connectionId " + agentConnectionId).sendInternalLogToServer();
              if (!callsDetected[agentConnectionId]) {
                contact.onRefresh(function() {
                  onRefreshContact(contact, agentConnectionId);
                });
                contact.onDestroy(function() {
                  onDestroyContact(agentConnectionId);
                });
              }
            };
            self2.onInitContactSub = connect2.contact(onInitContact);
            new connect2.Agent().getContacts().forEach(function(contact) {
              var agentConnectionId = contact.getAgentConnection().connectionId;
              logger.info("Contact exist in the snapshot. Reinitiate the Contact and RTC session creation for contactId" + contact.getContactId(), "agent connectionId " + agentConnectionId).sendInternalLogToServer();
              onInitContact(contact);
              onRefreshContact(contact, agentConnectionId);
            });
            this.terminate = () => {
              self2.onInitContactSub && self2.onInitContactSub.unsubscribe && self2.onInitContactSub.unsubscribe();
              onMuteSub && onMuteSub.unsubscribe && onMuteSub.unsubscribe();
              onSetSpeakerDeviceSub && onSetSpeakerDeviceSub.unsubscribe && onSetSpeakerDeviceSub.unsubscribe();
              onSetMicrophoneDeviceSub && onSetMicrophoneDeviceSub.unsubscribe && onSetMicrophoneDeviceSub.unsubscribe();
              if (rtcPeerConnectionFactory.clearIdleRtcPeerConnectionTimerId) {
                rtcPeerConnectionFactory.clearIdleRtcPeerConnectionTimerId();
              }
              rtcPeerConnectionFactory = null;
            };
          };
          var fireContactAcceptedEvent = function(contact) {
            var conduit = connect2.core.getUpstream();
            var agentConnection = contact.getAgentConnection();
            if (!agentConnection) {
              logger.info("Not able to retrieve the auto-accept setting from null AgentConnection, ignoring event publish..").sendInternalLogToServer();
              return;
            }
            var softphoneMediaInfo = agentConnection.getSoftphoneMediaInfo();
            if (!softphoneMediaInfo) {
              logger.info("Not able to retrieve the auto-accept setting from null SoftphoneMediaInfo, ignoring event publish..").sendInternalLogToServer();
              return;
            }
            if (softphoneMediaInfo.autoAccept === true) {
              logger.info("Auto-accept is enabled, sending out Accepted event to stop ringtone..").sendInternalLogToServer();
              conduit.sendUpstream(connect2.EventType.BROADCAST, {
                event: connect2.ContactEvents.ACCEPTED,
                data: new connect2.Contact(contact.contactId)
              });
              conduit.sendUpstream(connect2.EventType.BROADCAST, {
                event: connect2.core.getContactEventName(connect2.ContactEvents.ACCEPTED, contact.contactId),
                data: new connect2.Contact(contact.contactId)
              });
            } else {
              logger.info("Auto-accept is disabled, ringtone will be stopped by user action.").sendInternalLogToServer();
            }
          };
          var handleSoftPhoneMuteToggle = function() {
            var bus = connect2.core.getEventBus();
            return bus.subscribe(connect2.EventType.MUTE, muteToggle);
          };
          var handleSpeakerDeviceChange = function() {
            var bus = connect2.core.getEventBus();
            return bus.subscribe(connect2.ConfigurationEvents.SET_SPEAKER_DEVICE, setSpeakerDevice);
          };
          var handleMicrophoneDeviceChange = function(enableEchoCancellation) {
            var bus = connect2.core.getEventBus();
            return bus.subscribe(connect2.ConfigurationEvents.SET_MICROPHONE_DEVICE, (data) => setMicrophoneDevice({ ...data, enableEchoCancellation }));
          };
          var monitorMicrophonePermission = function() {
            try {
              if (connect2.isChromeBrowser() && connect2.getChromeBrowserVersion() > 43) {
                navigator.permissions.query({ name: "microphone" }).then(function(permissionStatus) {
                  permissionStatus.onchange = function() {
                    logger.info("Microphone Permission: " + permissionStatus.state);
                    publishTelemetryEvent(
                      "ConnectivityCheckResult",
                      null,
                      {
                        connectivityCheckType: "MicrophonePermission",
                        status: permissionStatus.state
                      }
                    );
                    if (permissionStatus.state === "denied") {
                      publishError(
                        SoftphoneErrorTypes.MICROPHONE_NOT_SHARED,
                        "Your microphone is not enabled in your browser. ",
                        ""
                      );
                    }
                  };
                });
              }
            } catch (e) {
              logger.error("Failed in detecting microphone permission status: " + e);
            }
          };
          var deleteLocalMediaStream = function(connectionId) {
            delete localMediaStream[connectionId];
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.AgentEvents.MUTE_TOGGLE,
              data: { muted: false }
            });
          };
          var muteToggle = function(data) {
            var status;
            if (connect2.keys(localMediaStream).length === 0) {
              return;
            }
            if (data && data.mute !== void 0) {
              status = data.mute;
            }
            for (var connectionId in localMediaStream) {
              if (localMediaStream.hasOwnProperty(connectionId)) {
                var localMedia = localMediaStream[connectionId].stream;
                if (localMedia) {
                  var audioTracks = localMedia.getAudioTracks()[0];
                  if (status !== void 0) {
                    audioTracks.enabled = !status;
                    localMediaStream[connectionId].muted = status;
                    if (status) {
                      logger.info("Agent has muted the contact, connectionId -  " + connectionId).sendInternalLogToServer();
                    } else {
                      logger.info("Agent has unmuted the contact, connectionId - " + connectionId).sendInternalLogToServer();
                    }
                  } else {
                    status = localMediaStream[connectionId].muted || false;
                  }
                }
              }
            }
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.AgentEvents.MUTE_TOGGLE,
              data: { muted: status }
            });
          };
          var setSpeakerDevice = function(data = {}) {
            const deviceId = data.deviceId || "";
            connect2.getLog().info(`[Audio Device Settings] Attempting to set speaker device ${deviceId}`).sendInternalLogToServer();
            if (!deviceId) {
              connect2.getLog().warn("[Audio Device Settings] Setting speaker device cancelled due to missing deviceId").sendInternalLogToServer();
              return;
            }
            var remoteAudioElement = document.getElementById("remote-audio") || window.parent.parent.document.getElementById("remote-audio");
            if (remoteAudioElement && typeof remoteAudioElement.setSinkId === "function") {
              remoteAudioElement.setSinkId(deviceId).then(() => {
                connect2.getLog().info(`[Audio Device Settings] Speaker device ${deviceId} successfully set to speaker audio element`).sendInternalLogToServer();
                connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
                  event: connect2.ConfigurationEvents.SPEAKER_DEVICE_CHANGED,
                  data: { deviceId }
                });
              }).catch((e) => {
                connect2.getLog().error("[Audio Device Settings] Failed to set speaker device " + deviceId).withException(e).sendInternalLogToServer();
              });
            } else {
              connect2.getLog().warn("[Audio Device Settings] Setting speaker device cancelled due to missing remoteAudioElement").sendInternalLogToServer();
            }
          };
          var setMicrophoneDevice = function(data = {}) {
            const deviceId = data.deviceId || "";
            connect2.getLog().info(`[Audio Device Settings] Attempting to set microphone device ${deviceId}`).sendInternalLogToServer();
            if (connect2.keys(localMediaStream).length === 0) {
              connect2.getLog().warn("[Audio Device Settings] Setting microphone device cancelled due to missing localMediaStream").sendInternalLogToServer();
              return;
            }
            if (!deviceId) {
              connect2.getLog().warn("[Audio Device Settings] Setting microphone device cancelled due to missing deviceId").sendInternalLogToServer();
              return;
            }
            var softphoneManager = connect2.core.getSoftphoneManager();
            var CONSTRAINT = { audio: { deviceId: { exact: deviceId } } };
            if (!data.enableEchoCancellation)
              CONSTRAINT.audio.echoCancellation = false;
            connect2.publishMetric({
              name: ECHO_CANCELLATION_CHECK,
              data: {
                count: 1,
                disableEchoCancellation: !data.enableEchoCancellation
              }
            });
            navigator.mediaDevices.getUserMedia(CONSTRAINT).then((newMicrophoneStream) => {
              try {
                var newMicrophoneTrack = newMicrophoneStream.getAudioTracks()[0];
                for (var connectionId in localMediaStream) {
                  if (localMediaStream.hasOwnProperty(connectionId)) {
                    var localMedia = localMediaStream[connectionId].stream;
                    var session = softphoneManager.getSession(connectionId);
                    session._pc.getSenders()[0].replaceTrack(newMicrophoneTrack).then(function() {
                      softphoneManager.replaceLocalMediaTrack(connectionId, newMicrophoneTrack);
                      connect2.getLog().info(`[Audio Device Settings] Microphone device ${deviceId} successfully set to local media stream in RTCRtpSender`).sendInternalLogToServer();
                    });
                  }
                }
              } catch (e) {
                connect2.getLog().error("[Audio Device Settings] Failed to set microphone device " + deviceId).withException(e).sendInternalLogToServer();
                return;
              }
              connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
                event: connect2.ConfigurationEvents.MICROPHONE_DEVICE_CHANGED,
                data: { deviceId }
              });
            }).catch((e) => {
              connect2.getLog().error("[Audio Device Settings] Failed to set microphone device " + deviceId).withException(e).sendInternalLogToServer();
            });
          };
          var publishSoftphoneFailureLogs = function(rtcSession, reason) {
            if (reason === connect2.RTCErrors.ICE_COLLECTION_TIMEOUT) {
              var endPointUrl = "\n";
              for (var i = 0; i < rtcSession._iceServers.length; i++) {
                for (var j = 0; j < rtcSession._iceServers[i].urls.length; j++) {
                  endPointUrl = endPointUrl + rtcSession._iceServers[i].urls[j] + "\n";
                }
              }
              publishError(SoftphoneErrorTypes.ICE_COLLECTION_TIMEOUT, "Ice collection timedout. ", endPointUrl);
            } else if (reason === connect2.RTCErrors.USER_BUSY) {
              publishError(
                SoftphoneErrorTypes.USER_BUSY_ERROR,
                "Softphone call UserBusy error. ",
                ""
              );
            } else if (reason === connect2.RTCErrors.SIGNALLING_HANDSHAKE_FAILURE) {
              publishError(
                SoftphoneErrorTypes.SIGNALLING_HANDSHAKE_FAILURE,
                "Handshaking with Signalling Server " + rtcSession._signalingUri + " failed. ",
                rtcSession._signalingUri
              );
            } else if (reason === connect2.RTCErrors.GUM_TIMEOUT_FAILURE || reason === connect2.RTCErrors.GUM_OTHER_FAILURE) {
              publishError(
                SoftphoneErrorTypes.MICROPHONE_NOT_SHARED,
                "Your microphone is not enabled in your browser. ",
                ""
              );
            } else if (reason === connect2.RTCErrors.SIGNALLING_CONNECTION_FAILURE) {
              publishError(
                SoftphoneErrorTypes.SIGNALLING_CONNECTION_FAILURE,
                "URL " + rtcSession._signalingUri + " cannot be reached. ",
                rtcSession._signalingUri
              );
            } else if (reason === connect2.RTCErrors.CALL_NOT_FOUND) {
              logger.error("Softphone call failed due to CallNotFoundException.").sendInternalLogToServer();
            } else {
              publishError(
                SoftphoneErrorTypes.WEBRTC_ERROR,
                "webrtc system error. ",
                ""
              );
            }
          };
          var parseCallConfig = function(serializedConfig) {
            var decodedJSON = serializedConfig.replace(/&quot;/g, '"');
            return JSON.parse(decodedJSON);
          };
          var fetchUserMedia = function(callbacksIn) {
            var callbacks = callbacksIn || {};
            callbacks.success = callbacks.success || function() {
            };
            callbacks.failure = callbacks.failure || function() {
            };
            var CONSTRAINT = {
              audio: true
            };
            var promise = null;
            if (typeof Promise !== "function") {
              callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);
              return;
            }
            if (typeof navigator.mediaDevices === "object" && typeof navigator.mediaDevices.getUserMedia === "function") {
              promise = navigator.mediaDevices.getUserMedia(CONSTRAINT);
            } else if (typeof navigator.webkitGetUserMedia === "function") {
              promise = new Promise(function(resolve, reject) {
                navigator.webkitGetUserMedia(CONSTRAINT, resolve, reject);
              });
            } else {
              callbacks.failure(SoftphoneErrorTypes.UNSUPPORTED_BROWSER);
              return;
            }
            promise.then(function(stream) {
              var audioTracks = stream.getAudioTracks();
              if (audioTracks && audioTracks.length > 0) {
                callbacks.success(stream);
              } else {
                callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);
              }
            }, function(err) {
              callbacks.failure(SoftphoneErrorTypes.MICROPHONE_NOT_SHARED);
            });
            return promise;
          };
          var publishError = function(errorType, message, endPointUrl) {
            logger.error(
              "Softphone error occurred : ",
              errorType,
              message || ""
            ).sendInternalLogToServer();
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.AgentEvents.SOFTPHONE_ERROR,
              data: new connect2.SoftphoneError(errorType, message, endPointUrl)
            });
          };
          var publishSessionFailureTelemetryEvent = function(contactId, reason) {
            publishTelemetryEvent("Softphone Session Failed", contactId, {
              failedReason: reason
            });
          };
          var publishTelemetryEvent = function(eventName, contactId, data) {
            connect2.publishMetric({
              name: eventName,
              contactId,
              data
            });
          };
          var publishMultipleSessionsEvent = function(eventName, contactId, agentConnectionId) {
            publishTelemetryEvent(eventName, contactId, [{
              name: "AgentConnectionId",
              value: agentConnectionId
            }]);
            logger.info("Publish multiple session error metrics", eventName, "contactId " + contactId, "agent connectionId " + agentConnectionId).sendInternalLogToServer();
          };
          SoftphoneManager.isBrowserSoftPhoneSupported = function() {
            if (connect2.isOperaBrowser() && connect2.getOperaBrowserVersion() > 17) {
              return true;
            } else if (connect2.isChromeBrowser() && connect2.getChromeBrowserVersion() > 22) {
              return true;
            } else if (connect2.isFirefoxBrowser() && connect2.getFirefoxBrowserVersion() > 21) {
              return true;
            } else {
              return false;
            }
          };
          var sendSoftphoneMetrics = function(contact) {
            var streamStats = timeSeriesStreamStatsBuffer.slice();
            timeSeriesStreamStatsBuffer = [];
            if (streamStats.length > 0) {
              contact.sendSoftphoneMetrics(streamStats, {
                success: function() {
                  logger.info("sendSoftphoneMetrics success" + JSON.stringify(streamStats)).sendInternalLogToServer();
                },
                failure: function(data) {
                  logger.error("sendSoftphoneMetrics failed.").withObject(data).sendInternalLogToServer();
                }
              });
            }
          };
          var sendSoftphoneReport = function(contact, report, userAudioStats, remoteAudioStats) {
            report.streamStats = [
              addStreamTypeToStats(userAudioStats, AUDIO_INPUT),
              addStreamTypeToStats(remoteAudioStats, AUDIO_OUTPUT)
            ];
            var callReport = {
              callStartTime: report.sessionStartTime,
              callEndTime: report.sessionEndTime,
              gumTimeMillis: report.gumTimeMillis,
              initializationTimeMillis: report.initializationTimeMillis,
              iceCollectionTimeMillis: report.iceCollectionTimeMillis,
              signallingConnectTimeMillis: report.signallingConnectTimeMillis,
              handshakingTimeMillis: report.handshakingTimeMillis,
              preTalkingTimeMillis: report.preTalkingTimeMillis,
              talkingTimeMillis: report.talkingTimeMillis,
              cleanupTimeMillis: report.cleanupTimeMillis,
              iceCollectionFailure: report.iceCollectionFailure,
              signallingConnectionFailure: report.signallingConnectionFailure,
              handshakingFailure: report.handshakingFailure,
              gumOtherFailure: report.gumOtherFailure,
              gumTimeoutFailure: report.gumTimeoutFailure,
              createOfferFailure: report.createOfferFailure,
              setLocalDescriptionFailure: report.setLocalDescriptionFailure,
              userBusyFailure: report.userBusyFailure,
              invalidRemoteSDPFailure: report.invalidRemoteSDPFailure,
              noRemoteIceCandidateFailure: report.noRemoteIceCandidateFailure,
              setRemoteDescriptionFailure: report.setRemoteDescriptionFailure,
              softphoneStreamStatistics: report.streamStats
            };
            contact.sendSoftphoneReport(callReport, {
              success: function() {
                logger.info("sendSoftphoneReport success" + JSON.stringify(callReport)).sendInternalLogToServer();
              },
              failure: function(data) {
                logger.error("sendSoftphoneReport failed.").withObject(data).sendInternalLogToServer();
              }
            });
            var streamPerSecondStats = {
              AUDIO_INPUT: {
                packetsCount: inputRTPStreamStatsBuffer.map((stats) => stats.packetsCount),
                packetsLost: inputRTPStreamStatsBuffer.map((stats) => stats.packetsLost),
                audioLevel: inputRTPStreamStatsBuffer.map((stats) => stats.audioLevel),
                jitterBufferMillis: inputRTPStreamStatsBuffer.map((stats) => stats.jitterBufferMillis)
              },
              AUDIO_OUTPUT: {
                packetsCount: outputRTPStreamStatsBuffer.map((stats) => stats.packetsCount),
                packetsLost: outputRTPStreamStatsBuffer.map((stats) => stats.packetsLost),
                audioLevel: outputRTPStreamStatsBuffer.map((stats) => stats.audioLevel),
                jitterBufferMillis: outputRTPStreamStatsBuffer.map((stats) => stats.jitterBufferMillis),
                roundTripTimeMillis: outputRTPStreamStatsBuffer.map((stats) => stats.roundTripTimeMillis)
              }
            };
            var telemetryCallReport = {
              ...callReport,
              softphoneStreamPerSecondStatistics: streamPerSecondStats,
              iceConnectionsLost: report.iceConnectionsLost,
              iceConnectionsFailed: report.iceConnectionsFailed || null,
              peerConnectionFailed: report.peerConnectionFailed || null,
              rtcJsVersion: report.rtcJsVersion || null,
              consecutiveNoAudioInputPackets,
              consecutiveLowInputAudioLevel,
              consecutiveNoAudioOutputPackets,
              consecutiveLowOutputAudioLevel,
              audioInputConnectedDurationSeconds
            };
            connect2.publishSoftphoneReport({
              contactId: contact.getContactId(),
              ccpVersion: global.ccpVersion,
              report: telemetryCallReport
            });
            logger.info("sent TelemetryCallReport " + JSON.stringify(telemetryCallReport)).sendInternalLogToServer();
          };
          var startStatsCollectionJob = function(rtcSession) {
            rtpStatsJob = window.setInterval(function() {
              rtcSession.getUserAudioStats().then(function(stats) {
                var previousUserStats = aggregatedUserAudioStats;
                aggregatedUserAudioStats = stats;
                var currRTPStreamStat = getTimeSeriesStats(aggregatedUserAudioStats, previousUserStats, AUDIO_INPUT);
                timeSeriesStreamStatsBuffer.push(currRTPStreamStat);
                telemetryCallReportRTPStreamStatsBuffer(currRTPStreamStat);
              }, function(error) {
                logger.debug("Failed to get user audio stats.", error).sendInternalLogToServer();
              });
              rtcSession.getRemoteAudioStats().then(function(stats) {
                var previousRemoteStats = aggregatedRemoteAudioStats;
                aggregatedRemoteAudioStats = stats;
                var currRTPStreamStat = getTimeSeriesStats(aggregatedRemoteAudioStats, previousRemoteStats, AUDIO_OUTPUT);
                timeSeriesStreamStatsBuffer.push(currRTPStreamStat);
                telemetryCallReportRTPStreamStatsBuffer(currRTPStreamStat);
              }, function(error) {
                logger.debug("Failed to get remote audio stats.", error).sendInternalLogToServer();
              });
            }, 1e3);
          };
          var startStatsReportingJob = function(contact) {
            reportStatsJob = window.setInterval(function() {
              sendSoftphoneMetrics(contact);
            }, statsReportingJobIntervalMs);
          };
          var initializeParams = function() {
            aggregatedUserAudioStats = null;
            aggregatedRemoteAudioStats = null;
            timeSeriesStreamStatsBuffer = [];
            inputRTPStreamStatsBuffer = [];
            outputRTPStreamStatsBuffer = [];
            rtpStatsJob = null;
            reportStatsJob = null;
            consecutiveNoAudioInputPackets = 0;
            consecutiveLowInputAudioLevel = 0;
            consecutiveNoAudioOutputPackets = 0;
            consecutiveLowOutputAudioLevel = 0;
            audioInputConnectedDurationSeconds = 0;
          };
          var getTimeSeriesStats = function(currentStats, previousStats, streamType) {
            if (previousStats && currentStats) {
              var packetsLost = currentStats.packetsLost > previousStats.packetsLost ? currentStats.packetsLost - previousStats.packetsLost : 0;
              var packetsCount = currentStats.packetsCount > previousStats.packetsCount ? currentStats.packetsCount - previousStats.packetsCount : 0;
              checkConsecutiveNoPackets(packetsCount, streamType);
              checkConsecutiveNoAudio(currentStats.audioLevel, streamType);
              return new RTPStreamStats(
                currentStats.timestamp,
                packetsLost,
                packetsCount,
                streamType,
                currentStats.audioLevel,
                currentStats.jbMilliseconds,
                currentStats.rttMilliseconds
              );
            } else {
              return new RTPStreamStats(
                currentStats.timestamp,
                currentStats.packetsLost,
                currentStats.packetsCount,
                streamType,
                currentStats.audioLevel,
                currentStats.jbMilliseconds,
                currentStats.rttMilliseconds
              );
            }
          };
          var telemetryCallReportRTPStreamStatsBuffer = function(rtpStreamStats) {
            if (rtpStreamStats.softphoneStreamType === AUDIO_INPUT) {
              while (inputRTPStreamStatsBuffer.length >= MAX_RTP_STREAM_STATS_BUFFER_SIZE) {
                inputRTPStreamStatsBuffer.shift();
              }
              inputRTPStreamStatsBuffer.push(rtpStreamStats);
            } else if (rtpStreamStats.softphoneStreamType === AUDIO_OUTPUT) {
              while (outputRTPStreamStatsBuffer.length >= MAX_RTP_STREAM_STATS_BUFFER_SIZE) {
                outputRTPStreamStatsBuffer.shift();
              }
              outputRTPStreamStatsBuffer.push(rtpStreamStats);
            }
          };
          var checkConsecutiveNoPackets = function(packetsCount, streamType) {
            if (streamType === AUDIO_INPUT) {
              audioInputConnectedDurationSeconds++;
              if (packetsCount <= 0) {
                consecutiveNoAudioInputPackets++;
              } else {
                consecutiveNoAudioInputPackets = 0;
              }
            } else if (streamType === AUDIO_OUTPUT) {
              if (packetsCount <= 0) {
                consecutiveNoAudioOutputPackets++;
              } else {
                consecutiveNoAudioOutputPackets = 0;
              }
            }
          };
          var checkConsecutiveNoAudio = function(audioLevel, streamType) {
            if (streamType === AUDIO_INPUT) {
              if (audioLevel !== null && audioLevel <= LOW_AUDIO_LEVEL_THRESHOLD) {
                consecutiveLowInputAudioLevel++;
              } else {
                consecutiveLowInputAudioLevel = 0;
              }
            } else if (streamType === AUDIO_OUTPUT) {
              if (audioLevel !== null && audioLevel <= LOW_AUDIO_LEVEL_THRESHOLD) {
                consecutiveLowOutputAudioLevel++;
              } else {
                consecutiveLowOutputAudioLevel = 0;
              }
            }
          };
          var stopJob = function(task) {
            if (task !== null) {
              window.clearInterval(task);
            }
            return null;
          };
          var stopJobsAndReport = function(contact, sessionReport) {
            rtpStatsJob = stopJob(rtpStatsJob);
            reportStatsJob = stopJob(reportStatsJob);
            sendSoftphoneReport(contact, sessionReport, addStreamTypeToStats(aggregatedUserAudioStats, AUDIO_INPUT), addStreamTypeToStats(aggregatedRemoteAudioStats, AUDIO_OUTPUT));
            sendSoftphoneMetrics(contact);
          };
          var RTPStreamStats = function(timestamp, packetsLost, packetsCount, streamType, audioLevel, jitterBufferMillis, roundTripTimeMillis) {
            this.softphoneStreamType = streamType;
            this.timestamp = timestamp;
            this.packetsLost = packetsLost;
            this.packetsCount = packetsCount;
            this.audioLevel = audioLevel;
            this.jitterBufferMillis = jitterBufferMillis;
            this.roundTripTimeMillis = roundTripTimeMillis;
          };
          var addStreamTypeToStats = function(stats, streamType) {
            stats = stats || {};
            return new RTPStreamStats(stats.timestamp, stats.packetsLost, stats.packetsCount, streamType, stats.audioLevel);
          };
          var SoftphoneLogger = function(logger2) {
            this._originalLogger = logger2;
            var self2 = this;
            this._tee = function(level, method) {
              return function() {
                var args = Array.prototype.slice.call(arguments[0]);
                var format = "";
                args.forEach(function() {
                  format = format + " %s";
                });
                return method.apply(self2._originalLogger, [connect2.LogComponent.SOFTPHONE, format].concat(args));
              };
            };
          };
          SoftphoneLogger.prototype.debug = function() {
            return this._tee(1, this._originalLogger.debug)(arguments);
          };
          SoftphoneLogger.prototype.info = function() {
            return this._tee(2, this._originalLogger.info)(arguments);
          };
          SoftphoneLogger.prototype.log = function() {
            return this._tee(3, this._originalLogger.log)(arguments);
          };
          SoftphoneLogger.prototype.warn = function() {
            return this._tee(4, this._originalLogger.warn)(arguments);
          };
          SoftphoneLogger.prototype.error = function() {
            return this._tee(5, this._originalLogger.error)(arguments);
          };
          connect2.SoftphoneManager = SoftphoneManager;
        })();
      }
    ),
    /***/
    944: (
      /***/
      () => {
        (function() {
          var ctx = this || globalThis;
          var sprintf = function() {
            if (!sprintf.cache.hasOwnProperty(arguments[0])) {
              sprintf.cache[arguments[0]] = sprintf.parse(arguments[0]);
            }
            return sprintf.format.call(null, sprintf.cache[arguments[0]], arguments);
          };
          sprintf.format = function(parse_tree, argv) {
            var cursor = 1, tree_length = parse_tree.length, node_type = "", arg, output = [], i, k, match, pad, pad_character, pad_length;
            for (i = 0; i < tree_length; i++) {
              node_type = get_type(parse_tree[i]);
              if (node_type === "string") {
                output.push(parse_tree[i]);
              } else if (node_type === "array") {
                match = parse_tree[i];
                if (match[2]) {
                  arg = argv[cursor];
                  for (k = 0; k < match[2].length; k++) {
                    if (!arg.hasOwnProperty(match[2][k])) {
                      throw sprintf('[sprintf] property "%s" does not exist', match[2][k]);
                    }
                    arg = arg[match[2][k]];
                  }
                } else if (match[1]) {
                  arg = argv[match[1]];
                } else {
                  arg = argv[cursor++];
                }
                if (/[^s]/.test(match[8]) && get_type(arg) != "number") {
                  throw sprintf("[sprintf] expecting number but found %s", get_type(arg));
                }
                switch (match[8]) {
                  case "b":
                    arg = arg.toString(2);
                    break;
                  case "c":
                    arg = String.fromCharCode(arg);
                    break;
                  case "d":
                    arg = parseInt(arg, 10);
                    break;
                  case "e":
                    arg = match[7] ? arg.toExponential(match[7]) : arg.toExponential();
                    break;
                  case "f":
                    arg = match[7] ? parseFloat(arg).toFixed(match[7]) : parseFloat(arg);
                    break;
                  case "o":
                    arg = arg.toString(8);
                    break;
                  case "s":
                    arg = (arg = String(arg)) && match[7] ? arg.substring(0, match[7]) : arg;
                    break;
                  case "u":
                    arg = arg >>> 0;
                    break;
                  case "x":
                    arg = arg.toString(16);
                    break;
                  case "X":
                    arg = arg.toString(16).toUpperCase();
                    break;
                }
                arg = /[def]/.test(match[8]) && match[3] && arg >= 0 ? "+" + arg : arg;
                pad_character = match[4] ? match[4] == "0" ? "0" : match[4].charAt(1) : " ";
                pad_length = match[6] - String(arg).length;
                pad = match[6] ? str_repeat(pad_character, pad_length) : "";
                output.push(match[5] ? arg + pad : pad + arg);
              }
            }
            return output.join("");
          };
          sprintf.cache = {};
          sprintf.parse = function(fmt) {
            var _fmt = fmt, match = [], parse_tree = [], arg_names = 0;
            while (_fmt) {
              if ((match = /^[^\x25]+/.exec(_fmt)) !== null) {
                parse_tree.push(match[0]);
              } else if ((match = /^\x25{2}/.exec(_fmt)) !== null) {
                parse_tree.push("%");
              } else if ((match = /^\x25(?:([1-9]\d*)\$|\(([^\)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-fosuxX])/.exec(_fmt)) !== null) {
                if (match[2]) {
                  arg_names |= 1;
                  var field_list = [], replacement_field = match[2], field_match = [];
                  if ((field_match = /^([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                    field_list.push(field_match[1]);
                    while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                      if ((field_match = /^\.([a-z_][a-z_\d]*)/i.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                      } else if ((field_match = /^\[(\d+)\]/.exec(replacement_field)) !== null) {
                        field_list.push(field_match[1]);
                      } else {
                        throw "[sprintf] huh?";
                      }
                    }
                  } else {
                    throw "[sprintf] huh?";
                  }
                  match[2] = field_list;
                } else {
                  arg_names |= 2;
                }
                if (arg_names === 3) {
                  throw "[sprintf] mixing positional and named placeholders is not (yet) supported";
                }
                parse_tree.push(match);
              } else {
                throw "[sprintf] huh?";
              }
              _fmt = _fmt.substring(match[0].length);
            }
            return parse_tree;
          };
          var vsprintf = function(fmt, argv, _argv) {
            _argv = argv.slice(0);
            _argv.splice(0, 0, fmt);
            return sprintf.apply(null, _argv);
          };
          function get_type(variable) {
            return Object.prototype.toString.call(variable).slice(8, -1).toLowerCase();
          }
          function str_repeat(input, multiplier) {
            for (var output = []; multiplier > 0; output[--multiplier] = input) {
            }
            return output.join("");
          }
          ctx.sprintf = sprintf;
          ctx.vsprintf = vsprintf;
        })();
      }
    ),
    /***/
    82: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          var Stream = function() {
          };
          Stream.prototype.send = function(message) {
            throw new connect2.NotImplementedError();
          };
          Stream.prototype.onMessage = function(f) {
            throw new connect2.NotImplementedError();
          };
          var NullStream = function() {
            Stream.call(this);
          };
          NullStream.prototype = Object.create(Stream.prototype);
          NullStream.prototype.constructor = NullStream;
          NullStream.prototype.onMessage = function(f) {
          };
          NullStream.prototype.send = function(message) {
          };
          var WindowStream = function(win, domain) {
            Stream.call(this);
            this.window = win;
            this.domain = domain || "*";
          };
          WindowStream.prototype = Object.create(Stream.prototype);
          WindowStream.prototype.constructor = WindowStream;
          WindowStream.prototype.send = function(message) {
            this.window.postMessage(message, this.domain);
          };
          WindowStream.prototype.onMessage = function(f) {
            this.window.addEventListener("message", f);
          };
          var WindowIOStream = function(inputwin, outputwin, domain) {
            Stream.call(this);
            this.input = inputwin;
            this.output = outputwin;
            this.domain = domain || "*";
          };
          WindowIOStream.prototype = Object.create(Stream.prototype);
          WindowIOStream.prototype.constructor = WindowIOStream;
          WindowIOStream.prototype.send = function(message) {
            this.output.postMessage(message, this.domain);
          };
          WindowIOStream.prototype.onMessage = function(f) {
            this.input.addEventListener("message", (message) => {
              if (message.source === this.output) {
                f(message);
              }
            });
          };
          var PortStream = function(port) {
            Stream.call(this);
            this.port = port;
            this.id = connect2.randomId();
          };
          PortStream.prototype = Object.create(Stream.prototype);
          PortStream.prototype.constructor = PortStream;
          PortStream.prototype.send = function(message) {
            this.port.postMessage(message);
          };
          PortStream.prototype.onMessage = function(f) {
            this.port.addEventListener("message", f);
          };
          PortStream.prototype.getId = function() {
            return this.id;
          };
          var StreamMultiplexer = function(streams) {
            Stream.call(this);
            this.streamMap = streams ? connect2.index(streams, function(s) {
              return s.getId();
            }) : {};
            this.messageListeners = [];
          };
          StreamMultiplexer.prototype = Object.create(Stream.prototype);
          StreamMultiplexer.prototype.constructor = StreamMultiplexer;
          StreamMultiplexer.prototype.send = function(message) {
            this.getStreams().forEach(function(stream) {
              try {
                stream.send(message);
              } catch (e) {
              }
            });
          };
          StreamMultiplexer.prototype.onMessage = function(f) {
            this.messageListeners.push(f);
            this.getStreams().forEach(function(stream) {
              stream.onMessage(f);
            });
          };
          StreamMultiplexer.prototype.addStream = function(stream) {
            var self2 = this;
            this.streamMap[stream.getId()] = stream;
            this.messageListeners.forEach(function(messageListener) {
              stream.onMessage(messageListener);
            });
          };
          StreamMultiplexer.prototype.removeStream = function(stream) {
            delete this.streamMap[stream.getId()];
          };
          StreamMultiplexer.prototype.getStreams = function(stream) {
            return connect2.values(this.streamMap);
          };
          StreamMultiplexer.prototype.getStreamForPort = function(port) {
            return connect2.find(this.getStreams(), function(s) {
              return s.port === port;
            });
          };
          var Conduit = function(name, upstream, downstream) {
            this.name = name;
            this.upstream = upstream || new NullStream();
            this.downstream = downstream || new NullStream();
            this.downstreamBus = new connect2.EventBus();
            this.upstreamBus = new connect2.EventBus();
            this.upstream.onMessage(connect2.hitch(this, this._dispatchEvent, this.upstreamBus));
            this.downstream.onMessage(connect2.hitch(this, this._dispatchEvent, this.downstreamBus));
          };
          Conduit.prototype.onUpstream = function(eventName, f) {
            connect2.assertNotNull(eventName, "eventName");
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.upstreamBus.subscribe(eventName, f);
          };
          Conduit.prototype.onAllUpstream = function(f) {
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.upstreamBus.subscribeAll(f);
          };
          Conduit.prototype.onDownstream = function(eventName, f) {
            connect2.assertNotNull(eventName, "eventName");
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.downstreamBus.subscribe(eventName, f);
          };
          Conduit.prototype.onAllDownstream = function(f) {
            connect2.assertNotNull(f, "f");
            connect2.assertTrue(connect2.isFunction(f), "f must be a function");
            return this.downstreamBus.subscribeAll(f);
          };
          Conduit.prototype.sendUpstream = function(eventName, data) {
            connect2.assertNotNull(eventName, "eventName");
            this.upstream.send({ event: eventName, data });
          };
          Conduit.prototype.sendDownstream = function(eventName, data) {
            connect2.assertNotNull(eventName, "eventName");
            this.downstream.send({ event: eventName, data });
          };
          Conduit.prototype._dispatchEvent = function(bus, messageEvent) {
            var message = messageEvent.data;
            if (message.event) {
              bus.trigger(message.event, message.data);
            }
          };
          Conduit.prototype.passUpstream = function() {
            var self2 = this;
            return function(data, eventName) {
              self2.upstream.send({ event: eventName, data });
            };
          };
          Conduit.prototype.passDownstream = function() {
            var self2 = this;
            return function(data, eventName) {
              self2.downstream.send({ event: eventName, data });
            };
          };
          Conduit.prototype.shutdown = function() {
            this.upstreamBus.unsubscribeAll();
            this.downstreamBus.unsubscribeAll();
          };
          var IFrameConduit = function(name, window2, iframe, domain) {
            Conduit.call(this, name, new WindowIOStream(window2, iframe.contentWindow, domain || "*"), null);
          };
          IFrameConduit.prototype = Object.create(Conduit.prototype);
          IFrameConduit.prototype.constructor = IFrameConduit;
          connect2.Stream = Stream;
          connect2.NullStream = NullStream;
          connect2.WindowStream = WindowStream;
          connect2.WindowIOStream = WindowIOStream;
          connect2.PortStream = PortStream;
          connect2.StreamMultiplexer = StreamMultiplexer;
          connect2.Conduit = Conduit;
          connect2.IFrameConduit = IFrameConduit;
        })();
      }
    ),
    /***/
    833: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          var GraphLink = function(fromState, toState) {
            connect2.assertNotNull(fromState, "fromState");
            connect2.assertNotNull(toState, "toState");
            this.fromState = fromState;
            this.toState = toState;
          };
          GraphLink.prototype.getAssociations = function(context) {
            throw connect2.NotImplementedError();
          };
          GraphLink.prototype.getFromState = function() {
            return this.fromState;
          };
          GraphLink.prototype.getToState = function() {
            return this.toState;
          };
          var DirectGraphLink = function(fromState, toState, associations) {
            connect2.assertNotNull(fromState, "fromState");
            connect2.assertNotNull(toState, "toState");
            connect2.assertNotNull(associations, "associations");
            GraphLink.call(this, fromState, toState);
            this.associations = associations;
          };
          DirectGraphLink.prototype = Object.create(GraphLink.prototype);
          DirectGraphLink.prototype.constructor = DirectGraphLink;
          DirectGraphLink.prototype.getAssociations = function(context) {
            return this.associations;
          };
          var FunctionalGraphLink = function(fromState, toState, closure) {
            connect2.assertNotNull(fromState, "fromState");
            connect2.assertNotNull(toState, "toState");
            connect2.assertNotNull(closure, "closure");
            connect2.assertTrue(connect2.isFunction(closure), "closure must be a function");
            GraphLink.call(this, fromState, toState);
            this.closure = closure;
          };
          FunctionalGraphLink.prototype = Object.create(GraphLink.prototype);
          FunctionalGraphLink.prototype.constructor = FunctionalGraphLink;
          FunctionalGraphLink.prototype.getAssociations = function(context) {
            return this.closure(context, this.getFromState(), this.getToState());
          };
          var EventGraph = function() {
            this.fromMap = {};
          };
          EventGraph.ANY = "<<any>>";
          EventGraph.prototype.assoc = function(fromStateObj, toStateObj, assocObj) {
            var self2 = this;
            if (!fromStateObj) {
              throw new Error("fromStateObj is not defined.");
            }
            if (!toStateObj) {
              throw new Error("toStateObj is not defined.");
            }
            if (!assocObj) {
              throw new Error("assocObj is not defined.");
            }
            if (fromStateObj instanceof Array) {
              fromStateObj.forEach(function(fromState) {
                self2.assoc(fromState, toStateObj, assocObj);
              });
            } else if (toStateObj instanceof Array) {
              toStateObj.forEach(function(toState) {
                self2.assoc(fromStateObj, toState, assocObj);
              });
            } else {
              if (typeof assocObj === "function") {
                this._addAssociation(new FunctionalGraphLink(fromStateObj, toStateObj, assocObj));
              } else if (assocObj instanceof Array) {
                this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, assocObj));
              } else {
                this._addAssociation(new DirectGraphLink(fromStateObj, toStateObj, [assocObj]));
              }
            }
            return this;
          };
          EventGraph.prototype.getAssociations = function(context, fromState, toState) {
            connect2.assertNotNull(fromState, "fromState");
            connect2.assertNotNull(toState, "toState");
            var associations = [];
            var toMapFromAny = this.fromMap[EventGraph.ANY] || {};
            var toMap = this.fromMap[fromState] || {};
            associations = associations.concat(this._getAssociationsFromMap(
              toMapFromAny,
              context,
              fromState,
              toState
            ));
            associations = associations.concat(this._getAssociationsFromMap(
              toMap,
              context,
              fromState,
              toState
            ));
            return associations;
          };
          EventGraph.prototype._addAssociation = function(assoc) {
            var toMap = this.fromMap[assoc.getFromState()];
            if (!toMap) {
              toMap = this.fromMap[assoc.getFromState()] = {};
            }
            var assocList = toMap[assoc.getToState()];
            if (!assocList) {
              assocList = toMap[assoc.getToState()] = [];
            }
            assocList.push(assoc);
          };
          EventGraph.prototype._getAssociationsFromMap = function(map, context, fromState, toState) {
            var assocList = (map[EventGraph.ANY] || []).concat(map[toState] || []);
            return assocList.reduce(function(prev, assoc) {
              return prev.concat(assoc.getAssociations(context));
            }, []);
          };
          connect2.EventGraph = EventGraph;
        })();
      }
    ),
    /***/
    891: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          var userAgent = navigator.userAgent;
          var ONE_DAY_MILLIS = 24 * 60 * 60 * 1e3;
          var DEFAULT_POPUP_HEIGHT = 578;
          var DEFAULT_POPUP_WIDTH = 433;
          var COPYABLE_EVENT_FIELDS = ["bubbles", "cancelBubble", "cancelable", "composed", "data", "defaultPrevented", "eventPhase", "isTrusted", "lastEventId", "origin", "returnValue", "timeStamp", "type"];
          connect2.sprintf = global.sprintf;
          connect2.vsprintf = global.vsprintf;
          delete global.sprintf;
          delete global.vsprintf;
          connect2.HTTP_STATUS_CODES = {
            SUCCESS: 200,
            UNAUTHORIZED: 401,
            ACCESS_DENIED: 403,
            TOO_MANY_REQUESTS: 429,
            INTERNAL_SERVER_ERROR: 500
          };
          connect2.TRANSPORT_TYPES = {
            CHAT_TOKEN: "chat_token",
            WEB_SOCKET: "web_socket",
            AGENT_DISCOVERY: "agent_discovery",
            WEB_RTC: "web_rtc"
          };
          connect2.hitch = function() {
            var args = Array.prototype.slice.call(arguments);
            var scope = args.shift();
            var method = args.shift();
            connect2.assertNotNull(scope, "scope");
            connect2.assertNotNull(method, "method");
            connect2.assertTrue(connect2.isFunction(method), "method must be a function");
            return function() {
              var closureArgs = Array.prototype.slice.call(arguments);
              return method.apply(scope, args.concat(closureArgs));
            };
          };
          connect2.isFunction = function(obj) {
            return !!(obj && obj.constructor && obj.call && obj.apply);
          };
          connect2.isArray = function(obj) {
            return Object.prototype.toString.call(obj) === "[object Array]";
          };
          connect2.keys = function(map) {
            var keys = [];
            connect2.assertNotNull(map, "map");
            for (var k in map) {
              keys.push(k);
            }
            return keys;
          };
          connect2.values = function(map) {
            var values = [];
            connect2.assertNotNull(map, "map");
            for (var k in map) {
              values.push(map[k]);
            }
            return values;
          };
          connect2.entries = function(map) {
            var entries = [];
            for (var k in map) {
              entries.push({ key: k, value: map[k] });
            }
            return entries;
          };
          connect2.merge = function() {
            var argMaps = Array.prototype.slice.call(arguments, 0);
            var resultMap = {};
            argMaps.forEach(function(map) {
              connect2.entries(map).forEach(function(kv) {
                resultMap[kv.key] = kv.value;
              });
            });
            return resultMap;
          };
          connect2.now = function() {
            return (/* @__PURE__ */ new Date()).getTime();
          };
          connect2.find = function(array, predicate) {
            for (var x = 0; x < array.length; x++) {
              if (predicate(array[x])) {
                return array[x];
              }
            }
            return null;
          };
          connect2.contains = function(obj, value) {
            if (obj instanceof Array) {
              return connect2.find(obj, function(v) {
                return v === value;
              }) != null;
            } else {
              return value in obj;
            }
          };
          connect2.containsValue = function(obj, value) {
            if (obj instanceof Array) {
              return connect2.find(obj, function(v) {
                return v === value;
              }) != null;
            } else {
              return connect2.find(connect2.values(obj), function(v) {
                return v === value;
              }) != null;
            }
          };
          connect2.randomId = function() {
            return connect2.sprintf("%s-%s", connect2.now(), Math.random().toString(36).slice(2));
          };
          connect2.makeEnum = function(values) {
            var enumObj = {};
            values.forEach(function(value) {
              var key = value.replace(/\.?([a-z]+)_?/g, function(x, y) {
                return y.toUpperCase() + "_";
              }).replace(/_$/, "");
              enumObj[key] = value;
            });
            return enumObj;
          };
          connect2.makeNamespacedEnum = function(prefix, values) {
            var enumObj = connect2.makeEnum(values);
            connect2.keys(enumObj).forEach(function(key) {
              enumObj[key] = connect2.sprintf("%s::%s", prefix, enumObj[key]);
            });
            return enumObj;
          };
          connect2.makeGenericNamespacedEnum = function(prefix, values, delimiter) {
            var enumObj = connect2.makeEnum(values);
            connect2.keys(enumObj).forEach(function(key) {
              enumObj[key] = connect2.sprintf("%s" + delimiter + "%s", prefix, enumObj[key]);
            });
            return enumObj;
          };
          connect2.isChromeBrowser = function() {
            return userAgent.indexOf("Chrome") !== -1;
          };
          connect2.isFirefoxBrowser = function() {
            return userAgent.indexOf("Firefox") !== -1;
          };
          connect2.isOperaBrowser = function() {
            return userAgent.indexOf("Opera") !== -1;
          };
          connect2.isEdgeBrowser = function() {
            return userAgent.indexOf("Edg") !== -1;
          };
          connect2.getChromeBrowserVersion = function() {
            var chromeVersion = userAgent.substring(userAgent.indexOf("Chrome") + 7);
            if (chromeVersion) {
              return parseFloat(chromeVersion);
            } else {
              return -1;
            }
          };
          connect2.getFirefoxBrowserVersion = function() {
            var firefoxVersion = userAgent.substring(userAgent.indexOf("Firefox") + 8);
            if (firefoxVersion) {
              return parseFloat(firefoxVersion);
            } else {
              return -1;
            }
          };
          connect2.isValidLocale = function(locale) {
            var languages = [
              {
                id: "en_US",
                label: "English"
              },
              {
                id: "de_DE",
                label: "Deutsch"
              },
              {
                id: "es_ES",
                label: "Espaol"
              },
              {
                id: "fr_FR",
                label: "Franais"
              },
              {
                id: "ja_JP",
                label: ""
              },
              {
                id: "it_IT",
                label: "Italiano"
              },
              {
                id: "ko_KR",
                label: ""
              },
              {
                id: "pt_BR",
                label: "Portugus"
              },
              {
                id: "zh_CN",
                label: "()"
              },
              {
                id: "zh_TW",
                label: "()"
              }
            ];
            return languages.map(function(language) {
              return language.id;
            }).includes(locale);
          };
          connect2.getOperaBrowserVersion = function() {
            var versionOffset = userAgent.indexOf("Opera");
            var operaVersion = userAgent.indexOf("Version") !== -1 ? userAgent.substring(versionOffset + 8) : userAgent.substring(versionOffset + 6);
            if (operaVersion) {
              return parseFloat(operaVersion);
            } else {
              return -1;
            }
          };
          connect2.index = function(iterable, closure) {
            var map = {};
            iterable.forEach(function(item) {
              map[closure(item)] = item;
            });
            return map;
          };
          connect2.set = function(arrayIn) {
            var setMap = {};
            arrayIn.forEach(function(key) {
              setMap[key] = 1;
            });
            return setMap;
          };
          connect2.relativeComplement = function(mapA, mapB) {
            var compMap = {};
            connect2.keys(mapB).forEach(function(key) {
              if (!(key in mapA)) {
                compMap[key] = mapB[key];
              }
            });
            return compMap;
          };
          connect2.assertTrue = function(premise, message) {
            if (!premise) {
              throw new connect2.ValueError(message);
            }
          };
          connect2.assertNotNull = function(value, name) {
            connect2.assertTrue(
              value != null && typeof value !== void 0,
              connect2.sprintf("%s must be provided", name || "A value")
            );
            return value;
          };
          connect2.deepcopy = function(src) {
            return JSON.parse(JSON.stringify(src));
          };
          connect2.deepcopyCrossOriginEvent = function(event) {
            const obj = {};
            const listOfAcceptableKeys = COPYABLE_EVENT_FIELDS;
            listOfAcceptableKeys.forEach((key) => {
              try {
                obj[key] = event[key];
              } catch (e) {
                connect2.getLog().info("deepcopyCrossOriginEvent failed on key: ", key).sendInternalLogToServer();
              }
            });
            return connect2.deepcopy(obj);
          };
          connect2.getBaseUrl = function() {
            var location2 = global.location;
            return connect2.sprintf("%s//%s:%s", location2.protocol, location2.hostname, location2.port);
          };
          connect2.getUrlWithProtocol = function(url) {
            var protocol = global.location.protocol;
            if (url.substr(0, protocol.length) !== protocol) {
              return connect2.sprintf("%s//%s", protocol, url);
            }
            return url;
          };
          connect2.isFramed = function() {
            try {
              return window.self !== window.top;
            } catch (e) {
              return true;
            }
          };
          connect2.hasOtherConnectedCCPs = function() {
            return connect2.numberOfConnectedCCPs > 1;
          };
          connect2.fetch = function(endpoint, options, milliInterval, maxRetry) {
            maxRetry = maxRetry || 5;
            milliInterval = milliInterval || 1e3;
            options = options || {};
            return new Promise(function(resolve, reject) {
              function fetchData(maxRetry2) {
                fetch(endpoint, options).then(function(res) {
                  if (res.status === connect2.HTTP_STATUS_CODES.SUCCESS) {
                    res.json().then((json) => resolve(json)).catch(() => resolve({}));
                  } else if (maxRetry2 !== 1 && (res.status >= connect2.HTTP_STATUS_CODES.INTERNAL_SERVER_ERROR || res.status === connect2.HTTP_STATUS_CODES.TOO_MANY_REQUESTS)) {
                    setTimeout(function() {
                      fetchData(--maxRetry2);
                    }, milliInterval);
                  } else {
                    reject(res);
                  }
                }).catch(function(e) {
                  reject(e);
                });
              }
              fetchData(maxRetry);
            });
          };
          connect2.fetchWithTimeout = async function(endpoint, timeoutMs, options, milliInterval, maxRetry) {
            options = options || {};
            if (!timeoutMs) {
              return connect2.fetch(endpoint, options, milliInterval, maxRetry);
            }
            const controller = new AbortController();
            const id = setTimeout(() => controller.abort(), timeoutMs);
            const response = await connect2.fetch(endpoint, {
              ...options,
              signal: controller.signal
            }, milliInterval, maxRetry);
            clearTimeout(id);
            return response;
          };
          connect2.backoff = function(func, milliInterval, maxRetry, callbacks) {
            connect2.assertTrue(connect2.isFunction(func), "func must be a Function");
            var self2 = this;
            var ratio = 2;
            func({
              success: function(data) {
                if (callbacks && callbacks.success) {
                  callbacks.success(data);
                }
              },
              failure: function(err, data) {
                if (maxRetry > 0) {
                  var interval = milliInterval * 2 * Math.random();
                  global.setTimeout(function() {
                    self2.backoff(func, interval * ratio, --maxRetry, callbacks);
                  }, interval);
                } else {
                  if (callbacks && callbacks.failure) {
                    callbacks.failure(err, data);
                  }
                }
              }
            });
          };
          connect2.publishMetric = function(metricData) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.EventType.CLIENT_METRIC,
              data: metricData
            });
          };
          connect2.publishSoftphoneStats = function(stats) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.EventType.SOFTPHONE_STATS,
              data: stats
            });
          };
          connect2.publishSoftphoneReport = function(report) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.EventType.SOFTPHONE_REPORT,
              data: report
            });
          };
          connect2.publishClickStreamData = function(report) {
            connect2.core.getUpstream().sendUpstream(connect2.EventType.BROADCAST, {
              event: connect2.EventType.CLICK_STREAM_DATA,
              data: report
            });
          };
          connect2.publishClientSideLogs = function(logs) {
            var bus = connect2.core.getEventBus();
            bus.trigger(connect2.EventType.CLIENT_SIDE_LOGS, logs);
          };
          connect2.addNamespaceToLogs = function(namespace) {
            const methods = ["log", "error", "warn", "info", "debug"];
            methods.forEach((method) => {
              const consoleMethod = window.console[method];
              window.console[method] = function() {
                const args = Array.from(arguments);
                args.unshift(`[${namespace}]`);
                consoleMethod.apply(window.console, args);
              };
            });
          };
          connect2.PopupManager = function() {
          };
          connect2.PopupManager.prototype.open = function(url, name, options) {
            var win = null;
            if (options) {
              var height = options.height || DEFAULT_POPUP_HEIGHT;
              var width = options.width || DEFAULT_POPUP_WIDTH;
              var top = options.top || 0;
              var left = options.left || 0;
              win = window.open("", name, "width=" + width + ", height=" + height + ", top=" + top + ", left=" + left);
              if (win.location !== url) {
                win = window.open(url, name, "width=" + width + ", height=" + height + ", top=" + top + ", left=" + left);
              }
            } else {
              win = window.open("", name);
              if (win.location !== url) {
                win = window.open(url, name);
              }
            }
            return win;
          };
          connect2.PopupManager.prototype.clear = function(name) {
            var key = this._getLocalStorageKey(name);
            global.localStorage.removeItem(key);
          };
          connect2.PopupManager.prototype._getLastOpenedTimestamp = function(name) {
            var key = this._getLocalStorageKey(name);
            var value = global.localStorage.getItem(key);
            if (value) {
              return parseInt(value, 10);
            } else {
              return 0;
            }
          };
          connect2.PopupManager.prototype._setLastOpenedTimestamp = function(name, ts) {
            var key = this._getLocalStorageKey(name);
            global.localStorage.setItem(key, "" + ts);
          };
          connect2.PopupManager.prototype._getLocalStorageKey = function(name) {
            return "connectPopupManager::" + name;
          };
          var NotificationPermission = connect2.makeEnum([
            "granted",
            "denied",
            "default"
          ]);
          connect2.NotificationManager = function() {
            this.queue = [];
            this.permission = NotificationPermission.DEFAULT;
          };
          connect2.NotificationManager.prototype.requestPermission = function() {
            var self2 = this;
            if (!("Notification" in global)) {
              connect2.getLog().warn("This browser doesn't support notifications.").sendInternalLogToServer();
              this.permission = NotificationPermission.DENIED;
            } else if (global.Notification.permission === NotificationPermission.DENIED) {
              connect2.getLog().warn("The user has requested to not receive notifications.").sendInternalLogToServer();
              this.permission = NotificationPermission.DENIED;
            } else if (this.permission !== NotificationPermission.GRANTED) {
              global.Notification.requestPermission().then(function(permission) {
                self2.permission = permission;
                if (permission === NotificationPermission.GRANTED) {
                  self2._showQueued();
                } else {
                  self2.queue = [];
                }
              });
            }
          };
          connect2.NotificationManager.prototype.show = function(title, options) {
            if (this.permission === NotificationPermission.GRANTED) {
              return this._showImpl({ title, options });
            } else if (this.permission === NotificationPermission.DENIED) {
              connect2.getLog().warn("Unable to show notification.").sendInternalLogToServer().withObject({
                title,
                options
              });
            } else {
              var params = { title, options };
              connect2.getLog().warn("Deferring notification until user decides to allow or deny.").withObject(params).sendInternalLogToServer();
              this.queue.push(params);
            }
          };
          connect2.NotificationManager.prototype._showQueued = function() {
            var self2 = this;
            var notifications = this.queue.map(function(params) {
              return self2._showImpl(params);
            });
            this.queue = [];
            return notifications;
          };
          connect2.NotificationManager.prototype._showImpl = function(params) {
            var notification = new global.Notification(params.title, params.options);
            if (params.options.clicked) {
              notification.onclick = function() {
                params.options.clicked.call(notification);
              };
            }
            return notification;
          };
          connect2.ValueError = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var format = args.shift();
            var instance = new Error(connect2.vsprintf(format, args));
            Object.setPrototypeOf(instance, connect2.ValueError.prototype);
            return instance;
          };
          Object.setPrototypeOf(connect2.ValueError.prototype, Error.prototype);
          Object.setPrototypeOf(connect2.ValueError, Error);
          connect2.ValueError.prototype.name = "ValueError";
          connect2.NotImplementedError = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var format = args.shift();
            var instance = new Error(connect2.vsprintf(format, args));
            Object.setPrototypeOf(instance, connect2.NotImplementedError.prototype);
            return instance;
          };
          Object.setPrototypeOf(connect2.NotImplementedError.prototype, Error.prototype);
          Object.setPrototypeOf(connect2.NotImplementedError, Error);
          connect2.NotImplementedError.prototype.name = "NotImplementedError";
          connect2.StateError = function() {
            var args = Array.prototype.slice.call(arguments, 0);
            var format = args.shift();
            var instance = new Error(connect2.vsprintf(format, args));
            Object.setPrototypeOf(instance, connect2.StateError.prototype);
            return instance;
          };
          Object.setPrototypeOf(connect2.StateError.prototype, Error.prototype);
          Object.setPrototypeOf(connect2.StateError, Error);
          connect2.StateError.prototype.name = "StateError";
          connect2.VoiceIdError = function(type, message, err) {
            var error = {};
            error.type = type;
            error.message = message;
            error.stack = Error(message).stack;
            error.err = err;
            return error;
          };
          connect2.isCCP = function() {
            if (!connect2.core.upstream) {
              return false;
            }
            var conduit = connect2.core.getUpstream();
            return conduit.name === "ConnectSharedWorkerConduit";
          };
          connect2.isSharedWorker = function() {
            return connect2.worker && !!connect2.worker.clientEngine;
          };
          connect2.isCRM = function() {
            if (!connect2.core.upstream) {
              return false;
            }
            return connect2.core.getUpstream() instanceof connect2.IFrameConduit;
          };
        })();
      }
    ),
    /***/
    736: (
      /***/
      () => {
        (function() {
          var global = this || globalThis;
          var connect2 = global.connect || {};
          global.connect = connect2;
          global.lily = connect2;
          connect2.worker = {};
          var GET_AGENT_TIMEOUT_MS = 3e4;
          var GET_AGENT_RECOVERY_TIMEOUT_MS = 5e3;
          var GET_AGENT_SUCCESS_TIMEOUT_MS = 100;
          var LOG_BUFFER_CAP_SIZE = 400;
          var CHECK_ACTIVE_REGION_INTERVAL_MS = 6e4;
          var CHECK_AUTH_TOKEN_INTERVAL_MS = 3e5;
          var REFRESH_AUTH_TOKEN_INTERVAL_MS = 1e4;
          var REFRESH_AUTH_TOKEN_MAX_TRY = 4;
          var GET_AGENT_CONFIGURATION_INTERVAL_MS = 3e4;
          var GET_AGENT_CONFIGURATION_TIMEOUT_MS = 1e4;
          var POLL_FOR_ACTIVE_REGION_METHOD = "LADS.GetAgentFailoverConfiguration";
          const relatedContactIdMethods = {
            createTaskContact: "createTaskContact",
            createOutboundContact: "createOutboundContact",
            createTemplatedTask: "createTemplatedTask"
          };
          var MasterTopicCoordinator = function() {
            this.topicMasterMap = {};
          };
          MasterTopicCoordinator.prototype.getMaster = function(topic) {
            connect2.assertNotNull(topic, "topic");
            return this.topicMasterMap[topic] || null;
          };
          MasterTopicCoordinator.prototype.setMaster = function(topic, id) {
            connect2.assertNotNull(topic, "topic");
            connect2.assertNotNull(id, "id");
            this.topicMasterMap[topic] = id;
          };
          MasterTopicCoordinator.prototype.removeMaster = function(id) {
            connect2.assertNotNull(id, "id");
            var self2 = this;
            connect2.entries(this.topicMasterMap).filter(function(entry) {
              return entry.value === id;
            }).forEach(function(entry) {
              delete self2.topicMasterMap[entry.key];
            });
          };
          var WorkerClient = function(conduit) {
            connect2.ClientBase.call(this);
            this.conduit = conduit;
          };
          WorkerClient.prototype = Object.create(connect2.ClientBase.prototype);
          WorkerClient.prototype.constructor = WorkerClient;
          WorkerClient.prototype._callImpl = function(method, params, callbacks) {
            var self2 = this;
            var request_start = (/* @__PURE__ */ new Date()).getTime();
            if (connect2.containsValue(connect2.AgentAppClientMethods, method)) {
              connect2.core.getAgentAppClient()._callImpl(method, params, {
                success: function(data) {
                  self2._recordAPILatency(method, request_start, params);
                  callbacks.success(data);
                },
                failure: function(error) {
                  self2._recordAPILatency(method, request_start, params, error);
                  callbacks.failure(error);
                }
              });
            } else if (connect2.containsValue(connect2.TaskTemplatesClientMethods, method)) {
              connect2.core.getTaskTemplatesClient()._callImpl(method, params, {
                success: function(data) {
                  self2._recordAPILatency(method, request_start, params);
                  callbacks.success(data);
                },
                failure: function(error) {
                  self2._recordAPILatency(method, request_start, params, error);
                  callbacks.failure(error);
                }
              });
            } else {
              connect2.core.getClient()._callImpl(method, params, {
                success: function(data, dataAttribute) {
                  self2._recordAPILatency(method, request_start, params);
                  callbacks.success(data, dataAttribute);
                },
                failure: function(error, data) {
                  self2._recordAPILatency(method, request_start, params, error);
                  callbacks.failure(error, data);
                },
                authFailure: function(error, data) {
                  self2._recordAPILatency(method, request_start, params, error);
                  callbacks.authFailure();
                },
                accessDenied: function(error, data) {
                  self2._recordAPILatency(method, request_start, params, error);
                  callbacks.accessDenied && callbacks.accessDenied();
                }
              });
            }
          };
          WorkerClient.prototype._recordAPILatency = function(method, request_start, params, err) {
            var request_end = (/* @__PURE__ */ new Date()).getTime();
            var request_time = request_end - request_start;
            this._sendAPIMetrics(method, request_time, params, err);
          };
          WorkerClient.prototype._sendAPIMetrics = function(method, time, params, err) {
            let eventData = {
              name: method,
              time,
              error: err,
              error5xx: 0
            };
            const dimensions = [
              { name: "Category", value: "API" }
            ];
            const statusCode = err && err.statusCode || 200;
            const retryStatus = err && err.retryStatus || connect2.RetryStatus.NONE;
            const optionalDimensions = [
              { name: "HttpStatusCode", value: statusCode },
              { name: "HttpGenericStatusCode", value: `${statusCode.toString().charAt(0)}XX` },
              { name: "RetryStatus", value: retryStatus }
            ];
            if (statusCode.toString().charAt(0) === "5") {
              eventData.error5xx = 1;
            }
            if (statusCode.toString().charAt(0) === "5") {
              eventData.fault = 1;
            } else if (statusCode.toString().charAt(0) === "2") {
              eventData.fault = 0;
            }
            if (relatedContactIdMethods[method] && params && params.relatedContactId) {
              let relatedEventData = {
                name: `${method}WithRelatedContactId`,
                time: eventData.time,
                error: eventData.error,
                error5xx: eventData.error5xx
              };
              this.conduit.sendDownstream(connect2.EventType.API_METRIC, {
                ...relatedEventData,
                dimensions,
                optionalDimensions
              });
            }
            this.conduit.sendDownstream(connect2.EventType.API_METRIC, {
              ...eventData,
              dimensions,
              optionalDimensions
            });
          };
          var ClientEngine = function() {
            var self2 = this;
            this.multiplexer = new connect2.StreamMultiplexer();
            this.conduit = new connect2.Conduit("AmazonConnectSharedWorker", null, this.multiplexer);
            this.client = new WorkerClient(this.conduit);
            this.timeout = null;
            this.agent = null;
            this.nextToken = null;
            this.initData = {};
            this.portConduitMap = {};
            this.streamMapByTabId = {};
            this.masterCoord = new MasterTopicCoordinator();
            this.logsBuffer = [];
            this.suppress = false;
            this.forceOffline = false;
            this.longPollingOptions = {
              allowLongPollingShadowMode: false,
              allowLongPollingWebsocketOnlyMode: false
            };
            this.drPollingUrl = null;
            this.thisArn = null;
            this.otherArn = null;
            this.pendingFailover = null;
            var webSocketManager = null;
            connect2.rootLogger = new connect2.DownstreamConduitLogger(this.conduit);
            this.conduit.onDownstream(connect2.EventType.SEND_LOGS, function(logsToUpload) {
              connect2.getLog().pushLogsDownstream(logsToUpload);
              self2.logsBuffer = self2.logsBuffer.concat(logsToUpload);
              if (self2.logsBuffer.length > LOG_BUFFER_CAP_SIZE) {
                self2.handleSendLogsRequest(self2.logsBuffer);
              }
            });
            this.conduit.onDownstream(connect2.DisasterRecoveryEvents.SUPPRESS, function(data) {
              connect2.getLog().debug("[Disaster Recovery] Setting Suppress to %s", data.suppress).sendInternalLogToServer();
              self2.suppress = data.suppress || false;
              if (!self2.suppress) {
                self2.forceOffline = false;
              }
              const shouldSendFailoverDownstream = typeof data.shouldSendFailoverDownstream === "undefined" || data.shouldSendFailoverDownstream;
              if (shouldSendFailoverDownstream) {
                self2.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FAILOVER, {
                  isPrimary: !self2.suppress
                });
              }
            });
            this.conduit.onDownstream(connect2.DisasterRecoveryEvents.FORCE_OFFLINE, function(data) {
              connect2.getLog().debug("[Disaster Recovery] Setting FORCE_OFFLINE to %s", data.offline).sendInternalLogToServer();
              if (!self2.forceOffline) {
                self2.pendingFailover = false;
                self2.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FAILOVER, {
                  isPrimary: false,
                  nextActiveArn: data.nextActiveArn
                });
              }
              self2.forceOffline = data.offline || false;
            });
            connect2.DisasterRecoveryEvents.INIT_DR_POLLING && this.conduit.onDownstream(connect2.DisasterRecoveryEvents.INIT_DR_POLLING, function(data) {
              var log2 = connect2.getLog();
              if (self2.drPollingUrl) {
                log2.debug(`[Disaster Recovery] Adding new CCP to active region polling for instance ${data.instanceArn}`).sendInternalLogToServer();
                self2.pollForActiveRegion(true, false);
              } else {
                log2.info(`[Disaster Recovery] Initializing active region polling for instance ${data.instanceArn}`).sendInternalLogToServer();
                self2.thisArn = data.instanceArn;
                self2.otherArn = data.otherArn;
                self2.getPresignedDiscoveryUrl().then(
                  (presignedUrl) => {
                    self2.drPollingUrl = presignedUrl;
                    self2.pollForActiveRegion(true, true);
                  },
                  (err) => {
                    log2.error(`[Disaster Recovery] Failed to get presigned URL for instance ${data.instanceArn}; suppressing contacts`).withException(err).sendInternalLogToServer();
                    self2.suppress = true;
                  }
                );
              }
            });
            this.conduit.onDownstream(connect2.EventType.CONFIGURE, function(data) {
              console.log("@@@ configure event handler", data);
              try {
                if (data.authToken && data.authToken !== self2.initData.authToken) {
                  self2.initData = data;
                  connect2.core.init(data);
                  if (data.longPollingOptions) {
                    if (typeof data.longPollingOptions.allowLongPollingShadowMode == "boolean") {
                      self2.longPollingOptions.allowLongPollingShadowMode = data.longPollingOptions.allowLongPollingShadowMode;
                    }
                    if (typeof data.longPollingOptions.allowLongPollingWebsocketOnlyMode == "boolean") {
                      self2.longPollingOptions.allowLongPollingWebsocketOnlyMode = data.longPollingOptions.allowLongPollingWebsocketOnlyMode;
                    }
                  }
                  if (!webSocketManager) {
                    connect2.getLog().info("Creating a new Websocket connection for CCP").sendInternalLogToServer();
                    connect2.WebSocketManager.setGlobalConfig({
                      loggerConfig: {
                        logger: connect2.getLog(),
                        advancedLogWriter: "info",
                        level: 10
                      }
                    });
                    webSocketManager = connect2.WebSocketManager.create();
                    webSocketManager.onInitFailure(function() {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.INIT_FAILURE);
                    });
                    webSocketManager.onConnectionOpen(function(response) {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.CONNECTION_OPEN, response);
                    });
                    webSocketManager.onConnectionClose(function(response) {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.CONNECTION_CLOSE, response);
                    });
                    webSocketManager.onConnectionGain(function() {
                      self2.conduit.sendDownstream(connect2.AgentEvents.WEBSOCKET_CONNECTION_GAINED);
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.CONNECTION_GAIN);
                    });
                    webSocketManager.onConnectionLost(function(response) {
                      self2.conduit.sendDownstream(connect2.AgentEvents.WEBSOCKET_CONNECTION_LOST, response);
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.CONNECTION_LOST, response);
                    });
                    webSocketManager.onSubscriptionUpdate(function(response) {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.SUBSCRIPTION_UPDATE, response);
                    });
                    webSocketManager.onSubscriptionFailure(function(response) {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.SUBSCRIPTION_FAILURE, response);
                    });
                    webSocketManager.onAllMessage(function(response) {
                      self2.conduit.sendDownstream(connect2.WebSocketEvents.ALL_MESSAGE, response);
                    });
                    self2.conduit.onDownstream(connect2.WebSocketEvents.SEND, function(message) {
                      webSocketManager.sendMessage(message);
                    });
                    self2.conduit.onDownstream(connect2.WebSocketEvents.SUBSCRIBE, function(topics) {
                      webSocketManager.subscribeTopics(topics);
                    });
                    webSocketManager.init(connect2.hitch(self2, self2.getWebSocketUrl)).then(function(response) {
                      try {
                        if (response && !response.webSocketConnectionFailed) {
                          connect2.getLog().info("Kicking off agent polling").sendInternalLogToServer();
                          self2.pollForAgent();
                          connect2.getLog().info("Kicking off config polling").sendInternalLogToServer();
                          self2.pollForAgentConfiguration({ repeatForever: true });
                          connect2.getLog().info("Kicking off auth token polling").sendInternalLogToServer();
                          global.setInterval(connect2.hitch(self2, self2.checkAuthToken), CHECK_AUTH_TOKEN_INTERVAL_MS);
                        } else {
                          if (!connect2.webSocketInitFailed) {
                            const event = connect2.WebSocketEvents.INIT_FAILURE;
                            self2.conduit.sendDownstream(event);
                            connect2.webSocketInitFailed = true;
                            throw new Error(event);
                          }
                        }
                      } catch (e) {
                        connect2.getLog().error("WebSocket failed to initialize").withException(e).sendInternalLogToServer();
                      }
                    });
                  } else {
                    connect2.getLog().info("Not Initializing a new WebsocketManager instance, since one already exists").sendInternalLogToServer();
                  }
                }
              } catch (e) {
                console.error("@@@ error", e);
              }
            });
            this.conduit.onDownstream(connect2.EventType.TERMINATE, function() {
              self2.handleSendLogsRequest(self2.logsBuffer);
              connect2.core.terminate();
              self2.conduit.sendDownstream(connect2.EventType.TERMINATED);
            });
            this.conduit.onDownstream(connect2.EventType.SYNCHRONIZE, function() {
              self2.conduit.sendDownstream(connect2.EventType.ACKNOWLEDGE);
            });
            this.conduit.onDownstream(connect2.EventType.BROADCAST, function(data) {
              self2.conduit.sendDownstream(data.event, data.data);
            });
            global.onconnect = function(event) {
              var port = event.ports[0];
              var stream = new connect2.PortStream(port);
              self2.multiplexer.addStream(stream);
              port.start();
              var portConduit = new connect2.Conduit(stream.getId(), null, stream);
              portConduit.sendDownstream(connect2.EventType.ACKNOWLEDGE, { id: stream.getId() });
              self2.portConduitMap[stream.getId()] = portConduit;
              self2.conduit.sendDownstream(connect2.EventType.UPDATE_CONNECTED_CCPS, { length: Object.keys(self2.portConduitMap).length });
              if (self2.agent !== null) {
                self2.updateAgent();
              }
              portConduit.onDownstream(
                connect2.EventType.API_REQUEST,
                connect2.hitch(self2, self2.handleAPIRequest, portConduit)
              );
              portConduit.onDownstream(
                connect2.EventType.MASTER_REQUEST,
                connect2.hitch(self2, self2.handleMasterRequest, portConduit, stream.getId())
              );
              portConduit.onDownstream(
                connect2.EventType.RELOAD_AGENT_CONFIGURATION,
                connect2.hitch(self2, self2.pollForAgentConfiguration)
              );
              portConduit.onDownstream(
                connect2.EventType.TAB_ID,
                connect2.hitch(self2, self2.handleTabIdEvent, stream)
              );
              portConduit.onDownstream(
                connect2.EventType.CLOSE,
                connect2.hitch(self2, self2.handleCloseEvent, stream)
              );
            };
          };
          ClientEngine.prototype.pollForActiveRegion = function(isFirstPollForCCP, isFirstPollForWorker) {
            var self2 = this;
            var log2 = connect2.getLog();
            if (!self2.drPollingUrl) {
              throw new connect2.StateError("[Disaster Recovery] Tried to poll for active region without first initializing DR polling in the worker.");
            }
            log2.debug(`[Disaster Recovery] Polling for failover with presigned URL for instance ${self2.thisArn}`).sendInternalLogToServer();
            var request_start = (/* @__PURE__ */ new Date()).getTime();
            return connect2.fetchWithTimeout(self2.drPollingUrl, GET_AGENT_CONFIGURATION_TIMEOUT_MS).catch((response) => {
              if (response.status) {
                self2.client._recordAPILatency(POLL_FOR_ACTIVE_REGION_METHOD, request_start, { statusCode: response.status });
                if ([connect2.HTTP_STATUS_CODES.ACCESS_DENIED, connect2.HTTP_STATUS_CODES.UNAUTHORIZED].includes(response.status)) {
                  log2.info("[Disaster Recovery] Active region polling failed; trying to get a new URL for polling.").withObject(response).sendInternalLogToServer();
                  return self2.getPresignedDiscoveryUrl().then((presignedUrl) => {
                    self2.drPollingUrl = presignedUrl;
                  }).then(() => {
                    request_start = (/* @__PURE__ */ new Date()).getTime();
                    return connect2.fetchWithTimeout(self2.drPollingUrl, GET_AGENT_CONFIGURATION_TIMEOUT_MS);
                  });
                } else {
                  var errMsg = `[Disaster Recovery] Failed to poll for failover for instance ${self2.thisArn}, received unexpected response code ${response.status}`;
                  log2.error(errMsg).withObject(response).sendInternalLogToServer();
                  throw new Error(errMsg);
                }
              } else {
                var errMsg = `[Disaster Recovery] Failed to poll for failover for instance ${self2.thisArn}, request timed out or aborted`;
                self2.client._recordAPILatency(POLL_FOR_ACTIVE_REGION_METHOD, request_start, { statusCode: -1 });
                log2.error(errMsg).withObject(response).sendInternalLogToServer();
                throw new Error(errMsg);
              }
            }).then((response) => {
              self2.client._recordAPILatency(POLL_FOR_ACTIVE_REGION_METHOD, request_start);
              if (typeof response.TerminateActiveContacts !== "boolean") {
                log2.error("[Disaster Recovery] DR polling response did not contain a valid value for TerminateActiveContacts.").withObject(response).sendInternalLogToServer();
                return;
              }
              var softFailover = !response.TerminateActiveContacts;
              if (!response.InstanceArn) {
                log2.error("[Disaster Recovery] DR polling response did not contain a truthy active instance ARN.").withObject(response).sendInternalLogToServer();
                return;
              } else {
                log2.debug(`[Disaster Recovery] Successfully polled for active region. Primary instance ARN is ${response.InstanceArn} and soft failover is ${softFailover ? "enabled" : "disabled"}`).sendInternalLogToServer();
              }
              if (self2.thisArn === response.InstanceArn && !self2.suppress && isFirstPollForCCP) {
                log2.debug(`[Disaster Recovery] Instance ${self2.thisArn} is being set to primary`).sendInternalLogToServer();
                self2.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FAILOVER, {
                  nextActiveArn: response.InstanceArn
                });
              } else if (self2.otherArn === response.InstanceArn) {
                if (softFailover && !isFirstPollForWorker && isFirstPollForCCP && (!self2.suppress || self2.pendingFailover)) {
                  self2.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FAILOVER, {
                    nextActiveArn: self2.thisArn
                  });
                }
                if (!self2.suppress) {
                  self2.suppress = true;
                  const willSoftFailover = softFailover && !isFirstPollForWorker;
                  if (willSoftFailover) {
                    self2.pendingFailover = true;
                    log2.debug(`[Disaster Recovery] Instance ${self2.thisArn} will be set to stand-by using soft failover`).sendInternalLogToServer();
                  } else {
                    log2.debug(`[Disaster Recovery] Instance ${self2.thisArn} is being set to stand-by immediately`).sendInternalLogToServer();
                  }
                  self2.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FORCE_OFFLINE, { softFailover: willSoftFailover, nextActiveArn: response.InstanceArn });
                }
              } else if (![self2.thisArn, self2.otherArn].includes(response.InstanceArn)) {
                log2.error(`[Disaster Recovery] The current primary instance in this agent's failover group ${response.InstanceArn} doesn't match this instance ${self2.thisArn} or the other instance ${self2.otherArn}`).sendInternalLogToServer();
              }
            }).catch((response) => {
              if (response.status) {
                self2.client._recordAPILatency(POLL_FOR_ACTIVE_REGION_METHOD, request_start, { ...response, statusCode: response.status });
              }
              log2.error(`[Disaster Recovery] Active region polling failed for instance ${self2.thisArn}.`).withObject(response).sendInternalLogToServer();
            }).finally(() => {
              if (isFirstPollForWorker || !isFirstPollForCCP) {
                global.setTimeout(connect2.hitch(self2, self2.pollForActiveRegion), CHECK_ACTIVE_REGION_INTERVAL_MS);
              }
            });
          };
          ClientEngine.prototype.getPresignedDiscoveryUrl = function() {
            var self2 = this;
            return new Promise((resolve, reject) => {
              connect2.getLog().info(`[Disaster Recovery] Getting presigned URL for instance ${self2.thisArn}`).sendInternalLogToServer();
              this.client.call(connect2.ClientMethods.CREATE_TRANSPORT, { transportType: connect2.TRANSPORT_TYPES.AGENT_DISCOVERY }, {
                success: function(data) {
                  if (data && data.agentDiscoveryTransport && data.agentDiscoveryTransport.presignedUrl) {
                    connect2.getLog().info("getPresignedDiscoveryUrl succeeded").sendInternalLogToServer();
                    resolve(data.agentDiscoveryTransport.presignedUrl);
                  } else {
                    connect2.getLog().info("getPresignedDiscoveryUrl received empty/invalid data").withObject(data).sendInternalLogToServer();
                    reject(Error("getPresignedDiscoveryUrl received empty/invalid data"));
                  }
                },
                failure: function(err, data) {
                  connect2.getLog().error(`[Disaster Recovery] Failed to get presigned URL for instance ${self2.thisArn}`).withException(err).withObject(data).sendInternalLogToServer();
                  reject(new Error("Failed to get presigned URL"));
                },
                authFailure: function() {
                  connect2.hitch(self2, self2.handleAuthFail)();
                  reject(new Error("Encountered auth failure when getting presigned URL"));
                },
                accessDenied: function() {
                  connect2.hitch(self2, self2.handleAccessDenied)();
                  reject(new Error("Encountered access denied when getting presigned URL"));
                }
              });
            });
          };
          ClientEngine.prototype.pollForAgent = function() {
            var self2 = this;
            var onAuthFail = connect2.hitch(self2, self2.handlePollingAuthFail);
            this.client.call(connect2.ClientMethods.GET_AGENT_SNAPSHOT, {
              nextToken: self2.nextToken,
              timeout: GET_AGENT_TIMEOUT_MS
            }, {
              success: function(data, dataAttribute) {
                try {
                  self2.agent = self2.agent || {};
                  self2.agent.snapshot = data.snapshot;
                  self2.agent.snapshot.localTimestamp = connect2.now();
                  self2.agent.snapshot.skew = self2.agent.snapshot.snapshotTimestamp - self2.agent.snapshot.localTimestamp;
                  self2.nextToken = data.nextToken;
                  if (dataAttribute && dataAttribute.hasOwnProperty("contentLength")) {
                    self2.agent.snapshot.contentLength = dataAttribute.contentLength;
                  }
                  connect2.getLog().trace("GET_AGENT_SNAPSHOT succeeded.").withObject(data).sendInternalLogToServer();
                  self2.updateAgent();
                } catch (e) {
                  connect2.getLog().error("Long poll failed to update agent.").withObject(data).withException(e).sendInternalLogToServer();
                } finally {
                  global.setTimeout(connect2.hitch(self2, self2.pollForAgent), GET_AGENT_SUCCESS_TIMEOUT_MS);
                }
              },
              failure: function(err, data) {
                try {
                  connect2.getLog().error("Failed to get agent data.").sendInternalLogToServer().withObject({
                    err,
                    data
                  });
                } finally {
                  global.setTimeout(connect2.hitch(self2, self2.pollForAgent), GET_AGENT_RECOVERY_TIMEOUT_MS);
                }
              },
              authFailure: function() {
                onAuthFail();
              },
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.pollForAgentConfiguration = function(paramsIn) {
            var self2 = this;
            var params = paramsIn || {};
            var onAuthFail = connect2.hitch(self2, self2.handlePollingAuthFail);
            this.client.call(connect2.ClientMethods.GET_AGENT_CONFIGURATION, {}, {
              success: function(data) {
                var configuration = data.configuration;
                self2.pollForAgentPermissions(configuration);
                self2.pollForAgentStates(configuration);
                self2.pollForDialableCountryCodes(configuration);
                self2.pollForRoutingProfileQueues(configuration);
                if (params.repeatForever) {
                  global.setTimeout(
                    connect2.hitch(self2, self2.pollForAgentConfiguration, params),
                    GET_AGENT_CONFIGURATION_INTERVAL_MS
                  );
                }
              },
              failure: function(err, data) {
                try {
                  connect2.getLog().error("Failed to fetch agent configuration data.").sendInternalLogToServer().withObject({
                    err,
                    data
                  });
                } finally {
                  if (params.repeatForever) {
                    global.setTimeout(
                      connect2.hitch(self2, self2.pollForAgentConfiguration),
                      GET_AGENT_CONFIGURATION_INTERVAL_MS,
                      params
                    );
                  }
                }
              },
              authFailure: function() {
                onAuthFail();
              },
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.pollForAgentStates = function(configuration, paramsIn) {
            var self2 = this;
            var params = paramsIn || {};
            params.maxResults = params.maxResults || connect2.DEFAULT_BATCH_SIZE;
            this.client.call(connect2.ClientMethods.GET_AGENT_STATES, {
              nextToken: params.nextToken || null,
              maxResults: params.maxResults
            }, {
              success: function(data) {
                if (data.nextToken) {
                  self2.pollForAgentStates(configuration, {
                    states: (params.states || []).concat(data.states),
                    nextToken: data.nextToken,
                    maxResults: params.maxResults
                  });
                } else {
                  configuration.agentStates = (params.states || []).concat(data.states);
                  self2.updateAgentConfiguration(configuration);
                }
              },
              failure: function(err, data) {
                connect2.getLog().error("Failed to fetch agent states list.").sendInternalLogToServer().withObject({
                  err,
                  data
                });
              },
              authFailure: connect2.hitch(self2, self2.handlePollingAuthFail),
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.pollForAgentPermissions = function(configuration, paramsIn) {
            var self2 = this;
            var params = paramsIn || {};
            params.maxResults = params.maxResults || connect2.DEFAULT_BATCH_SIZE;
            this.client.call(connect2.ClientMethods.GET_AGENT_PERMISSIONS, {
              nextToken: params.nextToken || null,
              maxResults: params.maxResults
            }, {
              success: function(data) {
                if (data.nextToken) {
                  self2.pollForAgentPermissions(configuration, {
                    permissions: (params.permissions || []).concat(data.permissions),
                    nextToken: data.nextToken,
                    maxResults: params.maxResults
                  });
                } else {
                  configuration.permissions = (params.permissions || []).concat(data.permissions);
                  self2.updateAgentConfiguration(configuration);
                }
              },
              failure: function(err, data) {
                connect2.getLog().error("Failed to fetch agent permissions list.").sendInternalLogToServer().withObject({
                  err,
                  data
                });
              },
              authFailure: connect2.hitch(self2, self2.handlePollingAuthFail),
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.pollForDialableCountryCodes = function(configuration, paramsIn) {
            var self2 = this;
            var params = paramsIn || {};
            params.maxResults = params.maxResults || connect2.DEFAULT_BATCH_SIZE;
            this.client.call(connect2.ClientMethods.GET_DIALABLE_COUNTRY_CODES, {
              nextToken: params.nextToken || null,
              maxResults: params.maxResults
            }, {
              success: function(data) {
                if (data.nextToken) {
                  self2.pollForDialableCountryCodes(configuration, {
                    countryCodes: (params.countryCodes || []).concat(data.countryCodes),
                    nextToken: data.nextToken,
                    maxResults: params.maxResults
                  });
                } else {
                  configuration.dialableCountries = (params.countryCodes || []).concat(data.countryCodes);
                  self2.updateAgentConfiguration(configuration);
                }
              },
              failure: function(err, data) {
                connect2.getLog().error("Failed to fetch dialable country codes list.").sendInternalLogToServer().withObject({
                  err,
                  data
                });
              },
              authFailure: connect2.hitch(self2, self2.handlePollingAuthFail),
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.pollForRoutingProfileQueues = function(configuration, paramsIn) {
            var self2 = this;
            var params = paramsIn || {};
            params.maxResults = params.maxResults || connect2.DEFAULT_BATCH_SIZE;
            this.client.call(connect2.ClientMethods.GET_ROUTING_PROFILE_QUEUES, {
              routingProfileARN: configuration.routingProfile.routingProfileARN,
              nextToken: params.nextToken || null,
              maxResults: params.maxResults
            }, {
              success: function(data) {
                if (data.nextToken) {
                  self2.pollForRoutingProfileQueues(configuration, {
                    countryCodes: (params.queues || []).concat(data.queues),
                    nextToken: data.nextToken,
                    maxResults: params.maxResults
                  });
                } else {
                  configuration.routingProfile.queues = (params.queues || []).concat(data.queues);
                  self2.updateAgentConfiguration(configuration);
                }
              },
              failure: function(err, data) {
                connect2.getLog().error("Failed to fetch routing profile queues list.").sendInternalLogToServer().withObject({
                  err,
                  data
                });
              },
              authFailure: connect2.hitch(self2, self2.handlePollingAuthFail),
              accessDenied: connect2.hitch(self2, self2.handleAccessDenied)
            });
          };
          ClientEngine.prototype.handleAPIRequest = function(portConduit, request) {
            var self2 = this;
            this.client.call(request.method, request.params, {
              success: function(data) {
                var response = connect2.EventFactory.createResponse(connect2.EventType.API_RESPONSE, request, data);
                portConduit.sendDownstream(response.event, response);
              },
              failure: function(err, data) {
                var response = connect2.EventFactory.createResponse(connect2.EventType.API_RESPONSE, request, data, JSON.stringify(err));
                portConduit.sendDownstream(response.event, response);
                connect2.getLog().error("'%s' API request failed", request.method).withObject({ request: self2.filterAuthToken(request), response }).withException(err).sendInternalLogToServer();
              },
              authFailure: connect2.hitch(self2, self2.handleAuthFail, { authorize: true })
            });
          };
          ClientEngine.prototype.handleMasterRequest = function(portConduit, portId, request) {
            var multiplexerConduit = this.conduit;
            var response = null;
            switch (request.method) {
              case connect2.MasterMethods.BECOME_MASTER:
                var masterId = this.masterCoord.getMaster(request.params.topic);
                var takeOver = Boolean(masterId) && masterId !== portId;
                this.masterCoord.setMaster(request.params.topic, portId);
                response = connect2.EventFactory.createResponse(connect2.EventType.MASTER_RESPONSE, request, {
                  masterId: portId,
                  takeOver,
                  topic: request.params.topic
                });
                if (takeOver) {
                  multiplexerConduit.sendDownstream(response.event, response);
                }
                break;
              case connect2.MasterMethods.CHECK_MASTER:
                var masterId = this.masterCoord.getMaster(request.params.topic);
                if (!masterId && !request.params.shouldNotBecomeMasterIfNone) {
                  this.masterCoord.setMaster(request.params.topic, portId);
                  masterId = portId;
                }
                response = connect2.EventFactory.createResponse(connect2.EventType.MASTER_RESPONSE, request, {
                  masterId,
                  isMaster: portId === masterId,
                  topic: request.params.topic
                });
                break;
              default:
                throw new Error("Unknown master method: " + request.method);
            }
            portConduit.sendDownstream(response.event, response);
          };
          ClientEngine.prototype.handleTabIdEvent = function(stream, data) {
            var self2 = this;
            try {
              let tabId = data.tabId;
              let streamsInThisTab = self2.streamMapByTabId[tabId];
              let currentStreamId = stream.getId();
              let tabIds = Object.keys(self2.streamMapByTabId);
              let streamsTabsAcrossBrowser = tabIds.filter((tabId2) => self2.streamMapByTabId[tabId2].length > 0).length;
              if (streamsInThisTab && streamsInThisTab.length > 0) {
                if (!streamsInThisTab.includes(currentStreamId)) {
                  self2.streamMapByTabId[tabId].push(currentStreamId);
                  let updateObject = { length: Object.keys(self2.portConduitMap).length, tabId, streamsTabsAcrossBrowser };
                  updateObject[tabId] = { length: streamsInThisTab.length };
                  self2.conduit.sendDownstream(connect2.EventType.UPDATE_CONNECTED_CCPS, updateObject);
                }
              } else {
                self2.streamMapByTabId[tabId] = [stream.getId()];
                let updateObject = { length: Object.keys(self2.portConduitMap).length, tabId, streamsTabsAcrossBrowser: streamsTabsAcrossBrowser + 1 };
                updateObject[tabId] = { length: self2.streamMapByTabId[tabId].length };
                self2.conduit.sendDownstream(connect2.EventType.UPDATE_CONNECTED_CCPS, updateObject);
              }
            } catch (e) {
              connect2.getLog().error("[Tab Ids] Issue updating connected CCPs within the same tab").withException(e).sendInternalLogToServer();
            }
          };
          ClientEngine.prototype.handleCloseEvent = function(stream) {
            var self2 = this;
            self2.multiplexer.removeStream(stream);
            delete self2.portConduitMap[stream.getId()];
            self2.masterCoord.removeMaster(stream.getId());
            let updateObject = { length: Object.keys(self2.portConduitMap).length };
            let tabIds = Object.keys(self2.streamMapByTabId);
            try {
              let tabId = tabIds.find((key) => self2.streamMapByTabId[key].includes(stream.getId()));
              if (tabId) {
                let streamIndexInMap = self2.streamMapByTabId[tabId].findIndex((value) => stream.getId() === value);
                self2.streamMapByTabId[tabId].splice(streamIndexInMap, 1);
                let tabLength = self2.streamMapByTabId[tabId] ? self2.streamMapByTabId[tabId].length : 0;
                updateObject[tabId] = { length: tabLength };
                updateObject.tabId = tabId;
              }
              let streamsTabsAcrossBrowser = tabIds.filter((tabId2) => self2.streamMapByTabId[tabId2].length > 0).length;
              updateObject.streamsTabsAcrossBrowser = streamsTabsAcrossBrowser;
            } catch (e) {
              connect2.getLog().error("[Tab Ids] Issue updating tabId-specific stream data").withException(e).sendInternalLogToServer();
            }
            self2.conduit.sendDownstream(connect2.EventType.UPDATE_CONNECTED_CCPS, updateObject);
          };
          ClientEngine.prototype.updateAgentConfiguration = function(configuration) {
            if (configuration.permissions && configuration.dialableCountries && configuration.agentStates && configuration.routingProfile.queues) {
              this.agent = this.agent || {};
              this.agent.configuration = configuration;
              this.updateAgent();
            } else {
              connect2.getLog().trace("Waiting to update agent configuration until all config data has been fetched.").sendInternalLogToServer();
            }
          };
          ClientEngine.prototype.updateAgent = function() {
            if (!this.agent) {
              connect2.getLog().trace("Waiting to update agent until the agent has been fully constructed.").sendInternalLogToServer();
            } else if (!this.agent.snapshot) {
              connect2.getLog().trace("Waiting to update agent until the agent snapshot is available.").sendInternalLogToServer();
            } else if (!this.agent.configuration) {
              connect2.getLog().trace("Waiting to update agent until the agent configuration is available.").sendInternalLogToServer();
            } else {
              this.agent.snapshot.status = this.agent.state;
              if (this.agent.snapshot.contacts && this.agent.snapshot.contacts.length > 1) {
                this.agent.snapshot.contacts.sort(function(contactA, contactB) {
                  return contactA.state.timestamp.getTime() - contactB.state.timestamp.getTime();
                });
              }
              this.agent.snapshot.contacts.forEach(function(contact) {
                contact.status = contact.state;
                contact.connections.forEach(function(connection) {
                  connection.address = connection.endpoint;
                });
              });
              this.agent.configuration.routingProfile.defaultOutboundQueue.queueId = this.agent.configuration.routingProfile.defaultOutboundQueue.queueARN;
              this.agent.configuration.routingProfile.queues.forEach(function(queue) {
                queue.queueId = queue.queueARN;
              });
              this.agent.snapshot.contacts.forEach(function(contact) {
                if (contact.queue !== void 0) {
                  contact.queue.queueId = contact.queue.queueARN;
                }
              });
              this.agent.configuration.routingProfile.routingProfileId = this.agent.configuration.routingProfile.routingProfileARN;
              if (this.suppress) {
                this.agent.snapshot.contacts = this.agent.snapshot.contacts.filter(function(contact) {
                  return contact.state.type == connect2.ContactStateType.CONNECTED || contact.state.type == connect2.ContactStateType.ENDED;
                });
                if (this.forceOffline) {
                  this.conduit.sendDownstream(connect2.DisasterRecoveryEvents.FORCE_OFFLINE);
                }
              }
              this.conduit.sendDownstream(connect2.AgentEvents.UPDATE, this.agent);
            }
          };
          ClientEngine.prototype.getWebSocketUrl = function() {
            var self2 = this;
            var client = connect2.core.getClient();
            var onAuthFail = connect2.hitch(self2, self2.handleAuthFail);
            var onAccessDenied = connect2.hitch(self2, self2.handleAccessDenied);
            return new Promise(function(resolve, reject) {
              client.call(connect2.ClientMethods.CREATE_TRANSPORT, { transportType: connect2.TRANSPORT_TYPES.WEB_SOCKET }, {
                success: function(data) {
                  connect2.getLog().info("getWebSocketUrl succeeded").sendInternalLogToServer();
                  resolve(data);
                },
                failure: function(err, data) {
                  connect2.getLog().error("getWebSocketUrl failed").sendInternalLogToServer().withObject({
                    err,
                    data
                  });
                  reject({
                    reason: "getWebSocketUrl failed",
                    _debug: err
                  });
                },
                authFailure: function() {
                  connect2.getLog().error("getWebSocketUrl Auth Failure").sendInternalLogToServer();
                  reject(Error("Authentication failed while getting getWebSocketUrl"));
                  onAuthFail();
                },
                accessDenied: function() {
                  connect2.getLog().error("getWebSocketUrl Access Denied Failure").sendInternalLogToServer();
                  reject(Error("Access Denied Failure while getting getWebSocketUrl"));
                  onAccessDenied();
                }
              });
            });
          };
          ClientEngine.prototype.handleSendLogsRequest = function() {
            var self2 = this;
            var logEvents = [];
            var logsToSend = self2.logsBuffer.slice();
            self2.logsBuffer = [];
            logsToSend.forEach(function(log2) {
              logEvents.push({
                timestamp: log2.time,
                component: log2.component,
                message: log2.text
              });
            });
            this.client.call(connect2.ClientMethods.SEND_CLIENT_LOGS, { logEvents }, {
              success: function(data) {
                connect2.getLog().info("SendLogs request succeeded.").sendInternalLogToServer();
              },
              failure: function(err, data) {
                connect2.getLog().error("SendLogs request failed.").withObject(data).withException(err).sendInternalLogToServer();
              },
              authFailure: connect2.hitch(self2, self2.handleAuthFail)
            });
          };
          ClientEngine.prototype.handleAuthFail = function(data) {
            var self2 = this;
            if (data) {
              self2.conduit.sendDownstream(connect2.EventType.AUTH_FAIL, data);
            } else {
              self2.conduit.sendDownstream(connect2.EventType.AUTH_FAIL);
            }
          };
          ClientEngine.prototype.handlePollingAuthFail = function() {
            var self2 = this;
            self2.conduit.sendDownstream(connect2.EventType.CTI_AUTHORIZE_RETRIES_EXHAUSTED);
          };
          ClientEngine.prototype.handleAccessDenied = function() {
            var self2 = this;
            self2.conduit.sendDownstream(connect2.EventType.ACCESS_DENIED);
          };
          ClientEngine.prototype.checkAuthToken = function() {
            var self2 = this;
            var expirationDate = new Date(self2.initData.authTokenExpiration);
            var currentTimeStamp = (/* @__PURE__ */ new Date()).getTime();
            var thirtyMins = 30 * 60 * 1e3;
            if (expirationDate.getTime() < currentTimeStamp + thirtyMins) {
              connect2.getLog().info("Auth token expires at " + expirationDate + " Start refreshing token with retry.").sendInternalLogToServer();
              connect2.backoff(connect2.hitch(self2, self2.authorize), REFRESH_AUTH_TOKEN_INTERVAL_MS, REFRESH_AUTH_TOKEN_MAX_TRY);
            }
          };
          ClientEngine.prototype.authorize = function(callbacks) {
            var self2 = this;
            connect2.core.authorize(this.initData.authorizeEndpoint).then(function(response) {
              var expiration = new Date(response.expiration);
              connect2.getLog().info("Authorization succeeded and the token expires at %s", expiration).sendInternalLogToServer();
              self2.initData.authToken = response.accessToken;
              self2.initData.authTokenExpiration = expiration;
              connect2.core.initClient(self2.initData);
              connect2.core.initAgentAppClient(self2.initData);
              callbacks.success();
            }).catch(function(response) {
              connect2.getLog().error("Authorization failed with code %s", response.status).sendInternalLogToServer();
              if (response.status === 401) {
                self2.handleAuthFail();
              } else {
                callbacks.failure();
              }
            });
          };
          ClientEngine.prototype.filterAuthToken = function(request) {
            var new_request = {};
            for (var keyA in request) {
              if (keyA === "params") {
                var new_params = {};
                for (var keyB in request.params) {
                  if (keyB !== "authentication") {
                    new_params[keyB] = request.params[keyB];
                  }
                }
                new_request.params = new_params;
              } else {
                new_request[keyA] = request[keyA];
              }
            }
            return new_request;
          };
          connect2.worker.main = function() {
            connect2.worker.clientEngine = new ClientEngine();
          };
        })();
      }
    )
    /******/
  };
  var __webpack_module_cache__ = {};
  function __webpack_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== void 0) {
      return cachedModule.exports;
    }
    var module = __webpack_module_cache__[moduleId] = {
      /******/
      // no module.id needed
      /******/
      // no module.loaded needed
      /******/
      exports: {}
      /******/
    };
    __webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
    return module.exports;
  }
  (() => {
    __webpack_require__.g = function() {
      if (typeof globalThis === "object")
        return globalThis;
      try {
        return this || new Function("return this")();
      } catch (e) {
        if (typeof window === "object")
          return window;
      }
    }();
  })();
  __webpack_require__(827);
  __webpack_require__(163);
  __webpack_require__(944);
  __webpack_require__(151);
  __webpack_require__(891);
  __webpack_require__(592);
  __webpack_require__(82);
  __webpack_require__(754);
  __webpack_require__(833);
  __webpack_require__(161);
  __webpack_require__(965);
  __webpack_require__(286);
  __webpack_require__(895);
  __webpack_require__(743);
  __webpack_require__(642);
  __webpack_require__(736);
  __webpack_require__(439);
  __webpack_require__(279);
  __webpack_require__(418);
  __webpack_require__(187);
  __webpack_require__(821);
  var __webpack_exports__ = __webpack_require__(500);
})();
/*! Bundled license information:

amazon-connect-streams/release/connect-streams.js:
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <http://feross.org>
   * @license  MIT
   *)
  (*! https://mths.be/punycode v1.4.1 by @mathias *)
  (*! @license sprintf.js | Copyright (c) 2007-2013 Alexandru Marasteanu <hello at alexei dot ro> | 3 clause BSD license *)
*/
//# sourceMappingURL=amazon-connect-streams.js.map
